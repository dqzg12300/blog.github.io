<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>jni函数动态注册分析 | king的博客</title><meta name="author" content="king"><meta name="copyright" content="king"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="动态注册jni函数时的流程学习过程的记录，以下代码参考自aosp8.1 jni函数绑定主要是有两种方式。静态注册和动态注册的jni函数 静态注册的jni函数有两次绑定，在类加载时会绑定一次，在jni函数第一次被调用时，art会对jni函数的地址进行查询并绑定 动态注册的jni函数也有两次绑定，在类加载时绑定一次，第二次由开发人员的代码主动绑定。">
<meta property="og:type" content="article">
<meta property="og:title" content="jni函数动态注册分析">
<meta property="og:url" content="http://missking.cc/2020/08/30/JNI-DexClassLoader/index.html">
<meta property="og:site_name" content="king的博客">
<meta property="og:description" content="动态注册jni函数时的流程学习过程的记录，以下代码参考自aosp8.1 jni函数绑定主要是有两种方式。静态注册和动态注册的jni函数 静态注册的jni函数有两次绑定，在类加载时会绑定一次，在jni函数第一次被调用时，art会对jni函数的地址进行查询并绑定 动态注册的jni函数也有两次绑定，在类加载时绑定一次，第二次由开发人员的代码主动绑定。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2020-08-30T21:43:17.000Z">
<meta property="article:modified_time" content="2022-09-05T12:58:30.585Z">
<meta property="article:author" content="king">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://missking.cc/2020/08/30/JNI-DexClassLoader/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'jni函数动态注册分析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-05 12:58:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/assets/blogImg/litten.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">king的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">jni函数动态注册分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-08-30T21:43:17.000Z" title="发表于 2020-08-30 21:43:17">2020-08-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-05T12:58:30.585Z" title="更新于 2022-09-05 12:58:30">2022-09-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/android/">android</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="jni函数动态注册分析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="动态注册jni函数时的流程"><a href="#动态注册jni函数时的流程" class="headerlink" title="动态注册jni函数时的流程"></a>动态注册jni函数时的流程</h3><p>学习过程的记录，以下代码参考自aosp8.1</p>
<p>jni函数绑定主要是有两种方式。静态注册和动态注册的jni函数</p>
<p>静态注册的jni函数有两次绑定，在类加载时会绑定一次，在jni函数第一次被调用时，art会对jni函数的地址进行查询并绑定</p>
<p>动态注册的jni函数也有两次绑定，在类加载时绑定一次，第二次由开发人员的代码主动绑定。</p>
<a id="more"></a>

<p>DexClassLoader是安卓的一种类加载器，然后用他的loadClass函数来进行类加载处理，而DexClassLoader中没有看到loadClass函数。通过在父类中寻找。最终发现loadClass在ClassLoad类中。继承关系如下</p>
<p>DexClassLoader–&gt;BaseDexClassLoader–&gt;ClassLoader</p>
<p>然后开始看看loadClass的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">     <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了两个参数的重载。继续看另外一个重载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line">                                <span class="comment">//初次加载时，c肯定是null，必然走的findClass</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>初次加载时，必然是取不到这个class的。所以初次执行时，必然走的findClass。所以接下来找这个findClass的代码，这个findClass的实现在BaseDexClassLoader中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        List&lt;Throwable&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;Throwable&gt;();</span><br><span class="line">        Class c = pathList.findClass(name, suppressedExceptions);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ClassNotFoundException cnfe = <span class="keyword">new</span> ClassNotFoundException(</span><br><span class="line">                    <span class="string">&quot;Didn&#x27;t find class \&quot;&quot;</span> + name + <span class="string">&quot;\&quot; on path: &quot;</span> + pathList);</span><br><span class="line">            <span class="keyword">for</span> (Throwable t : suppressedExceptions) &#123;</span><br><span class="line">                cnfe.addSuppressed(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> cnfe;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面我们可以看到关键的一句</p>
<p><code> Class c = pathList.findClass(name, suppressedExceptions);</code></p>
<p>Class c又是调用的pathList.findClass，继续找pathList的findClass，</p>
<p><code>DexPathList pathList</code></p>
<p>找到这个pathList的定义后，继续去DexPathList找findClass的函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">        DexPathList.Element[] arr$ = <span class="keyword">this</span>.dexElements;</span><br><span class="line">        <span class="keyword">int</span> len$ = arr$.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i$ = <span class="number">0</span>; i$ &lt; len$; ++i$) &#123;</span><br><span class="line">            DexPathList.Element element = arr$[i$];</span><br><span class="line">            DexFile dex = element.dexFile;</span><br><span class="line">            <span class="keyword">if</span> (dex != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Class clazz = dex.loadClassBinaryName(name, <span class="keyword">this</span>.definingContext, suppressed);</span><br><span class="line">                <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.dexElementsSuppressedExceptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">            suppressed.addAll(Arrays.asList(<span class="keyword">this</span>.dexElementsSuppressedExceptions));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>下面是关键的class来源。</p>
<p><code>Class clazz = dex.loadClassBinaryName(name, this.definingContext, suppressed);</code></p>
<p>这里可以看到clazz的来源，然后继续找loadClassBinaryName，在DexFile中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">loadClassBinaryName</span><span class="params">(String name, ClassLoader loader, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, loader, <span class="keyword">this</span>.mCookie, suppressed);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然后继续看defineClass的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Class <span class="title">defineClass</span><span class="params">(String name, ClassLoader loader, <span class="keyword">long</span> cookie, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">        Class result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = defineClassNative(name, loader, cookie);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoClassDefFoundError var7) &#123;</span><br><span class="line">            <span class="keyword">if</span> (suppressed != <span class="keyword">null</span>) &#123;</span><br><span class="line">                suppressed.add(var7);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var8) &#123;</span><br><span class="line">            <span class="keyword">if</span> (suppressed != <span class="keyword">null</span>) &#123;</span><br><span class="line">                suppressed.add(var8);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然后继续看defineClassNative的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Class <span class="title">defineClassNative</span><span class="params">(String var0, ClassLoader var1, <span class="keyword">long</span> var2)</span> <span class="keyword">throws</span> ClassNotFoundException, NoClassDefFoundError</span>;</span><br></pre></td></tr></table></figure>

<p>这里这个defineClassNative是一个native函数了。那么实现的代码就要去找c++代码了。DexFile的对应c++代码在dalvik_system_DexFile.cc中。继续找c++的实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jclass <span class="title">DexFile_defineClassNative</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        jclass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        jstring javaName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        jobject javaLoader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        jobject cookie,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        jobject dexFile)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> DexFile*&gt; dex_files;</span><br><span class="line">  <span class="keyword">const</span> OatFile* oat_file;</span><br><span class="line">  <span class="keyword">if</span> (!ConvertJavaArrayToDexFiles(env, cookie, <span class="comment">/*out*/</span> dex_files, <span class="comment">/*out*/</span> oat_file)) &#123;</span><br><span class="line">    VLOG(class_linker) &lt;&lt; <span class="string">&quot;Failed to find dex_file&quot;</span>;</span><br><span class="line">    DCHECK(env-&gt;ExceptionCheck());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">ScopedUtfChars <span class="title">class_name</span><span class="params">(env, javaName)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (class_name.c_str() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    VLOG(class_linker) &lt;&lt; <span class="string">&quot;Failed to find class_name&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">descriptor</span><span class="params">(DotToDescriptor(class_name.c_str()))</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">size_t</span> <span class="title">hash</span><span class="params">(ComputeModifiedUtf8Hash(descriptor.c_str()))</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; dex_file : dex_files) &#123;</span><br><span class="line">    <span class="keyword">const</span> DexFile::ClassDef* dex_class_def =</span><br><span class="line">        OatDexFile::FindClassDef(*dex_file, descriptor.c_str(), hash);</span><br><span class="line">    <span class="keyword">if</span> (dex_class_def != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="function">ScopedObjectAccess <span class="title">soa</span><span class="params">(env)</span></span>;</span><br><span class="line">      ClassLinker* class_linker = Runtime::Current()-&gt;GetClassLinker();</span><br><span class="line">      <span class="function">StackHandleScope&lt;1&gt; <span class="title">hs</span><span class="params">(soa.Self())</span></span>;</span><br><span class="line">      <span class="function">Handle&lt;mirror::ClassLoader&gt; <span class="title">class_loader</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          hs.NewHandle(soa.Decode&lt;mirror::ClassLoader&gt;(javaLoader)))</span></span>;</span><br><span class="line">      ObjPtr&lt;mirror::DexCache&gt; dex_cache =</span><br><span class="line">          class_linker-&gt;RegisterDexFile(*dex_file, class_loader.Get());</span><br><span class="line">      <span class="keyword">if</span> (dex_cache == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// OOME or InternalError (dexFile already registered with a different class loader).</span></span><br><span class="line">        soa.Self()-&gt;AssertPendingException();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ObjPtr&lt;mirror::Class&gt; result = class_linker-&gt;DefineClass(soa.Self(),</span><br><span class="line">                                                               descriptor.c_str(),</span><br><span class="line">                                                               hash,</span><br><span class="line">                                                               class_loader,</span><br><span class="line">                                                               *dex_file,</span><br><span class="line">                                                               *dex_class_def);</span><br><span class="line">      <span class="comment">// Add the used dex file. This only required for the DexFile.loadClass API since normal</span></span><br><span class="line">      <span class="comment">// class loaders already keep their dex files live.</span></span><br><span class="line">      class_linker-&gt;InsertDexFileInToClassLoader(soa.Decode&lt;mirror::Object&gt;(dexFile),</span><br><span class="line">                                                 class_loader.Get());</span><br><span class="line">      <span class="keyword">if</span> (result != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        VLOG(class_linker) &lt;&lt; <span class="string">&quot;DexFile_defineClassNative returning &quot;</span> &lt;&lt; result</span><br><span class="line">                           &lt;&lt; <span class="string">&quot; for &quot;</span> &lt;&lt; class_name.c_str();</span><br><span class="line">        <span class="keyword">return</span> soa.AddLocalReference&lt;jclass&gt;(result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  VLOG(class_linker) &lt;&lt; <span class="string">&quot;Failed to find dex_class_def &quot;</span> &lt;&lt; class_name.c_str();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里这段代码比较多。下面是关键代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjPtr&lt;mirror::Class&gt; result = class_linker-&gt;DefineClass(soa.Self(),                                   descriptor.c_str(),                                          hash,                                               class_loader,                                                *dex_file,                                             *dex_class_def);</span><br></pre></td></tr></table></figure>

<p>继续看DefineClass的实现代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">mirror::Class* <span class="title">ClassLinker::DefineClass</span><span class="params">(Thread* self,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> <span class="keyword">char</span>* descriptor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">size_t</span> hash,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Handle&lt;mirror::ClassLoader&gt; class_loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> DexFile&amp; dex_file,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> DexFile::ClassDef&amp; dex_class_def)</span> </span>&#123;</span><br><span class="line">  <span class="function">StackHandleScope&lt;3&gt; <span class="title">hs</span><span class="params">(self)</span></span>;</span><br><span class="line">  <span class="keyword">auto</span> klass = hs.NewHandle&lt;mirror::Class&gt;(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Load the class from the dex file.</span></span><br><span class="line">  <span class="keyword">if</span> (UNLIKELY(!init_done_)) &#123;</span><br><span class="line">    <span class="comment">// finish up init of hand crafted class_roots_</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(descriptor, <span class="string">&quot;Ljava/lang/Object;&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      klass.Assign(GetClassRoot(kJavaLangObject));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(descriptor, <span class="string">&quot;Ljava/lang/Class;&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      klass.Assign(GetClassRoot(kJavaLangClass));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(descriptor, <span class="string">&quot;Ljava/lang/String;&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      klass.Assign(GetClassRoot(kJavaLangString));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(descriptor, <span class="string">&quot;Ljava/lang/ref/Reference;&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      klass.Assign(GetClassRoot(kJavaLangRefReference));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(descriptor, <span class="string">&quot;Ljava/lang/DexCache;&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      klass.Assign(GetClassRoot(kJavaLangDexCache));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(descriptor, <span class="string">&quot;Ldalvik/system/ClassExt;&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      klass.Assign(GetClassRoot(kDalvikSystemClassExt));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (klass == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// Allocate a class with the status of not ready.</span></span><br><span class="line">    <span class="comment">// Interface object should get the right size here. Regular class will</span></span><br><span class="line">    <span class="comment">// figure out the right size later and be replaced with one of the right</span></span><br><span class="line">    <span class="comment">// size when the class becomes resolved.</span></span><br><span class="line">    klass.Assign(AllocClass(self, SizeOfClassWithoutEmbeddedTables(dex_file, dex_class_def)));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (UNLIKELY(klass == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    self-&gt;AssertPendingOOMException();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Get the real dex file. This will return the input if there aren&#x27;t any callbacks or they do</span></span><br><span class="line">  <span class="comment">// nothing.</span></span><br><span class="line">  DexFile <span class="keyword">const</span>* new_dex_file = <span class="literal">nullptr</span>;</span><br><span class="line">  DexFile::ClassDef <span class="keyword">const</span>* new_class_def = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// TODO We should ideally figure out some way to move this after we get a lock on the klass so it</span></span><br><span class="line">  <span class="comment">// will only be called once.</span></span><br><span class="line">  Runtime::Current()-&gt;GetRuntimeCallbacks()-&gt;ClassPreDefine(descriptor,</span><br><span class="line">                                                            klass,</span><br><span class="line">                                                            class_loader,</span><br><span class="line">                                                            dex_file,</span><br><span class="line">                                                            dex_class_def,</span><br><span class="line">                                                            &amp;new_dex_file,</span><br><span class="line">                                                            &amp;new_class_def);</span><br><span class="line">  <span class="comment">// Check to see if an exception happened during runtime callbacks. Return if so.</span></span><br><span class="line">  <span class="keyword">if</span> (self-&gt;IsExceptionPending()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ObjPtr&lt;mirror::DexCache&gt; dex_cache = RegisterDexFile(*new_dex_file, class_loader.Get());</span><br><span class="line">  <span class="keyword">if</span> (dex_cache == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    self-&gt;AssertPendingException();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  klass-&gt;SetDexCache(dex_cache);</span><br><span class="line">  SetupClass(*new_dex_file, *new_class_def, klass, class_loader.Get());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Mark the string class by setting its access flag.</span></span><br><span class="line">  <span class="keyword">if</span> (UNLIKELY(!init_done_)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(descriptor, <span class="string">&quot;Ljava/lang/String;&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      klass-&gt;SetStringClass();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">ObjectLock&lt;mirror::Class&gt; <span class="title">lock</span><span class="params">(self, klass)</span></span>;</span><br><span class="line">  klass-&gt;SetClinitThreadId(self-&gt;GetTid());</span><br><span class="line">  <span class="comment">// Make sure we have a valid empty iftable even if there are errors.</span></span><br><span class="line">  klass-&gt;SetIfTable(GetClassRoot(kJavaLangObject)-&gt;GetIfTable());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add the newly loaded class to the loaded classes table.</span></span><br><span class="line">  ObjPtr&lt;mirror::Class&gt; existing = InsertClass(descriptor, klass.Get(), hash);</span><br><span class="line">  <span class="keyword">if</span> (existing != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// We failed to insert because we raced with another thread. Calling EnsureResolved may cause</span></span><br><span class="line">    <span class="comment">// this thread to block.</span></span><br><span class="line">    <span class="keyword">return</span> EnsureResolved(self, descriptor, existing);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Load the fields and other things after we are inserted in the table. This is so that we don&#x27;t</span></span><br><span class="line">  <span class="comment">// end up allocating unfree-able linear alloc resources and then lose the race condition. The</span></span><br><span class="line">  <span class="comment">// other reason is that the field roots are only visited from the class table. So we need to be</span></span><br><span class="line">  <span class="comment">// inserted before we allocate / fill in these fields.</span></span><br><span class="line">  LoadClass(self, *new_dex_file, *new_class_def, klass);</span><br><span class="line">  <span class="keyword">if</span> (self-&gt;IsExceptionPending()) &#123;</span><br><span class="line">    VLOG(class_linker) &lt;&lt; self-&gt;GetException()-&gt;Dump();</span><br><span class="line">    <span class="comment">// An exception occured during load, set status to erroneous while holding klass&#x27; lock in case</span></span><br><span class="line">    <span class="comment">// notification is necessary.</span></span><br><span class="line">    <span class="keyword">if</span> (!klass-&gt;IsErroneous()) &#123;</span><br><span class="line">      mirror::Class::SetStatus(klass, mirror::Class::kStatusErrorUnresolved, self);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Finish loading (if necessary) by finding parents</span></span><br><span class="line">  CHECK(!klass-&gt;IsLoaded());</span><br><span class="line">  <span class="keyword">if</span> (!LoadSuperAndInterfaces(klass, *new_dex_file)) &#123;</span><br><span class="line">    <span class="comment">// Loading failed.</span></span><br><span class="line">    <span class="keyword">if</span> (!klass-&gt;IsErroneous()) &#123;</span><br><span class="line">      mirror::Class::SetStatus(klass, mirror::Class::kStatusErrorUnresolved, self);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  CHECK(klass-&gt;IsLoaded());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// At this point the class is loaded. Publish a ClassLoad event.</span></span><br><span class="line">  <span class="comment">// Note: this may be a temporary class. It is a listener&#x27;s responsibility to handle this.</span></span><br><span class="line">  Runtime::Current()-&gt;GetRuntimeCallbacks()-&gt;ClassLoad(klass);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Link the class (if necessary)</span></span><br><span class="line">  CHECK(!klass-&gt;IsResolved());</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Use fast jobjects?</span></span><br><span class="line">  <span class="keyword">auto</span> interfaces = hs.NewHandle&lt;mirror::ObjectArray&lt;mirror::Class&gt;&gt;(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  MutableHandle&lt;mirror::Class&gt; h_new_class = hs.NewHandle&lt;mirror::Class&gt;(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span> (!LinkClass(self, descriptor, klass, interfaces, &amp;h_new_class)) &#123;</span><br><span class="line">    <span class="comment">// Linking failed.</span></span><br><span class="line">    <span class="keyword">if</span> (!klass-&gt;IsErroneous()) &#123;</span><br><span class="line">      mirror::Class::SetStatus(klass, mirror::Class::kStatusErrorUnresolved, self);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  self-&gt;AssertNoPendingException();</span><br><span class="line">  CHECK(h_new_class != <span class="literal">nullptr</span>) &lt;&lt; descriptor;</span><br><span class="line">  CHECK(h_new_class-&gt;IsResolved() &amp;&amp; !h_new_class-&gt;IsErroneousResolved()) &lt;&lt; descriptor;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Instrumentation may have updated entrypoints for all methods of all</span></span><br><span class="line">  <span class="comment">// classes. However it could not update methods of this class while we</span></span><br><span class="line">  <span class="comment">// were loading it. Now the class is resolved, we can update entrypoints</span></span><br><span class="line">  <span class="comment">// as required by instrumentation.</span></span><br><span class="line">  <span class="keyword">if</span> (Runtime::Current()-&gt;GetInstrumentation()-&gt;AreExitStubsInstalled()) &#123;</span><br><span class="line">    <span class="comment">// We must be in the kRunnable state to prevent instrumentation from</span></span><br><span class="line">    <span class="comment">// suspending all threads to update entrypoints while we are doing it</span></span><br><span class="line">    <span class="comment">// for this class.</span></span><br><span class="line">    DCHECK_EQ(self-&gt;GetState(), kRunnable);</span><br><span class="line">    Runtime::Current()-&gt;GetInstrumentation()-&gt;InstallStubsForClass(h_new_class.Get());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * We send CLASS_PREPARE events to the debugger from here.  The</span></span><br><span class="line"><span class="comment">   * definition of &quot;preparation&quot; is creating the static fields for a</span></span><br><span class="line"><span class="comment">   * class and initializing them to the standard default values, but not</span></span><br><span class="line"><span class="comment">   * executing any code (that comes later, during &quot;initialization&quot;).</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * We did the static preparation in LinkClass.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * The class has been prepared and resolved but possibly not yet verified</span></span><br><span class="line"><span class="comment">   * at this point.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Runtime::Current()-&gt;GetRuntimeCallbacks()-&gt;ClassPrepare(klass, h_new_class);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Notify native debugger of the new class and its layout.</span></span><br><span class="line">  jit::Jit::NewTypeLoadedIfUsingJit(h_new_class.Get());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> h_new_class.Get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一段代码比较多，可以从descriptor的使用看出，这个参数是要加载的类描述 。但是关键点也很明显，那就是LoadClass。</p>
<p><code>LoadClass(self, *new_dex_file, *new_class_def, klass);</code></p>
<p>继续看LoadClass的实现代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClassLinker::LoadClass</span><span class="params">(Thread* self,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> DexFile&amp; dex_file,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> DexFile::ClassDef&amp; dex_class_def,</span></span></span><br><span class="line"><span class="function"><span class="params">                            Handle&lt;mirror::Class&gt; klass)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint8_t</span>* class_data = dex_file.GetClassData(dex_class_def);</span><br><span class="line">  <span class="keyword">if</span> (class_data == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">// no fields or methods - for example a marker interface</span></span><br><span class="line">  &#125;</span><br><span class="line">  LoadClassMembers(self, dex_file, class_data, klass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里就看到了我们关心的加载函数的处理了，LoadClassMembers也就是加载类函数的地方了。继续往下看实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClassLinker::LoadClassMembers</span><span class="params">(Thread* self,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">const</span> DexFile&amp; dex_file,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">const</span> <span class="keyword">uint8_t</span>* class_data,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   Handle&lt;mirror::Class&gt; klass)</span> </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Note: We cannot have thread suspension until the field and method arrays are setup or else</span></span><br><span class="line">    <span class="comment">// Class::VisitFieldRoots may miss some fields or methods.</span></span><br><span class="line">    <span class="function">ScopedAssertNoThreadSuspension <span class="title">nts</span><span class="params">(__FUNCTION__)</span></span>;</span><br><span class="line">    <span class="comment">// Load static fields.</span></span><br><span class="line">    <span class="comment">// We allow duplicate definitions of the same field in a class_data_item</span></span><br><span class="line">    <span class="comment">// but ignore the repeated indexes here, b/21868015.</span></span><br><span class="line">    LinearAlloc* <span class="keyword">const</span> allocator = GetAllocatorForClassLoader(klass-&gt;GetClassLoader());</span><br><span class="line">    <span class="function">ClassDataItemIterator <span class="title">it</span><span class="params">(dex_file, class_data)</span></span>;</span><br><span class="line">    LengthPrefixedArray&lt;ArtField&gt;* sfields = AllocArtFieldArray(self,</span><br><span class="line">                                                                allocator,</span><br><span class="line">                                                                it.NumStaticFields());</span><br><span class="line">    <span class="keyword">size_t</span> num_sfields = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> last_field_idx = <span class="number">0u</span>;</span><br><span class="line">    <span class="keyword">for</span> (; it.HasNextStaticField(); it.Next()) &#123;</span><br><span class="line">      <span class="keyword">uint32_t</span> field_idx = it.GetMemberIndex();</span><br><span class="line">      DCHECK_GE(field_idx, last_field_idx);  <span class="comment">// Ordering enforced by DexFileVerifier.</span></span><br><span class="line">      <span class="keyword">if</span> (num_sfields == <span class="number">0</span> || LIKELY(field_idx &gt; last_field_idx)) &#123;</span><br><span class="line">        DCHECK_LT(num_sfields, it.NumStaticFields());</span><br><span class="line">        LoadField(it, klass, &amp;sfields-&gt;At(num_sfields));</span><br><span class="line">        ++num_sfields;</span><br><span class="line">        last_field_idx = field_idx;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load instance fields.</span></span><br><span class="line">    LengthPrefixedArray&lt;ArtField&gt;* ifields = AllocArtFieldArray(self,</span><br><span class="line">                                                                allocator,</span><br><span class="line">                                                                it.NumInstanceFields());</span><br><span class="line">    <span class="keyword">size_t</span> num_ifields = <span class="number">0u</span>;</span><br><span class="line">    last_field_idx = <span class="number">0u</span>;</span><br><span class="line">    <span class="keyword">for</span> (; it.HasNextInstanceField(); it.Next()) &#123;</span><br><span class="line">      <span class="keyword">uint32_t</span> field_idx = it.GetMemberIndex();</span><br><span class="line">      DCHECK_GE(field_idx, last_field_idx);  <span class="comment">// Ordering enforced by DexFileVerifier.</span></span><br><span class="line">      <span class="keyword">if</span> (num_ifields == <span class="number">0</span> || LIKELY(field_idx &gt; last_field_idx)) &#123;</span><br><span class="line">        DCHECK_LT(num_ifields, it.NumInstanceFields());</span><br><span class="line">        LoadField(it, klass, &amp;ifields-&gt;At(num_ifields));</span><br><span class="line">        ++num_ifields;</span><br><span class="line">        last_field_idx = field_idx;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (UNLIKELY(num_sfields != it.NumStaticFields()) ||</span><br><span class="line">        UNLIKELY(num_ifields != it.NumInstanceFields())) &#123;</span><br><span class="line">      LOG(WARNING) &lt;&lt; <span class="string">&quot;Duplicate fields in class &quot;</span> &lt;&lt; klass-&gt;PrettyDescriptor()</span><br><span class="line">          &lt;&lt; <span class="string">&quot; (unique static fields: &quot;</span> &lt;&lt; num_sfields &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; it.NumStaticFields()</span><br><span class="line">          &lt;&lt; <span class="string">&quot;, unique instance fields: &quot;</span> &lt;&lt; num_ifields &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; it.NumInstanceFields() &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">      <span class="comment">// <span class="doctag">NOTE:</span> Not shrinking the over-allocated sfields/ifields, just setting size.</span></span><br><span class="line">      <span class="keyword">if</span> (sfields != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        sfields-&gt;SetSize(num_sfields);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (ifields != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ifields-&gt;SetSize(num_ifields);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Set the field arrays.</span></span><br><span class="line">    klass-&gt;SetSFieldsPtr(sfields);</span><br><span class="line">    DCHECK_EQ(klass-&gt;NumStaticFields(), num_sfields);</span><br><span class="line">    klass-&gt;SetIFieldsPtr(ifields);</span><br><span class="line">    DCHECK_EQ(klass-&gt;NumInstanceFields(), num_ifields);</span><br><span class="line">    <span class="comment">// Load methods.</span></span><br><span class="line">    <span class="keyword">bool</span> has_oat_class = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> OatFile::OatClass oat_class =</span><br><span class="line">        (Runtime::Current()-&gt;IsStarted() &amp;&amp; !Runtime::Current()-&gt;IsAotCompiler())</span><br><span class="line">            ? OatFile::FindOatClass(dex_file, klass-&gt;GetDexClassDefIndex(), &amp;has_oat_class)</span><br><span class="line">            : OatFile::OatClass::Invalid();</span><br><span class="line">    <span class="keyword">const</span> OatFile::OatClass* oat_class_ptr = has_oat_class ? &amp;oat_class : <span class="literal">nullptr</span>;</span><br><span class="line">    klass-&gt;SetMethodsPtr(</span><br><span class="line">        AllocArtMethodArray(self, allocator, it.NumDirectMethods() + it.NumVirtualMethods()),</span><br><span class="line">        it.NumDirectMethods(),</span><br><span class="line">        it.NumVirtualMethods());</span><br><span class="line">    <span class="keyword">size_t</span> class_def_method_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> last_dex_method_index = DexFile::kDexNoIndex;</span><br><span class="line">    <span class="keyword">size_t</span> last_class_def_method_index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// TODO These should really use the iterators.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; it.HasNextDirectMethod(); i++, it.Next()) &#123;</span><br><span class="line">      ArtMethod* method = klass-&gt;GetDirectMethodUnchecked(i, image_pointer_size_);</span><br><span class="line">      LoadMethod(dex_file, it, klass, method);</span><br><span class="line">      LinkCode(<span class="keyword">this</span>, method, oat_class_ptr, class_def_method_index);</span><br><span class="line">      <span class="keyword">uint32_t</span> it_method_index = it.GetMemberIndex();</span><br><span class="line">      <span class="keyword">if</span> (last_dex_method_index == it_method_index) &#123;</span><br><span class="line">        <span class="comment">// duplicate case</span></span><br><span class="line">        method-&gt;SetMethodIndex(last_class_def_method_index);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        method-&gt;SetMethodIndex(class_def_method_index);</span><br><span class="line">        last_dex_method_index = it_method_index;</span><br><span class="line">        last_class_def_method_index = class_def_method_index;</span><br><span class="line">      &#125;</span><br><span class="line">      class_def_method_index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; it.HasNextVirtualMethod(); i++, it.Next()) &#123;</span><br><span class="line">      ArtMethod* method = klass-&gt;GetVirtualMethodUnchecked(i, image_pointer_size_);</span><br><span class="line">      LoadMethod(dex_file, it, klass, method);</span><br><span class="line">      DCHECK_EQ(class_def_method_index, it.NumDirectMethods() + i);</span><br><span class="line">      LinkCode(<span class="keyword">this</span>, method, oat_class_ptr, class_def_method_index);</span><br><span class="line">      class_def_method_index++;</span><br><span class="line">    &#125;</span><br><span class="line">    DCHECK(!it.HasNext());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Ensure that the card is marked so that remembered sets pick up native roots.</span></span><br><span class="line">  Runtime::Current()-&gt;GetHeap()-&gt;WriteBarrierEveryFieldOf(klass.Get());</span><br><span class="line">  self-&gt;AllowThreadSuspension();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的代码比较多。但是整体内容前面部分是准备好jni函数绑定需要用到的field。后面是函数的加载。下面是函数加载部分的关键部分</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; it.HasNextDirectMethod(); i++, it.Next()) &#123;</span><br><span class="line">      ArtMethod* method = klass-&gt;GetDirectMethodUnchecked(i, image_pointer_size_);</span><br><span class="line">      LoadMethod(dex_file, it, klass, method);</span><br><span class="line">      LinkCode(<span class="keyword">this</span>, method, oat_class_ptr, class_def_method_index);</span><br><span class="line">      <span class="keyword">uint32_t</span> it_method_index = it.GetMemberIndex();</span><br><span class="line">      <span class="keyword">if</span> (last_dex_method_index == it_method_index) &#123;</span><br><span class="line">        <span class="comment">// duplicate case</span></span><br><span class="line">        method-&gt;SetMethodIndex(last_class_def_method_index);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        method-&gt;SetMethodIndex(class_def_method_index);</span><br><span class="line">        last_dex_method_index = it_method_index;</span><br><span class="line">        last_class_def_method_index = class_def_method_index;</span><br><span class="line">      &#125;</span><br><span class="line">      class_def_method_index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; it.HasNextVirtualMethod(); i++, it.Next()) &#123;</span><br><span class="line">      ArtMethod* method = klass-&gt;GetVirtualMethodUnchecked(i, image_pointer_size_);</span><br><span class="line">      LoadMethod(dex_file, it, klass, method);</span><br><span class="line">      DCHECK_EQ(class_def_method_index, it.NumDirectMethods() + i);</span><br><span class="line">      LinkCode(<span class="keyword">this</span>, method, oat_class_ptr, class_def_method_index);</span><br><span class="line">      class_def_method_index++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以大概看出意思，前面是遍历所有普通函数进行加载，后面是遍历所有虚函数进行加载。而加载的方式主要是两段代码，下面列出关键代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LoadMethod(dex_file, it, klass, method);</span><br><span class="line">LinkCode(<span class="keyword">this</span>, method, oat_class_ptr, class_def_method_index);</span><br></pre></td></tr></table></figure>

<p>这两个函数我们都看一下具体实现里面做了些什么，先是LoadMethod的处理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClassLinker::LoadMethod</span><span class="params">(<span class="keyword">const</span> DexFile&amp; dex_file,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> ClassDataItemIterator&amp; it,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Handle&lt;mirror::Class&gt; klass,</span></span></span><br><span class="line"><span class="function"><span class="params">                             ArtMethod* dst)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> dex_method_idx = it.GetMemberIndex();</span><br><span class="line">  <span class="keyword">const</span> DexFile::MethodId&amp; method_id = dex_file.GetMethodId(dex_method_idx);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* method_name = dex_file.StringDataByIdx(method_id.name_idx_);</span><br><span class="line"></span><br><span class="line">  <span class="function">ScopedAssertNoThreadSuspension <span class="title">ants</span><span class="params">(<span class="string">&quot;LoadMethod&quot;</span>)</span></span>;</span><br><span class="line">  dst-&gt;SetDexMethodIndex(dex_method_idx);</span><br><span class="line">  dst-&gt;SetDeclaringClass(klass.Get());</span><br><span class="line">  dst-&gt;SetCodeItemOffset(it.GetMethodCodeItemOffset());</span><br><span class="line"></span><br><span class="line">  dst-&gt;SetDexCacheResolvedMethods(klass-&gt;GetDexCache()-&gt;GetResolvedMethods(), image_pointer_size_);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint32_t</span> access_flags = it.GetMethodAccessFlags();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (UNLIKELY(<span class="built_in">strcmp</span>(<span class="string">&quot;finalize&quot;</span>, method_name) == <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">// Set finalizable flag on declaring class.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;V&quot;</span>, dex_file.GetShorty(method_id.proto_idx_)) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Void return type.</span></span><br><span class="line">      <span class="keyword">if</span> (klass-&gt;GetClassLoader() != <span class="literal">nullptr</span>) &#123;  <span class="comment">// All non-boot finalizer methods are flagged.</span></span><br><span class="line">        klass-&gt;SetFinalizable();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> temp;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* klass_descriptor = klass-&gt;GetDescriptor(&amp;temp);</span><br><span class="line">        <span class="comment">// The Enum class declares a &quot;final&quot; finalize() method to prevent subclasses from</span></span><br><span class="line">        <span class="comment">// introducing a finalizer. We don&#x27;t want to set the finalizable flag for Enum or its</span></span><br><span class="line">        <span class="comment">// subclasses, so we exclude it here.</span></span><br><span class="line">        <span class="comment">// We also want to avoid setting the flag on Object, where we know that finalize() is</span></span><br><span class="line">        <span class="comment">// empty.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(klass_descriptor, <span class="string">&quot;Ljava/lang/Object;&quot;</span>) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            <span class="built_in">strcmp</span>(klass_descriptor, <span class="string">&quot;Ljava/lang/Enum;&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">          klass-&gt;SetFinalizable();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method_name[<span class="number">0</span>] == <span class="string">&#x27;&lt;&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// Fix broken access flags for initializers. Bug 11157540.</span></span><br><span class="line">    <span class="keyword">bool</span> is_init = (<span class="built_in">strcmp</span>(<span class="string">&quot;&lt;init&gt;&quot;</span>, method_name) == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">bool</span> is_clinit = !is_init &amp;&amp; (<span class="built_in">strcmp</span>(<span class="string">&quot;&lt;clinit&gt;&quot;</span>, method_name) == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (UNLIKELY(!is_init &amp;&amp; !is_clinit)) &#123;</span><br><span class="line">      LOG(WARNING) &lt;&lt; <span class="string">&quot;Unexpected &#x27;&lt;&#x27; at start of method name &quot;</span> &lt;&lt; method_name;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (UNLIKELY((access_flags &amp; kAccConstructor) == <span class="number">0</span>)) &#123;</span><br><span class="line">        LOG(WARNING) &lt;&lt; method_name &lt;&lt; <span class="string">&quot; didn&#x27;t have expected constructor access flag in class &quot;</span></span><br><span class="line">            &lt;&lt; klass-&gt;PrettyDescriptor() &lt;&lt; <span class="string">&quot; in dex file &quot;</span> &lt;&lt; dex_file.GetLocation();</span><br><span class="line">        access_flags |= kAccConstructor;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dst-&gt;SetAccessFlags(access_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里大概就是构造函数的加载处理和普通函数的加载处理，然后我们再看看另一个函数LinkCode的实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LinkCode</span><span class="params">(ClassLinker* class_linker,</span></span></span><br><span class="line"><span class="function"><span class="params">                     ArtMethod* method,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">const</span> OatFile::OatClass* oat_class,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">uint32_t</span> class_def_method_index)</span> <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">  Runtime* <span class="keyword">const</span> runtime = Runtime::Current();</span><br><span class="line">  <span class="keyword">if</span> (runtime-&gt;IsAotCompiler()) &#123;</span><br><span class="line">    <span class="comment">// The following code only applies to a non-compiler runtime.</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Method shouldn&#x27;t have already been linked.</span></span><br><span class="line">  DCHECK(method-&gt;GetEntryPointFromQuickCompiledCode() == <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span> (oat_class != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// Every kind of method should at least get an invoke stub from the oat_method.</span></span><br><span class="line">    <span class="comment">// non-abstract methods also get their code pointers.</span></span><br><span class="line">    <span class="keyword">const</span> OatFile::OatMethod oat_method = oat_class-&gt;GetOatMethod(class_def_method_index);</span><br><span class="line">    oat_method.LinkMethod(method);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Install entry point from interpreter.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">void</span>* quick_code = method-&gt;GetEntryPointFromQuickCompiledCode();</span><br><span class="line">  <span class="keyword">bool</span> enter_interpreter = class_linker-&gt;ShouldUseInterpreterEntrypoint(method, quick_code);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!method-&gt;IsInvokable()) &#123;</span><br><span class="line">    EnsureThrowsInvocationError(class_linker, method);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (method-&gt;IsStatic() &amp;&amp; !method-&gt;IsConstructor()) &#123;</span><br><span class="line">    <span class="comment">// For static methods excluding the class initializer, install the trampoline.</span></span><br><span class="line">    <span class="comment">// It will be replaced by the proper entry point by ClassLinker::FixupStaticTrampolines</span></span><br><span class="line">    <span class="comment">// after initializing class (see ClassLinker::InitializeClass method).</span></span><br><span class="line">    method-&gt;SetEntryPointFromQuickCompiledCode(GetQuickResolutionStub());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (quick_code == <span class="literal">nullptr</span> &amp;&amp; method-&gt;IsNative()) &#123;</span><br><span class="line">    method-&gt;SetEntryPointFromQuickCompiledCode(GetQuickGenericJniStub());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (enter_interpreter) &#123;</span><br><span class="line">    <span class="comment">// Set entry point from compiled code if there&#x27;s no code or in interpreter only mode.</span></span><br><span class="line">    method-&gt;SetEntryPointFromQuickCompiledCode(GetQuickToInterpreterBridge());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (method-&gt;IsNative()) &#123;</span><br><span class="line">    <span class="comment">// Unregistering restores the dlsym lookup stub.</span></span><br><span class="line">    method-&gt;UnregisterNative();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enter_interpreter || quick_code == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// We have a native method here without code. Then it should have either the generic JNI</span></span><br><span class="line">      <span class="comment">// trampoline as entrypoint (non-static), or the resolution trampoline (static).</span></span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> this doesn&#x27;t handle all the cases where trampolines may be installed.</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">void</span>* entry_point = method-&gt;GetEntryPointFromQuickCompiledCode();</span><br><span class="line">      DCHECK(class_linker-&gt;IsQuickGenericJniStub(entry_point) ||</span><br><span class="line">             class_linker-&gt;IsQuickResolutionStub(entry_point));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到重点，如果是native的处理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (method-&gt;IsNative()) &#123;</span><br><span class="line">    <span class="comment">// Unregistering restores the dlsym lookup stub.</span></span><br><span class="line">    method-&gt;UnregisterNative();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是每个类加载时会触发的jni函数绑定，继续看UnregisterNative的实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArtMethod::UnregisterNative</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  CHECK(IsNative() &amp;&amp; !IsFastNative()) &lt;&lt; PrettyMethod();</span><br><span class="line">  <span class="comment">// restore stub to lookup native pointer via dlsym</span></span><br><span class="line">  SetEntryPointFromJni(GetJniDlsymLookupStub());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们就知道了。jni函数的静态加载和动态加载的第一次加载绑定都会调用的位置就是SetEntryPointFromJni这里，初次绑定函数存放到了GetJniDlsymLookupStub()这个函数返回的指针。然后看看是存放到了什么地方</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">void</span>* <span class="title">GetJniDlsymLookupStub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">void</span>*&gt;(art_jni_dlsym_lookup_stub);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确定了这是一个指针。这个指针指向了一个函数。初次加载是把函数存放到了哪里，对应的函数是一个汇编函数。静态注册的第一次调用就会直接触发这个函数来获取加载函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    .extern artFindNativeMethod</span><br><span class="line">ENTRY art_jni_dlsym_lookup_stub</span><br><span class="line">    push   &#123;r0, r1, r2, r3, lr&#125;           @ spill regs</span><br><span class="line">    .cfi_adjust_cfa_offset 20</span><br><span class="line">    .cfi_rel_offset r0, 0</span><br><span class="line">    .cfi_rel_offset r1, 4</span><br><span class="line">    .cfi_rel_offset r2, 8</span><br><span class="line">    .cfi_rel_offset r3, 12</span><br><span class="line">    .cfi_rel_offset lr, 16</span><br><span class="line">    sub    sp, #12                        @ pad stack pointer to align frame</span><br><span class="line">    .cfi_adjust_cfa_offset 12</span><br><span class="line">    blx    artFindNativeMethod</span><br><span class="line">    mov    r12, r0                        @ save result in r12</span><br><span class="line">    add    sp, #12                        @ restore stack pointer</span><br><span class="line">    .cfi_adjust_cfa_offset -12</span><br><span class="line">    cbz    r0, 1f                         @ is method code null?</span><br><span class="line">    pop    &#123;r0, r1, r2, r3, lr&#125;           @ restore regs</span><br><span class="line">    .cfi_adjust_cfa_offset -20</span><br><span class="line">    .cfi_restore r0</span><br><span class="line">    .cfi_restore r1</span><br><span class="line">    .cfi_restore r2</span><br><span class="line">    .cfi_restore r3</span><br><span class="line">    .cfi_restore lr</span><br><span class="line">    bx     r12                            @ if non-null, tail call to method&#39;s code</span><br><span class="line">1:</span><br><span class="line">    pop    &#123;r0, r1, r2, r3, pc&#125;           @ restore regs and return to caller to handle exception</span><br><span class="line">END art_jni_dlsym_lookup_stub</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看到这里blx调用了artFindNativeMethod。继续再看看这个里面做了什么。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">const</span> <span class="keyword">void</span>* <span class="title">artFindNativeMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Thread* self = Thread::Current();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">const</span> <span class="keyword">void</span>* <span class="title">artFindNativeMethod</span><span class="params">(Thread* self)</span> </span>&#123;</span><br><span class="line">  DCHECK_EQ(self, Thread::Current());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  Locks::mutator_lock_-&gt;AssertNotHeld(self);  <span class="comment">// We come here as Native.</span></span><br><span class="line">  <span class="function">ScopedObjectAccess <span class="title">soa</span><span class="params">(self)</span></span>;</span><br><span class="line"></span><br><span class="line">  ArtMethod* method = self-&gt;GetCurrentMethod(<span class="literal">nullptr</span>);</span><br><span class="line">  DCHECK(method != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Lookup symbol address for method, on failure we&#x27;ll return null with an exception set,</span></span><br><span class="line">  <span class="comment">// otherwise we return the address of the method we found.</span></span><br><span class="line">  <span class="keyword">void</span>* native_code = soa.Vm()-&gt;FindCodeForNativeMethod(method);</span><br><span class="line">  <span class="keyword">if</span> (native_code == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    self-&gt;AssertPendingException();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Register so that future calls don&#x27;t come here</span></span><br><span class="line">  <span class="keyword">return</span> method-&gt;RegisterNative(native_code, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就看到了熟悉的RegisterNative了，到这里才进行了真正的函数的绑定。而前面FindCodeForNativeMethod这个函数用来获取绑定函数的符号地址。将查询到的地址交给RegisterNative进行绑定，继续看是如何查询函数符号地址的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">JavaVMExt::FindCodeForNativeMethod</span><span class="params">(ArtMethod* m)</span> </span>&#123;</span><br><span class="line">  CHECK(m-&gt;IsNative());</span><br><span class="line">  mirror::Class* c = m-&gt;GetDeclaringClass();</span><br><span class="line">  <span class="comment">// If this is a static method, it could be called before the class has been initialized.</span></span><br><span class="line">  CHECK(c-&gt;IsInitializing()) &lt;&lt; c-&gt;GetStatus() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m-&gt;PrettyMethod();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> detail;</span><br><span class="line">  Thread* <span class="keyword">const</span> self = Thread::Current();</span><br><span class="line">  <span class="keyword">void</span>* native_method = libraries_-&gt;FindNativeMethod(self, m, detail);</span><br><span class="line">  <span class="keyword">if</span> (native_method == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// Lookup JNI native methods from native TI Agent libraries. See runtime/ti/agent.h for more</span></span><br><span class="line">    <span class="comment">// information. Agent libraries are searched for native methods after all jni libraries.</span></span><br><span class="line">    native_method = FindCodeForNativeMethodInAgents(m);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Throwing can cause libraries_lock to be reacquired.</span></span><br><span class="line">  <span class="keyword">if</span> (native_method == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    LOG(ERROR) &lt;&lt; detail;</span><br><span class="line">    self-&gt;ThrowNewException(<span class="string">&quot;Ljava/lang/UnsatisfiedLinkError;&quot;</span>, detail.c_str());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> native_method;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里又看到了FindNativeMethod，然后继续深入</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">FindNativeMethod</span><span class="params">(Thread* self, ArtMethod* m, <span class="built_in">std</span>::<span class="built_in">string</span>&amp; detail)</span></span></span><br><span class="line"><span class="function">      <span class="title">REQUIRES</span><span class="params">(!Locks::jni_libraries_lock_)</span></span></span><br><span class="line"><span class="function">      <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">jni_short_name</span><span class="params">(m-&gt;JniShortName())</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">jni_long_name</span><span class="params">(m-&gt;JniLongName())</span></span>;</span><br><span class="line">    mirror::ClassLoader* <span class="keyword">const</span> declaring_class_loader = m-&gt;GetDeclaringClass()-&gt;GetClassLoader();</span><br><span class="line">    <span class="function">ScopedObjectAccessUnchecked <span class="title">soa</span><span class="params">(Thread::Current())</span></span>;</span><br><span class="line">    <span class="keyword">void</span>* <span class="keyword">const</span> declaring_class_loader_allocator =</span><br><span class="line">        Runtime::Current()-&gt;GetClassLinker()-&gt;GetAllocatorForClassLoader(declaring_class_loader);</span><br><span class="line">    CHECK(declaring_class_loader_allocator != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Avoid calling GetShorty here to prevent dirtying dex pages?</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* shorty = m-&gt;GetShorty();</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// Go to suspended since dlsym may block for a long time if other threads are using dlopen.</span></span><br><span class="line">      <span class="function">ScopedThreadSuspension <span class="title">sts</span><span class="params">(self, kNative)</span></span>;</span><br><span class="line">      <span class="keyword">void</span>* native_code = FindNativeMethodInternal(self,</span><br><span class="line">                                                   declaring_class_loader_allocator,</span><br><span class="line">                                                   shorty,</span><br><span class="line">                                                   jni_short_name,</span><br><span class="line">                                                   jni_long_name);</span><br><span class="line">      <span class="keyword">if</span> (native_code != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> native_code;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    detail += <span class="string">&quot;No implementation found for &quot;</span>;</span><br><span class="line">    detail += m-&gt;PrettyMethod();</span><br><span class="line">    detail += <span class="string">&quot; (tried &quot;</span> + jni_short_name + <span class="string">&quot; and &quot;</span> + jni_long_name + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里继续找关键的函数FindNativeMethodInternal，然后再深入</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">FindNativeMethodInternal</span><span class="params">(Thread* self,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">void</span>* declaring_class_loader_allocator,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">const</span> <span class="keyword">char</span>* shorty,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; jni_short_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; jni_long_name)</span></span></span><br><span class="line"><span class="function">      <span class="title">REQUIRES</span><span class="params">(!Locks::jni_libraries_lock_)</span></span></span><br><span class="line"><span class="function">      <span class="title">REQUIRES</span><span class="params">(!Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">    <span class="function">MutexLock <span class="title">mu</span><span class="params">(self, *Locks::jni_libraries_lock_)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; lib : libraries_) &#123;</span><br><span class="line">      SharedLibrary* <span class="keyword">const</span> library = lib.second;</span><br><span class="line">      <span class="comment">// Use the allocator address for class loader equality to avoid unnecessary weak root decode.</span></span><br><span class="line">      <span class="keyword">if</span> (library-&gt;GetClassLoaderAllocator() != declaring_class_loader_allocator) &#123;</span><br><span class="line">        <span class="comment">// We only search libraries loaded by the appropriate ClassLoader.</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Try the short name then the long name...</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span>* arg_shorty = library-&gt;NeedsNativeBridge() ? shorty : <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">void</span>* fn = library-&gt;FindSymbol(jni_short_name, arg_shorty);</span><br><span class="line">      <span class="keyword">if</span> (fn == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        fn = library-&gt;FindSymbol(jni_long_name, arg_shorty);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (fn != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        VLOG(jni) &lt;&lt; <span class="string">&quot;[Found native code for &quot;</span> &lt;&lt; jni_long_name</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; in \&quot;&quot;</span> &lt;&lt; library-&gt;GetPath() &lt;&lt; <span class="string">&quot;\&quot;]&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> fn;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>最后看到了，是通过FindSymbol这个函数来获取绑定函数的符号地址。</p>
<p>静态函数绑定流程到这里就完成了。</p>
<p>动态函数绑定是通过jni中的RegisterNatives来进行绑定.然后找到art/runtime/jni_internal.cc下的RegisterNatives</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">RegisterNatives</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">                              jclass java_class,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">const</span> JNINativeMethod* methods,</span></span></span><br><span class="line"><span class="function"><span class="params">                              jint method_count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (UNLIKELY(method_count &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">      JavaVmExtFromEnv(env)-&gt;JniAbortF(<span class="string">&quot;RegisterNatives&quot;</span>, <span class="string">&quot;negative method count: %d&quot;</span>,</span><br><span class="line">                                       method_count);</span><br><span class="line">      <span class="keyword">return</span> JNI_ERR;  <span class="comment">// Not reached except in unit tests.</span></span><br><span class="line">    &#125;</span><br><span class="line">    CHECK_NON_NULL_ARGUMENT_FN_NAME(<span class="string">&quot;RegisterNatives&quot;</span>, java_class, JNI_ERR);</span><br><span class="line">    <span class="function">ScopedObjectAccess <span class="title">soa</span><span class="params">(env)</span></span>;</span><br><span class="line">    <span class="function">StackHandleScope&lt;1&gt; <span class="title">hs</span><span class="params">(soa.Self())</span></span>;</span><br><span class="line">    Handle&lt;mirror::Class&gt; c = hs.NewHandle(soa.Decode&lt;mirror::Class&gt;(java_class));</span><br><span class="line">    <span class="keyword">if</span> (UNLIKELY(method_count == <span class="number">0</span>)) &#123;</span><br><span class="line">      LOG(WARNING) &lt;&lt; <span class="string">&quot;JNI RegisterNativeMethods: attempt to register 0 native methods for &quot;</span></span><br><span class="line">          &lt;&lt; c-&gt;PrettyDescriptor();</span><br><span class="line">      <span class="keyword">return</span> JNI_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    CHECK_NON_NULL_ARGUMENT_FN_NAME(<span class="string">&quot;RegisterNatives&quot;</span>, methods, JNI_ERR);</span><br><span class="line">    <span class="keyword">for</span> (jint i = <span class="number">0</span>; i &lt; method_count; ++i) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span>* name = methods[i].name;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span>* sig = methods[i].signature;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">void</span>* fnPtr = methods[i].fnPtr;</span><br><span class="line">      <span class="keyword">if</span> (UNLIKELY(name == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">        ReportInvalidJNINativeMethod(soa, c.Get(), <span class="string">&quot;method name&quot;</span>, i);</span><br><span class="line">        <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (UNLIKELY(sig == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">        ReportInvalidJNINativeMethod(soa, c.Get(), <span class="string">&quot;method signature&quot;</span>, i);</span><br><span class="line">        <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (UNLIKELY(fnPtr == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">        ReportInvalidJNINativeMethod(soa, c.Get(), <span class="string">&quot;native function&quot;</span>, i);</span><br><span class="line">        <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">bool</span> is_fast = <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">// Notes about fast JNI calls:</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// On a normal JNI call, the calling thread usually transitions</span></span><br><span class="line">      <span class="comment">// from the kRunnable state to the kNative state. But if the</span></span><br><span class="line">      <span class="comment">// called native function needs to access any Java object, it</span></span><br><span class="line">      <span class="comment">// will have to transition back to the kRunnable state.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// There is a cost to this double transition. For a JNI call</span></span><br><span class="line">      <span class="comment">// that should be quick, this cost may dominate the call cost.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// On a fast JNI call, the calling thread avoids this double</span></span><br><span class="line">      <span class="comment">// transition by not transitioning from kRunnable to kNative and</span></span><br><span class="line">      <span class="comment">// stays in the kRunnable state.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// There are risks to using a fast JNI call because it can delay</span></span><br><span class="line">      <span class="comment">// a response to a thread suspension request which is typically</span></span><br><span class="line">      <span class="comment">// used for a GC root scanning, etc. If a fast JNI call takes a</span></span><br><span class="line">      <span class="comment">// long time, it could cause longer thread suspension latency</span></span><br><span class="line">      <span class="comment">// and GC pauses.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// Thus, fast JNI should be used with care. It should be used</span></span><br><span class="line">      <span class="comment">// for a JNI call that takes a short amount of time (eg. no</span></span><br><span class="line">      <span class="comment">// long-running loop) and does not block (eg. no locks, I/O,</span></span><br><span class="line">      <span class="comment">// etc.)</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// A &#x27;!&#x27; prefix in the signature in the JNINativeMethod</span></span><br><span class="line">      <span class="comment">// indicates that it&#x27;s a fast JNI call and the runtime omits the</span></span><br><span class="line">      <span class="comment">// thread state transition from kRunnable to kNative at the</span></span><br><span class="line">      <span class="comment">// entry.</span></span><br><span class="line">      <span class="keyword">if</span> (*sig == <span class="string">&#x27;!&#x27;</span>) &#123;</span><br><span class="line">        is_fast = <span class="literal">true</span>;</span><br><span class="line">        ++sig;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Note: the right order is to try to find the method locally</span></span><br><span class="line">      <span class="comment">// first, either as a direct or a virtual method. Then move to</span></span><br><span class="line">      <span class="comment">// the parent.</span></span><br><span class="line">      ArtMethod* m = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">bool</span> warn_on_going_to_parent = down_cast&lt;JNIEnvExt*&gt;(env)-&gt;vm-&gt;IsCheckJniEnabled();</span><br><span class="line">      <span class="keyword">for</span> (ObjPtr&lt;mirror::Class&gt; current_class = c.Get();</span><br><span class="line">           current_class != <span class="literal">nullptr</span>;</span><br><span class="line">           current_class = current_class-&gt;GetSuperClass()) &#123;</span><br><span class="line">        <span class="comment">// Search first only comparing methods which are native.</span></span><br><span class="line">        m = FindMethod&lt;<span class="literal">true</span>&gt;(current_class.Ptr(), name, sig);</span><br><span class="line">        <span class="keyword">if</span> (m != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Search again comparing to all methods, to find non-native methods that match.</span></span><br><span class="line">        m = FindMethod&lt;<span class="literal">false</span>&gt;(current_class.Ptr(), name, sig);</span><br><span class="line">        <span class="keyword">if</span> (m != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (warn_on_going_to_parent) &#123;</span><br><span class="line">          LOG(WARNING) &lt;&lt; <span class="string">&quot;CheckJNI: method to register \&quot;&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;\&quot; not in the given class. &quot;</span></span><br><span class="line">                       &lt;&lt; <span class="string">&quot;This is slow, consider changing your RegisterNatives calls.&quot;</span>;</span><br><span class="line">          warn_on_going_to_parent = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (m == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        c-&gt;DumpClass(LOG_STREAM(ERROR), mirror::Class::kDumpClassFullDetail);</span><br><span class="line">        LOG(ERROR)</span><br><span class="line">            &lt;&lt; <span class="string">&quot;Failed to register native method &quot;</span></span><br><span class="line">            &lt;&lt; c-&gt;PrettyDescriptor() &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; name &lt;&lt; sig &lt;&lt; <span class="string">&quot; in &quot;</span></span><br><span class="line">            &lt;&lt; c-&gt;GetDexCache()-&gt;GetLocation()-&gt;ToModifiedUtf8();</span><br><span class="line">        ThrowNoSuchMethodError(soa, c.Get(), name, sig, <span class="string">&quot;static or non-static&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!m-&gt;IsNative()) &#123;</span><br><span class="line">        LOG(ERROR)</span><br><span class="line">            &lt;&lt; <span class="string">&quot;Failed to register non-native method &quot;</span></span><br><span class="line">            &lt;&lt; c-&gt;PrettyDescriptor() &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; name &lt;&lt; sig</span><br><span class="line">            &lt;&lt; <span class="string">&quot; as native&quot;</span>;</span><br><span class="line">        ThrowNoSuchMethodError(soa, c.Get(), name, sig, <span class="string">&quot;native&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      VLOG(jni) &lt;&lt; <span class="string">&quot;[Registering JNI native method &quot;</span> &lt;&lt; m-&gt;PrettyMethod() &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (UNLIKELY(is_fast)) &#123;</span><br><span class="line">        <span class="comment">// There are a few reasons to switch:</span></span><br><span class="line">        <span class="comment">// 1) We don&#x27;t support !bang JNI anymore, it will turn to a hard error later.</span></span><br><span class="line">        <span class="comment">// 2) @FastNative is actually faster. At least 1.5x faster than !bang JNI.</span></span><br><span class="line">        <span class="comment">//    and switching is super easy, remove ! in C code, add annotation in .java code.</span></span><br><span class="line">        <span class="comment">// 3) Good chance of hitting DCHECK failures in ScopedFastNativeObjectAccess</span></span><br><span class="line">        <span class="comment">//    since that checks for presence of @FastNative and not for ! in the descriptor.</span></span><br><span class="line">        LOG(WARNING) &lt;&lt; <span class="string">&quot;!bang JNI is deprecated. Switch to @FastNative for &quot;</span> &lt;&lt; m-&gt;PrettyMethod();</span><br><span class="line">        is_fast = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> make this a hard register error in the future.</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">void</span>* final_function_ptr = m-&gt;RegisterNative(fnPtr, is_fast);</span><br><span class="line">      UNUSED(final_function_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> JNI_OK;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里代码有点多。关键函数是最后的m-&gt;RegisterNative进行绑定，这个m对象是一个ArtMethod类，继续往里面看代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">void</span>* <span class="title">ArtMethod::RegisterNative</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* native_method, <span class="keyword">bool</span> is_fast)</span> </span>&#123;</span><br><span class="line">  CHECK(IsNative()) &lt;&lt; PrettyMethod();</span><br><span class="line">  CHECK(!IsFastNative()) &lt;&lt; PrettyMethod();</span><br><span class="line">  CHECK(native_method != <span class="literal">nullptr</span>) &lt;&lt; PrettyMethod();</span><br><span class="line">  <span class="keyword">if</span> (is_fast) &#123;</span><br><span class="line">    AddAccessFlags(kAccFastNative);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span>* new_native_method = <span class="literal">nullptr</span>;</span><br><span class="line">  Runtime::Current()-&gt;GetRuntimeCallbacks()-&gt;RegisterNativeMethod(<span class="keyword">this</span>,</span><br><span class="line">                                                                  native_method,</span><br><span class="line">                                                                  <span class="comment">/*out*/</span>&amp;new_native_method);</span><br><span class="line">  SetEntryPointFromJni(new_native_method);</span><br><span class="line">  <span class="keyword">return</span> new_native_method;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候发现，其实动态注册最后还是调用了SetEntryPointFromJni这个函数来进行绑定的。</p>
<p>这篇太长了。frida来hook的部分下一篇再记录吧。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">king</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://missking.cc/2020/08/30/JNI-DexClassLoader/">http://missking.cc/2020/08/30/JNI-DexClassLoader/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://missking.cc" target="_blank">king的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/09/02/Frida-Native-Register/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">使用frida来hook artmethod的RegisterNative</div></div></a></div><div class="next-post pull-right"><a href="/2020/08/26/IOSDump/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ios的砸壳和基础工具</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/assets/blogImg/litten.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">king</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/dqzg12300"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/dqzg12300" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:king910827@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">新时代农民工</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8Cjni%E5%87%BD%E6%95%B0%E6%97%B6%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">动态注册jni函数时的流程</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/09/05/kernel1-0/" title="aosp12内核编译开启硬件断点和kprobes记录">aosp12内核编译开启硬件断点和kprobes记录</a><time datetime="2022-09-05T13:01:17.000Z" title="发表于 2022-09-05 13:01:17">2022-09-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/04/11/Kernel1/" title="linux内核书籍阅读笔记1">linux内核书籍阅读笔记1</a><time datetime="2022-04-11T22:38:34.000Z" title="发表于 2022-04-11 22:38:34">2022-04-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/03/20/CPU%E5%9F%BA%E7%A1%80/" title="逆向工程权威指南的看书笔记">逆向工程权威指南的看书笔记</a><time datetime="2022-03-20T15:38:13.000Z" title="发表于 2022-03-20 15:38:13">2022-03-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/01/27/MikRom/" title="FartExt超进化之奇奇怪怪的新ROM工具MikRom">FartExt超进化之奇奇怪怪的新ROM工具MikRom</a><time datetime="2022-01-27T13:48:38.000Z" title="发表于 2022-01-27 13:48:38">2022-01-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/07/26/fartext/" title="FartExt之优化更深主动调用的FART10">FartExt之优化更深主动调用的FART10</a><time datetime="2021-07-26T21:31:05.000Z" title="发表于 2021-07-26 21:31:05">2021-07-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By king</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'ihIPa0lRcHcfVzXqcboVznyu-gzGzoHsz',
      appKey: 'YB8y22BOhfzrVioINMUoEqxd',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'http://missking.cc/2020/08/30/JNI-DexClassLoader/'
    this.page.identifier = '2020/08/30/JNI-DexClassLoader/'
    this.page.title = 'jni函数动态注册分析'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>