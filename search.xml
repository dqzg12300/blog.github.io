<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>aosp12内核编译开启硬件断点和kprobes记录</title>
      <link href="/2022/09/05/kernel1-0/"/>
      <url>/2022/09/05/kernel1-0/</url>
      
        <content type="html"><![CDATA[<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://blog.seeflower.dev/archives/139/">eBPF on Android之打补丁和编译内核</a></p><p><a href="https://adtxl.com/index.php/archives/124.html">修改Linux Kernel defconfig的标准方法</a></p><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>最近打算重新做一版以前的工具，升级一下系统版本，在编译内核的时候碰到了一些问题，顺手记录一下。目标是编译aosp12的内核，修改配置开启硬件断点，开启kprobe。为后续学习bpf准备测试环境。</p><h3 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h3><p>首先找到对应我当前aosp12版本对应的内核，我们<a href="https://source.android.com/docs/setup/build/building-kernels?hl=zh-cn">官网提供的描述</a>可以找到。由于我使用的手机是pixel3，所以对应的版本是<code>android-msm-crosshatch-4.9-android12</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 拉取内核代码</span><br><span class="line">repo init -u https://android.googlesource.com/kernel/manifest -b android-msm-crosshatch-4.9-android12</span><br><span class="line">repo sync -j8</span><br></pre></td></tr></table></figure><p>成功拉取代码后，可以先直接编译<code>./build/build.sh</code>跑通编译，如果在编译过程中出现错误，有可能是缺少了一些环境，以下是我编译过程安装的缺少依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install bc</span><br><span class="line">sudo apt install kmod</span><br></pre></td></tr></table></figure><p>成功编译后，还需要让aosp使用我们自己编译的内核</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim .&#x2F;build&#x2F;envsetup.sh</span><br><span class="line">&#x2F;&#x2F;在最后添加</span><br><span class="line">export TARGET_PREBUILT_KERNEL&#x3D;&#x2F;root&#x2F;android_src&#x2F;android-kernel&#x2F;out&#x2F;android-msm-pixel-4.9&#x2F;dist&#x2F;Image.lz4</span><br></pre></td></tr></table></figure><p>添加好配置后，我们编译aosp时就会自动使用编译好的内核了。</p><h3 id="修改内核配置"><a href="#修改内核配置" class="headerlink" title="修改内核配置"></a>修改内核配置</h3><p>最早先，我是直接修改<code>arch/arm64/configs/xx_defconfig</code>，但是碰到了diff配置文件错误的问你题，后来又修改build.config.common文件，然后碰到了触摸失灵的问题。经过一番找资料，最后发现修改配置的方式得按照流程来才行。下面我贴上处理的过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;root&#x2F;android_src&#x2F;android-kernel&#x2F;private&#x2F;msm-google</span><br><span class="line">&#x2F;&#x2F; b1c1_defconfig是我的设备使用配置，第一步会在当前目录生成.config文件</span><br><span class="line">make ARCH&#x3D;arm64 b1c1_defconfig</span><br><span class="line">&#x2F;&#x2F; 这个命令会打开一个图形化的界面，我们在里面可以勾选需要的配置，最后save保存回这个.config文件</span><br><span class="line">&#x2F;&#x2F; 如果我们清楚的知道修改什么配置，那么可以不用打开图形化界面，直接编辑.config，添加自己的配置即可</span><br><span class="line">&#x2F;&#x2F; 比如我在最后直接添加CONFIG_KPROBES&#x3D;y</span><br><span class="line">make ARCH&#x3D;arm64 menuconfig</span><br><span class="line">&#x2F;&#x2F; 使用.config文件生成defconfig文件</span><br><span class="line">make ARCH&#x3D;arm64 savedefconfig</span><br><span class="line">最后将生成好的配置文件替换</span><br><span class="line">cp defconfig arch&#x2F;arm64&#x2F;configs&#x2F;b1c1_defconfig</span><br></pre></td></tr></table></figure><p>按照上面的步骤我手动在配置中添加了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_IKHEADERS&#x3D;y</span><br><span class="line">CONFIG_HAVE_KPROBES&#x3D;y</span><br><span class="line">CONFIG_KPROBES&#x3D;y</span><br><span class="line">CONFIG_KPROBE_EVENT&#x3D;y</span><br><span class="line">CONFIG_HAVE_HW_BREAKPOINT&#x3D;y</span><br><span class="line">CONFIG_HAVE_ARCH_TRACEHOOK&#x3D;y</span><br></pre></td></tr></table></figure><p>另外在图形化界面中添加如下</p><p>Main—&gt;Enable loadable module support—&gt;Module signature verification—&gt;Require modules to be validly signed</p><p><img src="/2022/09/05/kernel1-0/image-20220905220135721.png" alt="image-20220905220135721"></p><p>Main—&gt;Kernel hacking—&gt;Sample kernel code—&gt;Build kernel hardware breakpoint exammples – loadable module only</p><p><img src="/2022/09/05/kernel1-0/image-20220905220414549.png" alt="image-20220905220414549"></p><p>有几个多选的，我也不知道用不用的上，反正先开着把。万一学习的时候需要呢。</p>]]></content>
      
      
      
        <tags>
            
            <tag> aosp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux内核书籍阅读笔记1</title>
      <link href="/2022/04/11/Kernel1/"/>
      <url>/2022/04/11/Kernel1/</url>
      
        <content type="html"><![CDATA[<h3 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h3><p>一个linux内核小白的学习路，看书的过程有很多暂时无法理解的我就直接略过或者简单笔记一下。由于我主要的目的是学习android内核，所以我主要参考代码是安卓内核的源码。有些我看书理解的如果有错误，还请多多指点。</p><h3 id="参考书籍：Linux内核深度解析《余华兵》"><a href="#参考书籍：Linux内核深度解析《余华兵》" class="headerlink" title="参考书籍：Linux内核深度解析《余华兵》"></a>参考书籍：Linux内核深度解析《余华兵》</h3><h3 id="内核引导和初始化"><a href="#内核引导和初始化" class="headerlink" title="内核引导和初始化"></a>内核引导和初始化</h3><p>当CPU通电后，首先是执行引导程序，引导程序存放在一个只读的存储器中，物理地址0开始的一段地址空间分配给了这个存储器，引导程序把内核加载到内存中，然后执行内核，内核初始化完成后，启动用户空间第一个进程。</p><p>根据书中提示引导程序的入口是<code>arch/arm/cpu/armv8/start.S</code></p><p>而我参考的是android内核，翻来翻去都没找到，所以我跳过了uboot引导程序加载的部分。</p><p>直接快进到<code>arch/arm64/kernel/head.S</code>，这里对比发现和android内核的差不多了。</p><p>首先看开始的相关代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_EFI</span><br><span class="line">efi_head:</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * This add instruction has no meaningful effect except that</span><br><span class="line">     * its opcode forms the magic &quot;MZ&quot; signature required by UEFI.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    add    x13, x18, #0x16</span><br><span class="line">    b    stext</span><br><span class="line">#else</span><br><span class="line">    b    stext                &#x2F;&#x2F; branch to kernel start, magic</span><br></pre></td></tr></table></figure><p><code>CONFIG_EFI</code>表示提供UEFI运行时支持。</p><p>上面可以看到跳转到了stext。下面继续看stext的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(stext)</span><br><span class="line">    bl    preserve_boot_args        &#x2F;&#x2F; 把引导程序传的4个参数保存在全局数组boot_args中</span><br><span class="line">    bl    el2_setup            &#x2F;&#x2F; Drop to EL1, w20&#x3D;cpu_boot_mode</span><br><span class="line">    adrp    x24, __PHYS_OFFSET</span><br><span class="line">    bl    set_cpu_boot_mode_flag</span><br><span class="line"></span><br><span class="line">    bl    __vet_fdt</span><br><span class="line">    bl    __create_page_tables        &#x2F;&#x2F; 创建页表映射 x25&#x3D;TTBR0, x26&#x3D;TTBR1</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * The following calls CPU setup code, see arch&#x2F;arm64&#x2F;mm&#x2F;proc.S for</span><br><span class="line">     * details.</span><br><span class="line">     * On return, the CPU will be ready for the MMU to be turned on and</span><br><span class="line">     * the TCR will have been set.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    ldr    x27, &#x3D;__mmap_switched        &#x2F;&#x2F; address to jump to after</span><br><span class="line">                        &#x2F;&#x2F; MMU has been enabled</span><br><span class="line">    adr_l    lr, __enable_mmu        &#x2F;&#x2F; return (PIC) address</span><br><span class="line">    b    __cpu_setup            &#x2F;&#x2F; 初始化处理器 initialise processor</span><br><span class="line">ENDPROC(stext)</span><br></pre></td></tr></table></figure><p>发现虽然和书中的代码相差不大，但是还是有一定差别，这里并没有看到书中的__primary_switch。</p><p>然后我仔细翻了下代码。然后重点看下面几句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ldr    x27, &#x3D;__mmap_switched        &#x2F;&#x2F; 将__mmap_switched的地址保存在x27寄存器中</span><br><span class="line">adr_l    lr, __enable_mmu        &#x2F;&#x2F; 这里应该是将__enable_mmu这个函数的符号地址存到lr中</span><br><span class="line">b    __cpu_setup                    &#x2F;&#x2F;初始化处理器</span><br><span class="line">&#x2F;&#x2F; 虽然这里是b指令直接跳转，但是他手动设置了lr</span><br><span class="line">&#x2F;&#x2F; 所以这里__cpu_setup执行完成后，应该接着就执行__enable_mmu</span><br></pre></td></tr></table></figure><p>所以接下来看看__enable_mmu函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__enable_mmu:</span><br><span class="line">    ldr    x5, &#x3D;vectors</span><br><span class="line">    msr    vbar_el1, x5</span><br><span class="line">    msr    ttbr0_el1, x25            &#x2F;&#x2F; load TTBR0</span><br><span class="line">    msr    ttbr1_el1, x26            &#x2F;&#x2F; load TTBR1</span><br><span class="line">    isb</span><br><span class="line">    msr    sctlr_el1, x0</span><br><span class="line">    isb</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * Invalidate the local I-cache so that any instructions fetched</span><br><span class="line">     * speculatively from the PoC are discarded, since they may have</span><br><span class="line">     * been dynamically patched at the PoU.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    ic    iallu</span><br><span class="line">    dsb    nsh</span><br><span class="line">    isb</span><br><span class="line">    br    x27</span><br><span class="line">ENDPROC(__enable_mmu)</span><br></pre></td></tr></table></figure><p><code>__enable_mmu</code>书中是说这里是开启内存管理单元，以后执行程序时内存管理单元会将虚拟地址转换成物理地址，由于我比较菜，所以暂时不理会函数内部的如何实现，先关注执行的走向，最后看到br指令跳转到x27的对应函数，前面能看到x27实际上是<code>__mmap_switched</code>函数的地址，所以继续看这个函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">__mmap_switched:</span><br><span class="line">    &#x2F;&#x2F; Clear BSS</span><br><span class="line">    adr_l    x0, __bss_start</span><br><span class="line">    mov    x1, xzr</span><br><span class="line">    adr_l    x2, __bss_stop</span><br><span class="line">    sub    x2, x2, x0</span><br><span class="line">    bl    __pi_memset</span><br><span class="line">    dsb    ishst                &#x2F;&#x2F; Make zero page visible to PTW</span><br><span class="line"></span><br><span class="line">    adr_l    sp, initial_sp, x4</span><br><span class="line">    mov    x4, sp</span><br><span class="line">    and    x4, x4, #~(THREAD_SIZE - 1)</span><br><span class="line">#ifdef CONFIG_THREAD_INFO_IN_TASK</span><br><span class="line">    adr_l    x5, init_task</span><br><span class="line">    msr    sp_el0, x5            &#x2F;&#x2F; Save thread_info</span><br><span class="line">#else</span><br><span class="line">    msr    sp_el0, x4            &#x2F;&#x2F; Save thread_info</span><br><span class="line">#endif</span><br><span class="line">    str_l    x21, __fdt_pointer, x5        &#x2F;&#x2F; Save FDT pointer</span><br><span class="line">    str_l    x24, memstart_addr, x6        &#x2F;&#x2F; Save PHYS_OFFSET</span><br><span class="line">    mov    x29, #0</span><br><span class="line">#ifdef CONFIG_KASAN</span><br><span class="line">    bl    kasan_early_init</span><br><span class="line">#endif</span><br><span class="line">    b    start_kernel</span><br><span class="line">ENDPROC(__mmap_switched)</span><br></pre></td></tr></table></figure><p>走到这里。我们就看到最后调用了内核初始化的c语言部分的入口函数<code>start_kernel</code></p><p>书中没有看到具体是哪个文件下。我自己找了下，路径是<code>./init/main.c</code>中。下面贴上完整代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage __visible <span class="keyword">void</span> __init <span class="title">start_kernel</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *command_line;</span><br><span class="line">    <span class="keyword">char</span> *after_dashes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Need to run as early as possible, to initialize the</span></span><br><span class="line"><span class="comment">     * lockdep hash:</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    lockdep_init();</span><br><span class="line">    set_task_stack_end_magic(&amp;init_task);</span><br><span class="line">    smp_setup_processor_id();</span><br><span class="line">    debug_objects_early_init();</span><br><span class="line"></span><br><span class="line">    cgroup_init_early();</span><br><span class="line"></span><br><span class="line">    local_irq_disable();</span><br><span class="line">    early_boot_irqs_disabled = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Interrupts are still disabled. Do necessary setups, then</span></span><br><span class="line"><span class="comment"> * enable them</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    boot_cpu_init();</span><br><span class="line">    page_address_init();</span><br><span class="line">    pr_notice(<span class="string">&quot;%s&quot;</span>, linux_banner);</span><br><span class="line">    setup_arch(&amp;command_line);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Set up the the initial canary ASAP:</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    boot_init_stack_canary();</span><br><span class="line">    mm_init_cpumask(&amp;init_mm);</span><br><span class="line">    setup_command_line(command_line);</span><br><span class="line">    setup_nr_cpu_ids();</span><br><span class="line">    setup_per_cpu_areas();</span><br><span class="line">    smp_prepare_boot_cpu();    <span class="comment">/* arch-specific boot-cpu hooks */</span></span><br><span class="line"></span><br><span class="line">    build_all_zonelists(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    page_alloc_init();</span><br><span class="line"></span><br><span class="line">    pr_notice(<span class="string">&quot;Kernel command line: %s\n&quot;</span>, boot_command_line);</span><br><span class="line">    parse_early_param();</span><br><span class="line">    after_dashes = parse_args(<span class="string">&quot;Booting kernel&quot;</span>,</span><br><span class="line">                  static_command_line, __start___param,</span><br><span class="line">                  __stop___param - __start___param,</span><br><span class="line">                  <span class="number">-1</span>, <span class="number">-1</span>, &amp;unknown_bootoption);</span><br><span class="line">    <span class="keyword">if</span> (!IS_ERR_OR_NULL(after_dashes))</span><br><span class="line">        parse_args(<span class="string">&quot;Setting init args&quot;</span>, after_dashes, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>,</span><br><span class="line">               set_init_arg);</span><br><span class="line"></span><br><span class="line">    jump_label_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * These use large bootmem allocations and must precede</span></span><br><span class="line"><span class="comment">     * kmem_cache_init()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    setup_log_buf(<span class="number">0</span>);</span><br><span class="line">    pidhash_init();</span><br><span class="line">    vfs_caches_init_early();</span><br><span class="line">    sort_main_extable();</span><br><span class="line">    trap_init();</span><br><span class="line">    mm_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Set up the scheduler prior starting any interrupts (such as the</span></span><br><span class="line"><span class="comment">     * timer interrupt). Full topology setup happens at smp_init()</span></span><br><span class="line"><span class="comment">     * time - but meanwhile we still have a functioning scheduler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    sched_init();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Disable preemption - early bootup scheduling is extremely</span></span><br><span class="line"><span class="comment">     * fragile until we cpu_idle() for the first time.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    preempt_disable();</span><br><span class="line">    <span class="keyword">if</span> (WARN(!irqs_disabled(),</span><br><span class="line">         <span class="string">&quot;Interrupts were enabled *very* early, fixing it\n&quot;</span>))</span><br><span class="line">        local_irq_disable();</span><br><span class="line">    idr_init_cache();</span><br><span class="line">    rcu_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* trace_printk() and trace points may be used after this */</span></span><br><span class="line">    trace_init();</span><br><span class="line"></span><br><span class="line">    context_tracking_init();</span><br><span class="line">    radix_tree_init();</span><br><span class="line">    <span class="comment">/* init some links before init_ISA_irqs() */</span></span><br><span class="line">    early_irq_init();</span><br><span class="line">    init_IRQ();</span><br><span class="line">    tick_init();</span><br><span class="line">    rcu_init_nohz();</span><br><span class="line">    init_timers();</span><br><span class="line">    hrtimers_init();</span><br><span class="line">    softirq_init();</span><br><span class="line">    timekeeping_init();</span><br><span class="line">    time_init();</span><br><span class="line">    sched_clock_postinit();</span><br><span class="line">    perf_event_init();</span><br><span class="line">    profile_init();</span><br><span class="line">    call_function_init();</span><br><span class="line">    WARN(!irqs_disabled(), <span class="string">&quot;Interrupts were enabled early\n&quot;</span>);</span><br><span class="line">    early_boot_irqs_disabled = <span class="literal">false</span>;</span><br><span class="line">    local_irq_enable();</span><br><span class="line"></span><br><span class="line">    kmem_cache_init_late();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * HACK ALERT! This is early. We&#x27;re enabling the console before</span></span><br><span class="line"><span class="comment">     * we&#x27;ve done PCI setups etc, and console_init() must be aware of</span></span><br><span class="line"><span class="comment">     * this. But we do want output early, in case something goes wrong.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    console_init();</span><br><span class="line">    <span class="keyword">if</span> (panic_later)</span><br><span class="line">        panic(<span class="string">&quot;Too many boot %s vars at `%s&#x27;&quot;</span>, panic_later,</span><br><span class="line">              panic_param);</span><br><span class="line"></span><br><span class="line">    lockdep_info();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Need to run this when irqs are enabled, because it wants</span></span><br><span class="line"><span class="comment">     * to self-test [hard/soft]-irqs on/off lock inversion bugs</span></span><br><span class="line"><span class="comment">     * too:</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    locking_selftest();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BLK_DEV_INITRD</span></span><br><span class="line">    <span class="keyword">if</span> (initrd_start &amp;&amp; !initrd_below_start_ok &amp;&amp;</span><br><span class="line">        page_to_pfn(virt_to_page((<span class="keyword">void</span> *)initrd_start)) &lt; min_low_pfn) &#123;</span><br><span class="line">        pr_crit(<span class="string">&quot;initrd overwritten (0x%08lx &lt; 0x%08lx) - disabling it.\n&quot;</span>,</span><br><span class="line">            page_to_pfn(virt_to_page((<span class="keyword">void</span> *)initrd_start)),</span><br><span class="line">            min_low_pfn);</span><br><span class="line">        initrd_start = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    page_cgroup_init();</span><br><span class="line">    debug_objects_mem_init();</span><br><span class="line">    kmemleak_init();</span><br><span class="line">    setup_per_cpu_pageset();</span><br><span class="line">    numa_policy_init();</span><br><span class="line">    <span class="keyword">if</span> (late_time_init)</span><br><span class="line">        late_time_init();</span><br><span class="line">    sched_clock_init();</span><br><span class="line">    calibrate_delay();</span><br><span class="line">    pidmap_init();</span><br><span class="line">    anon_vma_init();</span><br><span class="line">    acpi_early_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86</span></span><br><span class="line">    <span class="keyword">if</span> (efi_enabled(EFI_RUNTIME_SERVICES))</span><br><span class="line">        efi_enter_virtual_mode();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_ESPFIX64</span></span><br><span class="line">    <span class="comment">/* Should be run before the first non-init thread is created */</span></span><br><span class="line">    init_espfix_bsp();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    thread_stack_cache_init();</span><br><span class="line">    cred_init();</span><br><span class="line">    fork_init(totalram_pages);</span><br><span class="line">    proc_caches_init();</span><br><span class="line">    buffer_init();</span><br><span class="line">    key_init();</span><br><span class="line">    security_init();</span><br><span class="line">    dbg_late_init();</span><br><span class="line">    vfs_caches_init(totalram_pages);</span><br><span class="line">    signals_init();</span><br><span class="line">    <span class="comment">/* rootfs populating might need page-writeback */</span></span><br><span class="line">    page_writeback_init();</span><br><span class="line">    proc_root_init();</span><br><span class="line">    cgroup_init();</span><br><span class="line">    cpuset_init();</span><br><span class="line">    taskstats_init_early();</span><br><span class="line">    delayacct_init();</span><br><span class="line"></span><br><span class="line">    check_bugs();</span><br><span class="line"></span><br><span class="line">    acpi_subsystem_init();</span><br><span class="line">    sfi_init_late();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (efi_enabled(EFI_RUNTIME_SERVICES)) &#123;</span><br><span class="line">        efi_late_init();</span><br><span class="line">        efi_free_boot_services();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ftrace_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do the rest non-__init&#x27;ed, we&#x27;re now alive */</span></span><br><span class="line">    rest_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上面的代码基本都是init，初始化各类的子系统。到最后调用了rest_init函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> noinline <span class="keyword">void</span> __init_refok <span class="title">rest_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line"></span><br><span class="line">    rcu_scheduler_starting();</span><br><span class="line">    smpboot_thread_init();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We need to spawn init first so that it obtains pid 1, however</span></span><br><span class="line"><span class="comment">     * the init task will end up wanting to create kthreads, which, if</span></span><br><span class="line"><span class="comment">     * we schedule it before we create kthreadd, will OOPS.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    kernel_thread(kernel_init, <span class="literal">NULL</span>, CLONE_FS);</span><br><span class="line">    numa_default_policy();</span><br><span class="line">    pid = kernel_thread(kthreadd, <span class="literal">NULL</span>, CLONE_FS | CLONE_FILES);</span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    kthreadd_task = find_task_by_pid_ns(pid, &amp;init_pid_ns);</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">    complete(&amp;kthreadd_done);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The boot idle thread must execute schedule()</span></span><br><span class="line"><span class="comment">     * at least once to get things moving:</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    init_idle_bootup_task(current);</span><br><span class="line">    schedule_preempt_disabled();</span><br><span class="line">    <span class="comment">/* Call into cpu_idle with preempt disabled */</span></span><br><span class="line">    cpu_startup_entry(CPUHP_ONLINE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点看书中所说的init线程和创建内核的线程，也就是下面的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kernel_thread(kernel_init, <span class="literal">NULL</span>, CLONE_FS);</span><br><span class="line">pid = kernel_thread(kthreadd, <span class="literal">NULL</span>, CLONE_FS | CLONE_FILES);</span><br></pre></td></tr></table></figure><p>所以我们接着看kernel_init函数的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __ref <span class="title">kernel_init</span><span class="params">(<span class="keyword">void</span> *unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    kernel_init_freeable();</span><br><span class="line">    <span class="comment">/* need to finish all async __init code before freeing the memory */</span></span><br><span class="line">    async_synchronize_full();</span><br><span class="line">    free_initmem();</span><br><span class="line">    mark_readonly();</span><br><span class="line">    system_state = SYSTEM_RUNNING;</span><br><span class="line">    numa_default_policy();</span><br><span class="line"></span><br><span class="line">    flush_delayed_fput();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ramdisk_execute_command) &#123;</span><br><span class="line">        ret = run_init_process(ramdisk_execute_command);</span><br><span class="line">        <span class="keyword">if</span> (!ret)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        pr_err(<span class="string">&quot;Failed to execute %s (error %d)\n&quot;</span>,</span><br><span class="line">               ramdisk_execute_command, ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We try each of these until one succeeds.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The Bourne shell can be used instead of init if we are</span></span><br><span class="line"><span class="comment">     * trying to recover a really broken machine.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (execute_command) &#123;</span><br><span class="line">        ret = run_init_process(execute_command);</span><br><span class="line">        <span class="keyword">if</span> (!ret)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        pr_err(<span class="string">&quot;Failed to execute %s (error %d).  Attempting defaults...\n&quot;</span>,</span><br><span class="line">            execute_command, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!try_to_run_init_process(<span class="string">&quot;/sbin/init&quot;</span>) ||</span><br><span class="line">        !try_to_run_init_process(<span class="string">&quot;/etc/init&quot;</span>) ||</span><br><span class="line">        !try_to_run_init_process(<span class="string">&quot;/bin/init&quot;</span>) ||</span><br><span class="line">        !try_to_run_init_process(<span class="string">&quot;/bin/sh&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    panic(<span class="string">&quot;No working init found.  Try passing init= option to kernel. &quot;</span></span><br><span class="line">          <span class="string">&quot;See Linux Documentation/init.txt for guidance.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我在kernel_init_freeable函数中看到了书中所说的smp系统初始化相关的代码。这里就不继续往后贴了</p><p>SMP系统就是对称多处理器系统。并且每个处理器的地位平等。但是在启动过程中不是平等的。0号处理器是引导处理器，负责执行引导程序和初始化内存，其他处理器是从处理器，等待引导处理器完成初始化，引导处理器初始化完内核后启动从处理器。启动流程看起来比较复杂。暂时略过。</p><p>init进程是用户空间第一个进程，负责启动用户程序，我们可以看到上面start_kernel函数中是使用<code>try_to_run_init_process</code>函数来启动init进程的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试启动/sbin/init失败则启动/etc/init以此类推</span></span><br><span class="line"><span class="keyword">if</span> (!try_to_run_init_process(<span class="string">&quot;/sbin/init&quot;</span>) ||</span><br><span class="line">        !try_to_run_init_process(<span class="string">&quot;/etc/init&quot;</span>) ||</span><br><span class="line">        !try_to_run_init_process(<span class="string">&quot;/bin/init&quot;</span>) ||</span><br><span class="line">        !try_to_run_init_process(<span class="string">&quot;/bin/sh&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>继续看看这个函数怎么实现的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">try_to_run_init_process</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init_filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = run_init_process(init_filename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &amp;&amp; ret != -ENOENT) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Starting init: %s exists but couldn&#x27;t execute it (error %d)\n&quot;</span>,</span><br><span class="line">               init_filename, ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就看到调用了run_iniit_process函数，继续看实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">run_init_process</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init_filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    argv_init[<span class="number">0</span>] = init_filename;</span><br><span class="line">    <span class="keyword">return</span> do_execve(getname_kernel(init_filename),</span><br><span class="line">        (<span class="keyword">const</span> <span class="keyword">char</span> __user *<span class="keyword">const</span> __user *)argv_init,</span><br><span class="line">        (<span class="keyword">const</span> <span class="keyword">char</span> __user *<span class="keyword">const</span> __user *)envp_init);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里就知道了，实际就是通过execve()来运行init程序的了。</p><p>到这里第一章就结束了，小白啃的太费劲了。然后下面简单画了下流程图。</p><p><img src="/2022/04/11/Kernel1/kernel1.png" alt="kernel1"></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux内核基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向工程权威指南的看书笔记</title>
      <link href="/2022/03/20/CPU%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/03/20/CPU%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="书籍：逆向工程权威指南上（看书笔记）"><a href="#书籍：逆向工程权威指南上（看书笔记）" class="headerlink" title="书籍：逆向工程权威指南上（看书笔记）"></a>书籍：逆向工程权威指南上（看书笔记）</h3><h3 id="这本书有各种架构的相关说明，省略掉非arm64架构的相关记录"><a href="#这本书有各种架构的相关说明，省略掉非arm64架构的相关记录" class="headerlink" title="这本书有各种架构的相关说明，省略掉非arm64架构的相关记录"></a>这本书有各种架构的相关说明，省略掉非arm64架构的相关记录</h3><h3 id="1、CPU"><a href="#1、CPU" class="headerlink" title="1、CPU"></a>1、CPU</h3><p>cpu：执行程序机器码的硬件单元。</p><p>指令码：cpu处理的底层命令。</p><p>机器码：给cpu执行的程序代码。</p><p>汇编语言：为了便于编写而创造出来的，最接近机器码的语言。</p><p>指令集架构：不同架构的cpu处理的指令集都不一样，arm指令集最早先都被封装在4个字节里，后来由于发现4个字节很少用满，就推出了封装在2个字节的Thumb指令集及架构，但是不能封装所有的arm指令。就推出了2个字节封装不下的指令就由4字节封装的Thumb-2。最后arm64指令集又回到了固定使用4字节的指令集。</p><h3 id="2、简单函数"><a href="#2、简单函数" class="headerlink" title="2、简单函数"></a>2、简单函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int f()&#123;</span><br><span class="line">    return 123;</span><br><span class="line">&#125;</span><br><span class="line">--------汇编代码--------</span><br><span class="line">f:</span><br><span class="line">    mov r0,#0x7b ;</span><br><span class="line">    bx lr</span><br><span class="line">    endp</span><br></pre></td></tr></table></figure><p>这里可以看到arm程序使用r0寄存器存放返回值,使用lr存放函数结束后返回的地址。</p><h3 id="3、arm64的hello-world例子"><a href="#3、arm64的hello-world例子" class="headerlink" title="3、arm64的hello world例子"></a>3、arm64的hello world例子</h3><p>首先写个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们需要先编译成android的可执行程序</p><p>首先下载个用来编译的工具ndk-r12b</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;dl.google.com&#x2F;android&#x2F;repository&#x2F;android-ndk-r12b-linux-x86_64.zip</span><br></pre></td></tr></table></figure><p>然后编写我们的编译脚本build_android.sh</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CC_HOME=/home/king/Android/Sdk/ndk/android-ndk-r12b</span><br><span class="line">BIN_PATH=<span class="variable">$&#123;CC_HOME&#125;</span>/toolchains/aarch64-linux-android-4.9/prebuilt/linux-x86_64/bin</span><br><span class="line">CC=<span class="variable">$&#123;BIN_PATH&#125;</span>/aarch64-linux-android-gcc</span><br><span class="line">CXX=<span class="variable">$&#123;BIN_PATH&#125;</span>/aarch64-linux-android-g++</span><br><span class="line">AS=<span class="variable">$&#123;BIN_PATH&#125;</span>/aarch64-linux-android-as</span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123;CC&#125;</span>  -o hello main.c -pie -fPIE -I<span class="variable">$&#123;CC_HOME&#125;</span>/platforms/android-24/arch-arm64/usr/include -L<span class="variable">$&#123;CC_HOME&#125;</span>/platforms/android-24/arch-arm64/usr/lib --sysroot=<span class="variable">$&#123;CC_HOME&#125;</span>/platforms/android-23/arch-arm64/usr/</span><br></pre></td></tr></table></figure><p>或者是使用llvm也一样可以编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//编译arm版本</span><br><span class="line">/Users/king/Library/Android/sdk/ndk/24.0.8215888/toolchains/llvm/prebuilt/darwin-x86_64/bin/armv7a-linux-androideabi24-clang++  ./main.cpp</span><br><span class="line">//编译arm64版本</span><br><span class="line">/Users/king/Library/Android/sdk/ndk/24.0.8215888/toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android24-clang++  ./main.cpp</span><br></pre></td></tr></table></figure><p>编译完成之后，使用<code>file hello</code>查看一下刚刚编译的文件是否正确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter &#x2F;system&#x2F;bin&#x2F;linker64, not stripped</span><br></pre></td></tr></table></figure><p>接着我们用ida来分析这个文件，查看汇编代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">EXPORT main</span><br><span class="line">main</span><br><span class="line"></span><br><span class="line">var_s0&#x3D;  0</span><br><span class="line"></span><br><span class="line">STP             X29, X30, [SP,#-0x10+var_s0]!</span><br><span class="line">MOV             X29, SP</span><br><span class="line">ADRL            X0, aHelloWorld ; &quot;hello world!&quot;</span><br><span class="line">BL              .printf</span><br><span class="line">MOV             W0, #0</span><br><span class="line">LDP             X29, X30, [SP+var_s0],#0x10</span><br><span class="line">RET</span><br><span class="line">; End of function main</span><br></pre></td></tr></table></figure><p>可以看到在函数开始时使用指令<code>STP</code>将X29和X30寄存器存放到了数据栈中保存，然后在函数结束的时候，使用指令<code>LDP</code>将X29和X30再从数据栈取值填充回去。同样也是通过W0寄存器存放返回值。在ARM64中，X29相当于是FP寄存器，X30是LR寄存器。所以这两个寄存器经常在函数的开始部分和结尾部分成对出现</p><p><code>ADR</code>指令是将PC寄存器的值加上字符串偏移量，由此找到内存中字符串常量的绝对地址，然后赋值给X0寄存器。</p><p><code>BL</code>调用printf实际上是将下一条指令<code>MOV             W0, #0</code>的地址保存到LR寄存器中，然后将printf的函数地址写入PC寄存器，下一条指令会执行PC寄存器指向的地址，当printf执行完成后，会从LR寄存器获取到返回地址，然后函数继续执行。</p><p>最后返回W0寄存器是X0寄存器的低32位，如果我们定义的函数返回值不是int而是int64，则这里会变成返回X0寄存器。</p><h3 id="4、函数序言和函数尾声"><a href="#4、函数序言和函数尾声" class="headerlink" title="4、函数序言和函数尾声"></a>4、函数序言和函数尾声</h3><p>也就是前面看到的FP和LR寄存器值保存到数据栈中。这是为了在函数执行期间，这些寄存器的值不受后汉书运行的影响，在函数结束时，能将这些寄存器的值还原给调用者。通过序言和尾声的特征，我们可以在汇编中识别出各个函数的范围。</p><h3 id="5、栈的用途"><a href="#5、栈的用途" class="headerlink" title="5、栈的用途"></a>5、栈的用途</h3><p>前面的例子中，在函数的开始和结尾，就用到了栈来保护相关寄存器的值不受影响。</p><p>如果有一个函数不调用其他函数，就像树上最末端的样子一样你，就叫做<code>叶函数（leaf function）</code>，叶函数的特点是不用保存LR寄存器的值。如果叶函数代码短到只用几个寄存器，那么也有可能不会使用数据栈，这种叶函数的运行速度就会很快。</p><p>也可以使用栈来为函数传递参数。</p><p>alloca函数直接使用栈来分配内存，是很请的内存不用特地free来释放。比如x86里函数尾声的代码会还原寄存器ESP的值，把数据栈还原为函数启动之前的状态。</p><p>栈的脏数据，在函数退出以后，原有栈空间的局部变量不会自动清除，就成了栈的脏数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d&quot;</span>,a,b,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f1();</span><br><span class="line">    f2();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子最后打印1,2,3。就是因为使用到了栈上的脏数据。</p><p>所以就是在运行一个函数时，栈中的值受前一个函数的影响，而获得了前一个函数的变量值，这种就是脏数据。</p><h3 id="6、printf参数的传递"><a href="#6、printf参数的传递" class="headerlink" title="6、printf参数的传递"></a>6、printf参数的传递</h3><p>在arm中，参数传递时，前4个参数会传递给r0-r3寄存器，如果参数更加长，其他的参数会存放在栈中。</p><p>b指令和bl指令的差别是，b指令只负责跳转，不会根据LR寄存器返回，而BL则会将LR寄存器保存到栈中。</p><p>下面看个printf的参数传递例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data: %d %d %d\n&quot;</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成汇编如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">STMFD           SP!, &#123;R11,LR&#125;</span><br><span class="line">MOV             R11, SP                                </span><br><span class="line">SUB             SP, SP, #8                        </span><br><span class="line">MOV             R0, #0                                </span><br><span class="line">STR             R0, [SP,#8+var_4]            </span><br><span class="line">LDR             R0, &#x3D;(aDataDDD - 0x1478)</span><br><span class="line">ADD             R0, PC, R0 ; &quot;data: %d %d %d\n&quot;</span><br><span class="line">MOV             R1, #1</span><br><span class="line">MOV             R2, #2</span><br><span class="line">MOV             R3, #3</span><br><span class="line">BL              printf</span><br><span class="line">MOV             R0, #0</span><br><span class="line">MOV             SP, R11</span><br><span class="line">LDMFD           SP!, &#123;R11,PC&#125;</span><br></pre></td></tr></table></figure><p>可以看到三个值是直接存放在R1,R2,R3寄存器中，接下来看看更多参数的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data: %d %d %d %d %d %d %d %d %d\n&quot;</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再用ida查看一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">STMFD           SP!, &#123;R4-R7,R11,LR&#125;</span><br><span class="line">ADD             R11, SP, #0x10</span><br><span class="line">SUB             SP, SP, #0x20</span><br><span class="line">MOV             R0, #0</span><br><span class="line">STR             R0, [R11,#var_14]</span><br><span class="line">LDR             R0, &#x3D;(aDataDDDDDDDDD - 0x1498)</span><br><span class="line">ADD             R0, PC, R0 ; &quot;data: %d %d %d %d %d %d %d %d %d\n&quot;</span><br><span class="line">MOV             R1, #1</span><br><span class="line">MOV             R2, #2</span><br><span class="line">MOV             R3, #3</span><br><span class="line">MOV             R7, #4</span><br><span class="line">MOV             R6, #5</span><br><span class="line">MOV             R5, #6</span><br><span class="line">MOV             R4, #7</span><br><span class="line">MOV             LR, #8</span><br><span class="line">MOV             R12, #9</span><br><span class="line">STR             R7, [SP,#0x30+var_30]</span><br><span class="line">STR             R6, [SP,#0x30+var_2C]</span><br><span class="line">STR             R5, [SP,#0x30+var_28]</span><br><span class="line">STR             R4, [SP,#0x30+var_24]</span><br><span class="line">STR             LR, [SP,#0x30+var_20]</span><br><span class="line">STR             R12, [SP,#0x30+var_1C]</span><br><span class="line">BL              printf</span><br><span class="line">MOV             R0, #0</span><br><span class="line">SUB             SP, R11, #0x10</span><br><span class="line">LDMFD           SP!, &#123;R4-R7,R11,PC&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到r0-r3的值没有放进栈中，r4后面的寄存器放到了栈中，再调用的printf。</p><p>另外我们可以看到对栈的处理，就知道是如何在函数执行完成时还原栈的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ADD             R11, SP, #0x10  &#x2F;&#x2F;函数开始时，先将sp+0x10的值保存到r11</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">SUB             SP, R11, #0x10  &#x2F;&#x2F;函数开始时，先将r11-0x10的值还原到sp</span><br></pre></td></tr></table></figure><p>上面可以看到结束函数时栈的地址是如何还原，原本栈上的数据依然在那里，所以前面那个脏数据的例子就会出现那样的效果。</p><h3 id="7、scanf函数"><a href="#7、scanf函数" class="headerlink" title="7、scanf函数"></a>7、scanf函数</h3><p>这里作者主要通过这个函数演示一下数据指针的传递。例子如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;enter num:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input num:%d&quot;</span>,num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后看看arm的汇编如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">STMFD           SP!, &#123;R11,LR&#125;</span><br><span class="line">MOV             R11, SP</span><br><span class="line">SUB             SP, SP, #8</span><br><span class="line">MOV             R0, #0</span><br><span class="line">STR             R0, [SP,#8+var_4]</span><br><span class="line">LDR             R0, &#x3D;(aEnterNum - 0x14A0)</span><br><span class="line">ADD             R0, PC, R0 ; &quot;enter num:\n&quot;</span><br><span class="line">BL              printf</span><br><span class="line">LDR             R0, &#x3D;(unk_3C4 - 0x14AC)</span><br><span class="line">ADD             R0, PC, R0 ; unk_3C4 ; format</span><br><span class="line">MOV             R1, SP</span><br><span class="line">BL              scanf</span><br><span class="line">LDR             R1, [SP,#8+var_8]</span><br><span class="line">LDR             R0, &#x3D;(aInputNumD - 0x14C0)</span><br><span class="line">ADD             R0, PC, R0 ; &quot;input num:%d&quot;</span><br><span class="line">BL              printf</span><br><span class="line">MOV             R0, #0</span><br><span class="line">MOV             SP, R11</span><br><span class="line">LDMFD           SP!, &#123;R11,PC&#125;</span><br></pre></td></tr></table></figure><p>可以看到scanf的第二个参数直接是将sp传进去了，然后执行结束后，再用ldr将sp中的数据读取出来。</p><p>下面看看在arm64时的汇编，区别不大。不过看起来更加清晰一些。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SUB             SP, SP, #0x20</span><br><span class="line">STP             X29, X30, [SP,#0x10+var_s0]</span><br><span class="line">ADD             X29, SP, #0x10</span><br><span class="line">MOV             W8, WZR</span><br><span class="line">STR             W8, [SP,#0x10+var_C]</span><br><span class="line">STUR            WZR, [X29,#var_4]</span><br><span class="line">ADRP            X0, #aEnterNum@PAGE ; &quot;enter num:\n&quot;</span><br><span class="line">ADD             X0, X0, #aEnterNum@PAGEOFF ; &quot;enter num:\n&quot;</span><br><span class="line">BL              .printf</span><br><span class="line">ADRP            X0, #unk_578@PAGE</span><br><span class="line">ADD             X0, X0, #unk_578@PAGEOFF</span><br><span class="line">ADD             X1, SP, #0x10+var_8</span><br><span class="line">BL              .scanf</span><br><span class="line">LDR             W1, [SP,#0x10+var_8]</span><br><span class="line">ADRP            X0, #aInputNumD@PAGE ; &quot;input num:%d&quot;</span><br><span class="line">ADD             X0, X0, #aInputNumD@PAGEOFF ; &quot;input num:%d&quot;</span><br><span class="line">BL              .printf</span><br><span class="line">LDR             W0, [SP,#0x10+var_C]</span><br><span class="line">LDP             X29, X30, [SP,#0x10+var_s0]</span><br><span class="line">ADD             SP, SP, #0x20</span><br><span class="line">RET</span><br></pre></td></tr></table></figure><p>如果num变量是全局变量的情况又会有什么不同呢。下面看看调整后的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;enter num:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input num:%d&quot;</span>,num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是arm汇编</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">STMFD           SP!, &#123;R11,LR&#125;</span><br><span class="line">MOV             R11, SP</span><br><span class="line">SUB             SP, SP, #8</span><br><span class="line">MOV             R0, #0</span><br><span class="line">STR             R0, [SP,#8+var_4]</span><br><span class="line">LDR             R0, &#x3D;(aEnterNum - 0x14A0)</span><br><span class="line">ADD             R0, PC, R0 ; &quot;enter num:\n&quot;</span><br><span class="line">BL              printf</span><br><span class="line">LDR             R0, &#x3D;(unk_3C4 - 0x14AC)</span><br><span class="line">ADD             R0, PC, R0 ; unk_3C4 ; format</span><br><span class="line">LDR             R1, &#x3D;(num - 0x14B4)</span><br><span class="line">ADD             R1, PC, R1 ; num</span><br><span class="line">BL              scanf</span><br><span class="line">LDR             R0, &#x3D;(num - 0x14C0)</span><br><span class="line">ADD             R0, PC, R0 ; num</span><br><span class="line">LDR             R1, [R0]</span><br><span class="line">LDR             R0, &#x3D;(aInputNumD - 0x14CC)</span><br><span class="line">ADD             R0, PC, R0 ; &quot;input num:%d&quot;</span><br><span class="line">BL              printf</span><br><span class="line">MOV             R0, #0</span><br><span class="line">MOV             SP, R11</span><br><span class="line">LDMFD           SP!, &#123;R11,PC&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 逆向基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FartExt超进化之奇奇怪怪的新ROM工具MikRom</title>
      <link href="/2022/01/27/MikRom/"/>
      <url>/2022/01/27/MikRom/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​        一眨眼就到春节了，好久没有写文章了，趁着新年空闲，赶紧把自己折腾了一段时间的东西整理了一下。在折腾的过程中，碰到了不少问题，感谢大佬们的帮助。目前这个工具不算是怎么完善吧，但是感觉能凑合使用了，剩下的部分在使用中再慢慢完善吧，其中部分代码我会开源，其实感觉实现的核心并不怎么复杂。算是一个萌新学习定制ROM过程的一个作品把。而且还有个调试超级慢的BUG，如果有大佬知道是啥原因，还请指导一下。万分感谢。</p><a id="more"></a><h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><blockquote><p>看雪高研班课程</p><p>FART脱壳王课程</p><p>珍惜的android进阶课程</p></blockquote><h3 id="FartExt"><a href="#FartExt" class="headerlink" title="FartExt"></a>FartExt</h3><p>​        详细的介绍请看：<a href="https://bbs.pediy.com/thread-268760.htm">FartExt之优化更深主动调用的FART10</a></p><p>​        FartExt是我之前学习脱壳实践时做的一个自动脱壳机，是基于FART的主动调用思想实现对特定的抽取壳进行优化处理的工具。由于原本的FART没有配置相关的，所以我增加了配置对指定app脱壳。大致就是对FART的简单优化。由于感觉当时做的功能并不怎么完善，所以只是短暂的放了下载地址，就删掉了。不知道有没有人实际使用。使用的效果到底咋样。现在放出开源代码。</p><p>github：<a href="https://github.com/dqzg12300/FartExt">FartExt</a></p><h3 id="MikRom"><a href="#MikRom" class="headerlink" title="MikRom"></a>MikRom</h3><p>​        首先回顾一下当时FartExt文章最后的思考部分</p><blockquote><p>整个流程梳理完成后，我们可以由此来借鉴来思考延伸一下。</p><p>比如，包装一些属于自己的系统层api调用。便于我们使用xposed或者是frida来调用一些功能。</p><p>再比如，加载应用时，读取配置文件作为开关，我们来对网络流量进行拦截写入保存，或者对所有的jni函数调用，或者是java函数调用进行trace。这种就属于是rom级别的打桩。</p><p>再比如，可以做一个应用来读写作为开关的配置文件，而rom读取配置文件后，对一些流程进行调整。例如控制FART是否使用更深调用。控制是否开启rom级别的打桩。</p><p>以上纯属个人瞎想。刚刚入门，想的有点多，以后了解更深了，我再看看如何定制一个专属的rom逆向集合</p></blockquote><p>​        MikRom就是当时个人瞎想的成果，做一个Rom层面的逆向工具，为我们提供比较常用的插桩、注入、脱壳等一系列功能。下面列上目前MikRom中包含的功能</p><blockquote><ul><li>内核修改过反调试</li><li>开启硬件断点</li><li>USB调试默认连接</li><li>脱壳（黑名单、白名单过滤、更深的主动调用链）</li><li>ROM打桩（ArtMethod调用、RegisterNative调用、JNI函数调用）</li><li>frida持久化（支持listen,wait,script三种模式）</li><li>支持自行切换frida-gadget版本</li><li>反调试（通过sleep目标函数，再附加进程来过掉起始的反调试）</li><li>trace java函数（smali指令的trace）</li><li>内置dobby注入</li><li>注入so</li><li>注入dex（实现对应的接口触发调用。目前还未测试）</li></ul></blockquote><p>github：<a href="https://github.com/dqzg12300/MikRom">MikRom</a></p><h3 id="MikManager"><a href="#MikManager" class="headerlink" title="MikManager"></a>MikManager</h3><p>​        由于功能做的更加复杂了，我们自行编辑配置文件不再那么方便了，所以我特地做了一个界面化的工具来操作。最后将我们的设置保存到文件，然后MikRom会在打开app时读取文件，解析后做对应的操作。MikManager就是用来管理这个配置的。界面较为简陋，如果对MikRom感兴趣的，但是感觉我的界面太丑，也可以自己编写一个界面管理工具。我正向开发比较渣，所以代码较为粗糙。不过目前使用没啥问题。</p><p>github：<a href="https://github.com/dqzg12300/MikManager">MikManager</a></p><h3 id="开发的始末"><a href="#开发的始末" class="headerlink" title="开发的始末"></a>开发的始末</h3><p>​        虽然功能不是很多，但是做这个工具却折腾了我很长的时间，这里我将记录下这样一个简陋的Rom工具开发的历程，由于并不是很清楚其他大佬是如何处理的，所以有些功能都是我不断的试错中找到的方案。在试错的过程中，走了不少弯路，希望能帮到一些小伙伴。如果我采用的方案犯了什么比较低级的错误，还请大佬能指点一下。另外有大佬说，做越简单化的工具，越危险。如果有什么和谐的风险或者是法律的问题，还请联系我进行修改。</p><h3 id="编译版本"><a href="#编译版本" class="headerlink" title="编译版本"></a>编译版本</h3><p>​        早先FartExt我采用的是aosp10r2的源码进行修改编译。后来有同学觉得界面太简陋了，看起来就像山寨系统。确实如此，然后我就参考了hanbingle老师在Fart脱壳王使用的rom，选择了PixelExperience来进行修改。编译的marlin版本，测试手机是pixel XL。</p><blockquote><p>参考文章：<a href="https://blog.csdn.net/weixin_42443075/article/details/118084535">https://blog.csdn.net/weixin_42443075/article/details/118084535</a></p></blockquote><p>​        上面是我当时编译参考的文章。另外在编译PixelExperience时编译碰到错误，需要修改<code>build/blueprint/Blueprints</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bootstrap_go_package &#123;</span><br><span class="line">    name: &quot;blueprint-pathtools&quot;,</span><br><span class="line">    pkgPath: &quot;github.com&#x2F;google&#x2F;blueprint&#x2F;pathtools&quot;,</span><br><span class="line">    deps: [</span><br><span class="line">        &quot;blueprint-deptools&quot;,</span><br><span class="line">    ],</span><br><span class="line">    srcs: [</span><br><span class="line">        &quot;pathtools&#x2F;lists.go&quot;,</span><br><span class="line">        &quot;pathtools&#x2F;fs.go&quot;,</span><br><span class="line">        &quot;pathtools&#x2F;glob.go&quot;,</span><br><span class="line">    ],</span><br><span class="line">    testSrcs: [</span><br><span class="line">        &#x2F;&#x2F;修改处，这里的内容删掉</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        另外一个问题就是这个rom居然没法在mac进行编译，最后没办法只能用ubuntu来开发了。</p><h3 id="配置管理优化"><a href="#配置管理优化" class="headerlink" title="配置管理优化"></a>配置管理优化</h3><p>​        最早先在FartExt中的配置是我们自己在/data/local/tmp/中写入一个fext.config的文件，然后在应用启动过程中的handleBindApplication调用时，解析这个配置文件，来决定是否要脱壳。而现在配置更加复杂了，我们需要使用一个app来对配置进行管理生成，而app没有对/data/local/tmp写入文件的权限。所以我们这里就有了一个简单的需求，要将配置文件落地到一个所有应用都有权限访问的地方。</p><p>​        有人就要说了，我们可以落地到sdcard，是的，早期我就是这么干的。配置文件落地到sdcard后，所有的app要使用功能，就必须先打开sdcard，并且，由于我使用的rom版本是安卓10的，而安卓10中，你想要直接访问sdcard的任意目录，是需要设置<code>requestLegacyExternalStorage=&quot;true&quot;</code>。所以这就导致了，即使我们不嫌麻烦，每个想处理的app都打开sdcard，也会出现有些app无法访问到配置文件。</p><p>​        在这里我使用的方案是，创建一个系统服务，这个系统服务提供一个读和写的函数，然后通过调用系统服务将配置文件落地到<code>/data/system/</code>目录中，然后每个应用打开时再通过这个系统服务来读取配置。</p><h3 id="添加系统服务"><a href="#添加系统服务" class="headerlink" title="添加系统服务"></a>添加系统服务</h3><p>​        这个系统服务目前主要就是为配置管理提供读写权限。可能这样干会有些漏洞的问题，不过我这个rom本身就是逆向使用的工具，而面向正常用户，所以就暂时不考虑漏洞问题了。</p><blockquote><p>参考文章：<a href="https://bbs.pediy.com/thread-260472.htm">Android AOSP 添加系统服务【aidl接口服务】Java层</a></p><p>参考文章：<a href="https://blog.csdn.net/a546036242/article/details/118221349">android 10 添加系统服务步骤</a></p></blockquote><p>​        下面贴上我定义的系统服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMikRom</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//读取文件</span></span><br><span class="line">    <span class="function">String <span class="title">readFile</span><span class="params">(String path)</span></span>;</span><br><span class="line">    <span class="comment">//写入文件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeFile</span><span class="params">(String path,String data)</span></span>;</span><br><span class="line">    <span class="comment">//执行shell命令</span></span><br><span class="line">    <span class="function">String <span class="title">shellExec</span><span class="params">(String cmd)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        至于详细的读写方法我就不贴了，就是和android正常的读写文件处理一样。我就说一下在这里我碰到的坑，我按照参考文章一样的方式做完之后，发现无法找到服务，但是<code>service list|grep mikrom</code>是可以匹配到我自己定义的服务的。最后经过排查日志发现selinux提示缺少了find权限，于是我修改文件<code>system/sepolicy/public/untrusted_app.te</code>，内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type untrusted_app, domain;</span><br><span class="line">type untrusted_app_27, domain;</span><br><span class="line">type untrusted_app_25, domain;</span><br><span class="line">allow untrusted_app mikrom_service:service_manager find;</span><br><span class="line">allow untrusted_app_27 mikrom_service:service_manager find;</span><br><span class="line">allow untrusted_app_25 mikrom_service:service_manager find;</span><br></pre></td></tr></table></figure><p>最后成功找到服务，将配置文件写入到了<code>/data/system/</code>目录中。</p><p>这里我只简单的贴一下相关</p><p>MikManager的写入的相关代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IMikRom iMikRom = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IMikRom <span class="title">getiMikRom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (iMikRom == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class localClass = Class.forName(<span class="string">&quot;android.os.ServiceManager&quot;</span>);</span><br><span class="line">                Method getService = localClass.getMethod(<span class="string">&quot;getService&quot;</span>, <span class="keyword">new</span> Class[] &#123;String.class&#125;);</span><br><span class="line">                <span class="keyword">if</span>(getService != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Object objResult = getService.invoke(localClass, <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;mikrom&quot;</span>&#125;);</span><br><span class="line">                    <span class="keyword">if</span> (objResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        IBinder binder = (IBinder) objResult;</span><br><span class="line">                        iMikRom = IMikRom.Stub.asInterface(binder);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Log.d(<span class="string">&quot;MikManager&quot;</span>,e.getMessage());</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> iMikRom;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将json数据保存到指定路径</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SaveMikromConfig</span><span class="params">(List&lt;PackageItem&gt; packageList)</span></span>&#123;</span><br><span class="line">    Log.e(ConfigUtil.TAG,<span class="string">&quot;SaveMikromConfig&quot;</span>);</span><br><span class="line">    Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">    String savejson=gson.toJson(packageList);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ServiceUtils.getiMikRom().writeFile(ConfigUtil.configPath,savejson);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        Log.e(ConfigUtil.TAG,<span class="string">&quot;writeConfig err:&quot;</span>+e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MikRom中读取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> IMikRom iMikRom=<span class="keyword">null</span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IMikRom <span class="title">getiMikRom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (iMikRom == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               Class localClass = Class.forName(<span class="string">&quot;android.os.ServiceManager&quot;</span>);</span><br><span class="line">               Method getService = localClass.getMethod(<span class="string">&quot;getService&quot;</span>, <span class="keyword">new</span> Class[] &#123;String.class&#125;);</span><br><span class="line">               <span class="keyword">if</span>(getService != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   Object objResult = getService.invoke(localClass, <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;mikrom&quot;</span>&#125;);</span><br><span class="line">                   <span class="keyword">if</span> (objResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       IBinder binder = (IBinder) objResult;</span><br><span class="line">                       iMikRom = IMikRom.Stub.asInterface(binder);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               Log.d(<span class="string">&quot;MikManager&quot;</span>,e.getMessage());</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> iMikRom;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMikConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           IMikRom mikrom=getiMikRom();</span><br><span class="line">           <span class="keyword">if</span>(mikrom==<span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> mikrom.readFile(<span class="string">&quot;/data/system/mik.conf&quot;</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>测试的配置文件内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;&quot;appName&quot;:&quot;crackme&quot;,&quot;breakClass&quot;:&quot;&quot;,&quot;dexClassName&quot;:&quot;&quot;,&quot;dexPath&quot;:&quot;&quot;,&quot;enabled&quot;:true,&quot;fridaJsPath&quot;:&quot;&quot;,&quot;gadgetArm64Path&quot;:&quot;&quot;,&quot;gadgetPath&quot;:&quot;&quot;,&quot;isDeep&quot;:false,&quot;isDobby&quot;:false,&quot;isInvokePrint&quot;:false,&quot;isJNIMethodPrint&quot;:true,&quot;isRegisterNativePrint&quot;:false,&quot;isTuoke&quot;:false,&quot;packageName&quot;:&quot;com.kanxue.crackme&quot;,&quot;port&quot;:0,&quot;sleepNativeMethod&quot;:&quot;&quot;,&quot;soPath&quot;:&quot;&quot;,&quot;traceMethod&quot;:&quot;&quot;,&quot;whiteClass&quot;:&quot;&quot;,&quot;whitePath&quot;:&quot;&quot;&#125;]</span><br></pre></td></tr></table></figure><p>到这里第一步的优化就完成了，读写配置成功脱离了对sdcard的权限依赖，以及能全局应用都可以访问到。具体的详细相关代码可参考我放出的部分源码。</p><h3 id="脱壳相关优化"><a href="#脱壳相关优化" class="headerlink" title="脱壳相关优化"></a>脱壳相关优化</h3><p>​        由于我走向了另外一条偏向更易于使用的优化方向，所以关于脱壳的关键部分我并没有做什么优化，所以如果脱壳需求较大的朋友可以考虑看看hanbingle大佬的脱壳王是否能满足需求。</p><p>​        我对脱壳的优化主要分为两点，由于FartExt当时的脱壳结果保存是在sdcard中，所以对于权限有一定依赖，所以我优化掉了这块的依赖，让我们不用再手动开启sdcard权限，也能保存下脱壳结果。另外一点就是当时如果是抽取壳的情况，我们需要拿出两个文件来手动修复一下。我这里也优化了一下，会直接将函数执行完的dex重新再保存一份，这样就无需我们再手动修复了。当然同时也保留了原本的做法，仍然保存大佬说的几个重要元素。</p><h4 id="优化1方案：解决sdcard权限问题"><a href="#优化1方案：解决sdcard权限问题" class="headerlink" title="优化1方案：解决sdcard权限问题"></a>优化1方案：解决sdcard权限问题</h4><p>​        我尝试了很多种办法来避免我们手动开启sdcard权限的情况下保存脱壳结果文件。最后测试成功了两种办法。这两种办法我都简单说下。</p><p>​        第一种办法，我们直接将数据可以写入应用本身的内部空间中。也就是<code>/data/data/&lt;PackageName&gt;</code>中。但是这样有权限写入，但是没有root的话就无法访问到保存的结果了，当然没有root的情况也是能访问到应用内部数据的。我们可以通过命令<code>run-as &lt;PackageName&gt;</code>来直接进入应用数据内部。但是也有人会问，如果对方应用没有开启debuggable，不就没办法使用run-as了吗？这就是改Rom的优势所在了。我们可以直接修改PackageParser中的函数parseBaseApplication。在里面为我们默认打开debuggable即可。这样即使对方没有设置，在加载xml的时候，也会打开这个功能。</p><p>​        第二种办法，既然第一个办法最后可以直接改xml为我们默认打开debuggable，那么我们解决sdcard权限，也可以修改PackageParser中的函数parseBaseApplication来直接打开sdcard权限。不过由于安卓10的特殊性，即使打开了sdcard权限，也只能在sdcard中自己的目录写入数据，所以使用这个办法时，脱壳结果应保存在<code>/sdcard/Android/data/&lt;PackageName&gt;/</code>目录中。</p><p>​        下面贴上相关的代码，其中包含了两种解决方案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里我判断如果非系统应用才增加这些权限</span></span><br><span class="line"><span class="keyword">if</span>((ai.flags&amp;ApplicationInfo.FLAG_SYSTEM)!=<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="comment">//试错中发现，开启这些权限的时候，有个google和message相关的进程会崩溃，所以过滤一下</span></span><br><span class="line">           <span class="keyword">if</span>(!ai.packageName.contains(<span class="string">&quot;google&quot;</span>) &amp;&amp; !ai.packageName.contains(<span class="string">&quot;message&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">//下面是sdcard权限开启，以及debuggable权限开启。如果担心检测，可以关掉debuggable的默认开启</span></span><br><span class="line">               ai.privateFlags |= ApplicationInfo.PRIVATE_FLAG_REQUEST_LEGACY_EXTERNAL_STORAGE;</span><br><span class="line"></span><br><span class="line">               ai.flags |= ApplicationInfo.FLAG_EXTERNAL_STORAGE;</span><br><span class="line"></span><br><span class="line">               ai.flags |= ApplicationInfo.FLAG_DEBUGGABLE;</span><br><span class="line">               <span class="comment">// Debuggable implies profileable</span></span><br><span class="line">               ai.privateFlags |= ApplicationInfo.PRIVATE_FLAG_PROFILEABLE_BY_SHELL;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h4 id="优化2方案：解决抽取壳在脱壳完成后还需要手动修复"><a href="#优化2方案：解决抽取壳在脱壳完成后还需要手动修复" class="headerlink" title="优化2方案：解决抽取壳在脱壳完成后还需要手动修复"></a>优化2方案：解决抽取壳在脱壳完成后还需要手动修复</h4><p>​        在优化这个问题前，首先要意识到为什么会需要手动修复，当我们理解了大佬的处理之后，就发现hanbingle大佬为了避免每个函数主动调用都将dex给保存，所以只有文件不存在的时候才保存。也就意味着我们保存的dex是第一个主动调用执行时的dex。如果这个抽取壳是必须函数执行后才会恢复的，那么后面的函数在这个保存dex中都依然是被抽取的。FART的做法是将codeitem保存出来后，然后再修复。所以我将这里优化了一下。</p><p>​        知道问题所在后，优化的思路就清晰了，我采用了比较简单的一种优化方式，就是每个dex文件保存时，将这个dex的地址以及长度给保存下来。最后在所有主动调用完成时，重新将所有dex文件再保存一次。下面看看优化后的相关代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存放dex的指针和长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">void</span>*,<span class="keyword">size_t</span>&gt; dex_map;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主动调用函数的dump处理</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">dumpArtMethod</span><span class="params">(ArtMethod* artmethod)</span>  <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">int</span> dexfilefp=<span class="built_in">open</span>(dexfilepath,O_RDONLY,<span class="number">0666</span>);</span><br><span class="line">                <span class="comment">///dex文件存在则不处理,避免主动调用每次都要重新保存dex</span></span><br><span class="line">                <span class="keyword">if</span>(dexfilefp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">close</span>(dexfilefp);</span><br><span class="line">                    dexfilefp=<span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    LOG(ERROR) &lt;&lt; <span class="string">&quot;mikrom ArtMethod::dumpdexfilebyArtMethod save dex_map&quot;</span>;</span><br><span class="line">                    <span class="comment">//将这个地址给保存下来</span></span><br><span class="line">                    dex_map.insert(<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="keyword">void</span>*,<span class="keyword">size_t</span>&gt;((<span class="keyword">void</span>*)begin_,size_));</span><br><span class="line">                    <span class="keyword">int</span> fp=<span class="built_in">open</span>(dexfilepath,O_CREAT|O_APPEND|O_RDWR,<span class="number">0666</span>);</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主动调用完成时,重新保存到文件名&lt;dexSize&gt;_dexfile_repair.dex中</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">dumpDexOver</span><span class="params">()</span>  <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dex_map.<span class="built_in">size</span>()&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; <span class="string">&quot;mikrom dumpDexOver dex_map.size()&lt;=0&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> *dexfilepath=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">1000</span>);</span><br><span class="line">    LOG(ERROR) &lt;&lt; <span class="string">&quot;mikrom ArtMethod::dumpDexOver&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>* packageName=ArtMethod::GetPackageName();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">void</span>*, <span class="keyword">size_t</span>&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter = dex_map.<span class="built_in">begin</span>(); iter != dex_map.<span class="built_in">end</span>(); iter++) &#123;</span><br><span class="line">        <span class="keyword">void</span>* begin_=iter-&gt;first;</span><br><span class="line">        <span class="keyword">size_t</span> size_=iter-&gt;second;</span><br><span class="line">        <span class="keyword">int</span> size_int_=(<span class="keyword">int</span>)size_;</span><br><span class="line">        <span class="built_in">memset</span>(dexfilepath,<span class="number">0</span>,<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">sprintf</span>(dexfilepath,<span class="string">&quot;/sdcard/Android/data/%s/files/dump&quot;</span>,packageName);</span><br><span class="line">        <span class="built_in">mkdir</span>(dexfilepath,<span class="number">0777</span>);</span><br><span class="line">        <span class="built_in">memset</span>(dexfilepath,<span class="number">0</span>,<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">sprintf</span>(dexfilepath,<span class="string">&quot;/sdcard/Android/data/%s/files/dump/%d_dexfile_repair.dex&quot;</span>,packageName,size_int_);</span><br><span class="line">        <span class="keyword">int</span> dexfilefp=<span class="built_in">open</span>(dexfilepath,O_RDONLY,<span class="number">0666</span>);</span><br><span class="line">        <span class="keyword">if</span>(dexfilefp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="built_in">close</span>(dexfilefp);</span><br><span class="line">          dexfilefp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">int</span> fp=<span class="built_in">open</span>(dexfilepath,O_CREAT|O_APPEND|O_RDWR,<span class="number">0666</span>);</span><br><span class="line">          <span class="keyword">if</span>(fp&gt;<span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              result=<span class="built_in">write</span>(fp,(<span class="keyword">void</span>*)begin_,size_);</span><br><span class="line">              <span class="keyword">if</span>(result&lt;<span class="number">0</span>)</span><br><span class="line">              &#123;</span><br><span class="line">                  LOG(ERROR) &lt;&lt; <span class="string">&quot;mikrom ArtMethod::dumpDexOver,open dexfilepath error&quot;</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              fsync(fp);</span><br><span class="line">              <span class="built_in">close</span>(fp);</span><br><span class="line">              <span class="built_in">memset</span>(dexfilepath,<span class="number">0</span>,<span class="number">1000</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dexfilepath!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(dexfilepath);</span><br><span class="line">        dexfilepath=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后生成的_repair.dex文件就是无需再修复的了，如果想要手动修复按照原来的方式也可以。当然，如果主动调用未能成功跑完，这个repair文件也是不会生成的。</p><h3 id="新增功能"><a href="#新增功能" class="headerlink" title="新增功能"></a>新增功能</h3><h4 id="1、修改内核反调试"><a href="#1、修改内核反调试" class="headerlink" title="1、修改内核反调试"></a>1、修改内核反调试</h4><p>​        关于修改内核反调试已经有相当多的文章讲解了，我这里也是和他们用的同一个方案，基本都是根据正向检测调试的方式，来进行反调试，当然如果有人用其他方式来判断是否被调试，这个反调试就无效了。详细的过反调试原理可以看参考文章。</p><blockquote><p>参考文章：<a href="https://blog.csdn.net/u011426115/article/details/113144592">修改内核源码绕过反调试检测（Android10）</a></p></blockquote><p>​        虽然我改了。但是没测试效果咋样。修改的代码如下，<code>kernel/google/marlin/fs/proc/array.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> task_state_array[] = &#123;</span><br><span class="line">    <span class="string">&quot;R (running)&quot;</span>,        <span class="comment">/*   0 */</span></span><br><span class="line">    <span class="string">&quot;S (sleeping)&quot;</span>,        <span class="comment">/*   1 */</span></span><br><span class="line">    <span class="string">&quot;D (disk sleep)&quot;</span>,    <span class="comment">/*   2 */</span></span><br><span class="line">    <span class="string">&quot;S (sleeping)&quot;</span>,        <span class="comment">/*   4 */</span>         <span class="comment">//这里之前是 &quot;T (stopped)&quot;,</span></span><br><span class="line">    <span class="string">&quot;S (sleeping)&quot;</span>,        <span class="comment">/*   8 */</span>         <span class="comment">//这里之前是 &quot;t (tracing stop)&quot;</span></span><br><span class="line">    <span class="string">&quot;X (dead)&quot;</span>,        <span class="comment">/*  16 */</span></span><br><span class="line">    <span class="string">&quot;Z (zombie)&quot;</span>,        <span class="comment">/*  32 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">task_state</span><span class="params">(struct seq_file *m, struct pid_namespace *ns,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct pid *pid, struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span> = <span class="title">seq_user_ns</span>(<span class="title">m</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span></span><br><span class="line">    <span class="keyword">int</span> g;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">cred</span>;</span></span><br><span class="line">    <span class="keyword">pid_t</span> ppid = <span class="number">0</span>, tpid = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">leader</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    <span class="keyword">if</span> (pid_alive(p)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tracer</span> = <span class="title">ptrace_parent</span>(<span class="title">p</span>);</span></span><br><span class="line">        <span class="keyword">if</span> (tracer)</span><br><span class="line">            tpid = task_pid_nr_ns(tracer, ns);</span><br><span class="line">        ppid = task_tgid_nr_ns(rcu_dereference(p-&gt;real_parent), ns);</span><br><span class="line">        leader = p-&gt;group_leader;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个直接强制改tpid为0。</span></span><br><span class="line">    tpid=<span class="number">0</span>;</span><br><span class="line">    cred = get_task_cred(p);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当对方检测<code>/proc/&lt;pid&gt;/status</code>文件时，获取到的TracerPid就会一直是0，并且应用的状态不会出现<code>stopped</code>和<code>tracing stop</code>。下面是status的部分内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Name:    .kanxue.crackme</span><br><span class="line">State:    S (sleeping)</span><br><span class="line">Tgid:    12142</span><br><span class="line">Pid:    12142</span><br><span class="line">PPid:    545</span><br><span class="line">TracerPid:    0</span><br><span class="line">Uid:    10027    10027    10027    10027</span><br><span class="line">Gid:    10027    10027    10027    10027</span><br><span class="line">Ngid:    0</span><br><span class="line">FDSize:    128</span><br><span class="line">Groups:    9997 20027 50027 </span><br><span class="line">VmPeak:     5657524 kB</span><br><span class="line">VmSize:     5210040 kB</span><br></pre></td></tr></table></figure><p>还有一处修改文件是<code>kernel/google/marlin/fs/proc/base.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">proc_pid_wchan</span><span class="params">(struct seq_file *m, struct pid_namespace *ns,</span></span></span><br><span class="line"><span class="function"><span class="params">              struct pid *pid, struct task_struct *task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> wchan;</span><br><span class="line">    <span class="keyword">char</span> symname[KSYM_NAME_LEN];</span><br><span class="line"></span><br><span class="line">    wchan = get_wchan(task);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lookup_symbol_name(wchan, symname) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (!ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> seq_printf(m, <span class="string">&quot;%lu&quot;</span>, wchan);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(symname,<span class="string">&quot;trace&quot;</span>))&#123;        <span class="comment">//这里是新增的，如果符号名称包含trace，就固定改成sys_epoll_wait</span></span><br><span class="line">            <span class="keyword">return</span> seq_printf(m,<span class="string">&quot;%s&quot;</span>,<span class="string">&quot;SyS_epoll_wait&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> seq_printf(m, <span class="string">&quot;%s&quot;</span>, symname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、sleep反调试"><a href="#2、sleep反调试" class="headerlink" title="2、sleep反调试"></a>2、sleep反调试</h4><p>​        通过sleep的反调试方式是在看雪高研班中学习到的，据说这个办法可以过掉一些在前期检测的native的反调试。思路就是需要调试的JNI函数执行前会调用JniMethodStart，那么我们只要在这里进行判断，如果这个函数是目标函数，就sleep睡眠若干秒。在睡眠期间，我们再调试附加上即可。相关代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">uint32_t</span> <span class="title">JniMethodStart</span><span class="params">(Thread* self)</span> </span>&#123;</span><br><span class="line">  JNIEnvExt* env = self-&gt;GetJniEnv();</span><br><span class="line">  DCHECK(env != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">uint32_t</span> saved_local_ref_cookie = bit_cast&lt;<span class="keyword">uint32_t</span>&gt;(env-&gt;GetLocalRefCookie());</span><br><span class="line">  env-&gt;SetLocalRefCookie(env-&gt;GetLocalsSegmentState());</span><br><span class="line">  ArtMethod* native_method = *self-&gt;GetManagedStack()-&gt;GetTopQuickFrame();</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Introduce special entrypoint for synchronized @FastNative methods?</span></span><br><span class="line">  <span class="comment">//       Or ban synchronized @FastNative outright to avoid the extra check here?</span></span><br><span class="line">  DCHECK(!native_method-&gt;IsFastNative() || native_method-&gt;IsSynchronized());</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* methodname=native_method-&gt;PrettyMethod().c_str();</span><br><span class="line">  <span class="keyword">if</span>(ArtMethod::GetDebugMethod()!=<span class="literal">nullptr</span> &amp;&amp; <span class="built_in">strlen</span>(ArtMethod::GetDebugMethod())&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strstr</span>(methodname,ArtMethod::GetDebugMethod())!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">ostringstream</span> oss1;</span><br><span class="line">            oss1&lt;&lt; <span class="string">&quot;fartext JniMethodStart methodname:&quot;</span>&lt;&lt;methodname&lt;&lt;<span class="string">&quot; wait debug sleep 60...&quot;</span>;</span><br><span class="line">            LOG(ERROR)&lt;&lt;oss1.str();</span><br><span class="line">            sleep(<span class="number">60</span>);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!native_method-&gt;IsFastNative()) &#123;</span><br><span class="line">    <span class="comment">// When not fast JNI we transition out of runnable.</span></span><br><span class="line">    self-&gt;TransitionFromRunnableToSuspended(kNative);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> saved_local_ref_cookie;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、ROM级打桩"><a href="#3、ROM级打桩" class="headerlink" title="3、ROM级打桩"></a>3、ROM级打桩</h4><p>​        这个其实没什么难的，在关键的函数位置直接打印即可。我只讲一下jni的打桩部分，我查资料的时候看到了两种做法，第一种是打印jni部分是在jni函数中找比较通用的调用函数，例如<code>InvokeVirtualOrInterfaceWithJValues、InvokeWithVarArgs、InvokeWithJValues</code>，然后在里面加上打印。第二种就是像jnitracer一样，通过偏移，找到所有的函数指针，然后再包装处理，比如加一个外层函数调用。由于我c++非常烂，所以我采用最笨的方法，我写了几个较为通用的打印函数，jni_internal.cc中的所有我关心的jni函数，就调用各自对应的打印函数。下面贴上我的例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowVarArgs</span><span class="params">(<span class="keyword">const</span> ScopedObjectAccessAlreadyRunnable&amp; soa,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">const</span> <span class="keyword">char</span>* jniMethod,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           jmethodID mid,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           va_list args)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(ArtMethod::IsJNIMethodPrint())&#123;</span><br><span class="line">                 ArtMethod* method = jni::DecodeArtMethod(mid);</span><br><span class="line">               <span class="keyword">uint32_t</span> shorty_len = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">const</span> <span class="keyword">char</span>* shorty =</span><br><span class="line">               method-&gt;GetInterfaceMethodIfProxy(kRuntimePointerSize)-&gt;GetShorty(&amp;shorty_len);</span><br><span class="line">         JValue result;</span><br><span class="line">         <span class="function">ArgArray <span class="title">arg_array</span><span class="params">(shorty, shorty_len)</span></span>;</span><br><span class="line">         arg_array.VarArgsShowArg(soa, args,jniMethod,method-&gt;PrettyMethod().c_str());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowJValue</span><span class="params">(<span class="keyword">const</span> ScopedObjectAccessAlreadyRunnable&amp; soa,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">const</span> <span class="keyword">char</span>* jniMethod,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           jmethodID mid,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">const</span> jvalue* args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ArtMethod::IsJNIMethodPrint())&#123;</span><br><span class="line">                ArtMethod* method = jni::DecodeArtMethod(mid);</span><br><span class="line">                <span class="keyword">uint32_t</span> shorty_len = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">char</span>* shorty =</span><br><span class="line">                        method-&gt;GetInterfaceMethodIfProxy(kRuntimePointerSize)-&gt;GetShorty(&amp;shorty_len);</span><br><span class="line">                JValue result;</span><br><span class="line">                <span class="function">ArgArray <span class="title">arg_array</span><span class="params">(shorty, shorty_len)</span></span>;</span><br><span class="line">                arg_array.JValuesShowArg(soa, args,jniMethod,method-&gt;PrettyMethod().c_str());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowJniField</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* jniMethodName,jfieldID field)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ArtMethod::IsJNIMethodPrint())&#123;</span><br><span class="line">            ArtField* f = jni::DecodeArtField(field);</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">ostringstream</span> oss;</span><br><span class="line">            oss &lt;&lt; <span class="string">&quot;mikrom jni &quot;</span>&lt;&lt;jniMethodName&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;ArtField::PrettyField(f);</span><br><span class="line">            LOG(ERROR)&lt;&lt;oss.str();</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowArgStr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* jniMethod,<span class="keyword">const</span> <span class="keyword">char</span>* str1,<span class="keyword">const</span> <span class="keyword">char</span>* str2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ArtMethod::IsJNIMethodPrint())&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">ostringstream</span> oss;</span><br><span class="line">            <span class="keyword">if</span>(str1!=<span class="literal">nullptr</span> &amp;&amp; str2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                oss &lt;&lt; <span class="string">&quot;mikrom jni &quot;</span>&lt;&lt;jniMethod&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;str1&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;str2;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str1!=<span class="literal">nullptr</span> )&#123;</span><br><span class="line">                oss &lt;&lt; <span class="string">&quot;mikrom jni &quot;</span>&lt;&lt;jniMethod&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;str1;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                oss &lt;&lt; <span class="string">&quot;mikrom jni &quot;</span>&lt;&lt;jniMethod;</span><br><span class="line">            &#125;</span><br><span class="line">            LOG(ERROR)&lt;&lt;oss.str();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理完判断部分，接下来就是对于参数的打印部分了，这里我只处理了下将字符串参数打印出来，其他特殊的参数我就没有处理了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VarArgsShowArg</span><span class="params">(<span class="keyword">const</span> ScopedObjectAccessAlreadyRunnable&amp; soa,</span></span></span><br><span class="line"><span class="function"><span class="params">                                va_list ap,<span class="keyword">const</span> <span class="keyword">char</span>* jniMethodName,<span class="keyword">const</span> <span class="keyword">char</span>* methodName)</span></span></span><br><span class="line"><span class="function">      <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">  ss &lt;&lt; <span class="string">&quot;mikrom jni &quot;</span>&lt;&lt;jniMethodName&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;methodName&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; shorty_len_; ++i) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (shorty_[i]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Z&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">          ss&lt;&lt;<span class="string">&quot;arg&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;va_arg(ap, jint)&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">            ss&lt;&lt;<span class="string">&quot;arg&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;va_arg(ap, jdouble)&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:&#123;</span><br><span class="line">            jobject obj=va_arg(ap, jobject);</span><br><span class="line">                ObjPtr&lt;mirror::Object&gt; receiver =soa.Decode&lt;mirror::Object&gt;(obj);</span><br><span class="line">                <span class="keyword">if</span>(receiver==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    LOG(ERROR)&lt;&lt;<span class="string">&quot;mikrom  &quot;</span>&lt;&lt;jniMethodName&lt;&lt;<span class="string">&quot; receiver =nullptr&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ObjPtr&lt;mirror::Class&gt; cls=receiver-&gt;GetClass();</span><br><span class="line">                <span class="keyword">if</span> (cls-&gt;DescriptorEquals(<span class="string">&quot;Ljava/lang/String;&quot;</span>))&#123;</span><br><span class="line">                        ObjPtr&lt;mirror::<span class="keyword">String</span>&gt; argStr =soa.Decode&lt;mirror::<span class="keyword">String</span>&gt;(obj);</span><br><span class="line">                        ss&lt;&lt;<span class="string">&quot;arg&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;(<span class="keyword">const</span> <span class="keyword">char</span>*)argStr-&gt;GetValue();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        ss&lt;&lt;<span class="string">&quot;arg&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;receiver&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">          ss&lt;&lt;<span class="string">&quot;arg&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;va_arg(ap, jdouble)&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;J&#x27;</span>:</span><br><span class="line">          ss&lt;&lt;<span class="string">&quot;arg&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;va_arg(ap, jlong)&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LOG(ERROR) &lt;&lt; ss.str();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">JValuesShowArg</span><span class="params">(<span class="keyword">const</span> ScopedObjectAccessAlreadyRunnable&amp; soa,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> jvalue* args,<span class="keyword">const</span> <span class="keyword">char</span> * jniMethodName,<span class="keyword">const</span> <span class="keyword">char</span>* methodName)</span></span></span><br><span class="line"><span class="function">      <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;mikrom jni &quot;</span>&lt;&lt;jniMethodName&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;methodName&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>, args_offset = <span class="number">0</span>; i &lt; shorty_len_; ++i, ++args_offset) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (shorty_[i]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Z&#x27;</span>:</span><br><span class="line">          ss&lt;&lt;<span class="string">&quot;arg&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;args[args_offset].z&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">          ss&lt;&lt;<span class="string">&quot;arg&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;args[args_offset].b&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">          ss&lt;&lt;<span class="string">&quot;arg&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;args[args_offset].c&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">          ss&lt;&lt;<span class="string">&quot;arg&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;args[args_offset].s&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">          FALLTHROUGH_INTENDED;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">          ss&lt;&lt;<span class="string">&quot;arg&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;args[args_offset].i&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:&#123;</span><br><span class="line">            jobject obj=args[args_offset].l;</span><br><span class="line">                ObjPtr&lt;mirror::Object&gt; receiver =soa.Decode&lt;mirror::Object&gt;(obj);</span><br><span class="line">                <span class="keyword">if</span>(receiver==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    LOG(ERROR)&lt;&lt;<span class="string">&quot;mikrom  &quot;</span>&lt;&lt;jniMethodName&lt;&lt;<span class="string">&quot; receiver =nullptr&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ObjPtr&lt;mirror::Class&gt; cls=receiver-&gt;GetClass();</span><br><span class="line">                <span class="keyword">if</span> (cls-&gt;DescriptorEquals(<span class="string">&quot;Ljava/lang/String;&quot;</span>))&#123;</span><br><span class="line">                        ObjPtr&lt;mirror::<span class="keyword">String</span>&gt; argStr =soa.Decode&lt;mirror::<span class="keyword">String</span>&gt;(obj);</span><br><span class="line">                        ss&lt;&lt;<span class="string">&quot;arg&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;(<span class="keyword">const</span> <span class="keyword">char</span>*)argStr-&gt;GetValue();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        ss&lt;&lt;<span class="string">&quot;arg&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;receiver&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">          FALLTHROUGH_INTENDED;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;J&#x27;</span>:</span><br><span class="line">          ss&lt;&lt;<span class="string">&quot;arg&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;args[args_offset].j&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LOG(ERROR) &lt;&lt; ss.str();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>搞定了封装部分，就看看调用部分是怎么使用的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> jdouble <span class="title">CallDoubleMethodA</span><span class="params">(JNIEnv* env, jobject obj, jmethodID mid, <span class="keyword">const</span> jvalue* args)</span> </span>&#123;</span><br><span class="line">  CHECK_NON_NULL_ARGUMENT_RETURN_ZERO(obj);</span><br><span class="line">  CHECK_NON_NULL_ARGUMENT_RETURN_ZERO(mid);</span><br><span class="line">  <span class="function">ScopedObjectAccess <span class="title">soa</span><span class="params">(env)</span></span>;</span><br><span class="line">  <span class="comment">//add</span></span><br><span class="line">  ShowJValue(soa,__FUNCTION__,mid,args);</span><br><span class="line">  <span class="comment">//add end</span></span><br><span class="line">  <span class="keyword">return</span> InvokeVirtualOrInterfaceWithJValues(soa, obj, mid, args).GetD();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> jfloat <span class="title">CallFloatMethod</span><span class="params">(JNIEnv* env, jobject obj, jmethodID mid, ...)</span> </span>&#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  va_start(ap, mid);</span><br><span class="line">  <span class="function">ScopedVAArgs <span class="title">free_args_later</span><span class="params">(&amp;ap)</span></span>;</span><br><span class="line">  CHECK_NON_NULL_ARGUMENT_RETURN_ZERO(obj);</span><br><span class="line">  CHECK_NON_NULL_ARGUMENT_RETURN_ZERO(mid);</span><br><span class="line">  <span class="function">ScopedObjectAccess <span class="title">soa</span><span class="params">(env)</span></span>;</span><br><span class="line">  <span class="comment">//add</span></span><br><span class="line">  ShowVarArgs(soa,__FUNCTION__,mid,ap);</span><br><span class="line">  <span class="comment">//add end</span></span><br><span class="line">  <span class="function">JValue <span class="title">result</span><span class="params">(InvokeVirtualOrInterfaceWithVarArgs(soa, obj, mid, ap))</span></span>;</span><br><span class="line">  <span class="keyword">return</span> result.GetF();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里就搞定了jni的打印以及参数的打印，大多数调用我都打印了，由于我实战的少，所以可能会漏掉一些常用的打印，如果有发现什么比较有用的打印，也可以告诉我优化下。</p><h4 id="4、frida-gadget持久化"><a href="#4、frida-gadget持久化" class="headerlink" title="4、frida-gadget持久化"></a>4、frida-gadget持久化</h4><p>​        这个frida持久化的问题，论坛里面也发过一遍又一遍了。我也是参考他们的文章，然后测试优化。先贴上参考文章。</p><blockquote><p>参考文章：<a href="https://www.mobibrw.com/2021/28588">ubuntu 20.04系统AOSP(Android 11)集成Frida</a></p><p>参考文章：<a href="https://bbs.pediy.com/thread-270028.htm">从0开始实现一个简易的主动调用框架</a></p></blockquote><p>​        不过我的加载时机和他的不太一样，并且我扩展了可自行切换frida-gadget的版本，默认集成到系统中的版本是15.1，如果你喜欢用14.2的版本，可以自己上传到手机进行切换，如果你想不root的情况下，也可以通过MikManager设置切换的版本。下面贴上加载的部分代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadGadget</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String processName = ActivityThread.currentProcessName();</span><br><span class="line">        <span class="keyword">for</span>(PackageItem item : mikConfigs)&#123;</span><br><span class="line">            <span class="keyword">if</span>(item.packageName.equals(processName))&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(item.fridaJsPath.length()&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    String configPath=<span class="string">&quot;/data/data/&quot;</span>+processName+<span class="string">&quot;/libfdgg.config.so&quot;</span>;</span><br><span class="line">                    String configPath2=<span class="string">&quot;/data/data/&quot;</span>+processName+<span class="string">&quot;/libfdgg32.config.so&quot;</span>;</span><br><span class="line">                    <span class="keyword">if</span>(item.fridaJsPath.equals(<span class="string">&quot;listen&quot;</span>)||item.fridaJsPath.equals(<span class="string">&quot;listen_wait&quot;</span>))&#123;</span><br><span class="line">                        WriteConfig(configPath,item.fridaJsPath,item.port);</span><br><span class="line">                        WriteConfig(configPath2,item.fridaJsPath,item.port);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        File file = <span class="keyword">new</span> File(item.fridaJsPath);</span><br><span class="line">                        <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">                            file = <span class="keyword">new</span> File( <span class="string">&quot;/data/data/&quot;</span> + processName +<span class="string">&quot;/&quot;</span>+file.getName());</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">                            Log.e(<span class="string">&quot;mikrom&quot;</span>, <span class="string">&quot;initConfig package:&quot;</span> + processName+<span class="string">&quot; frida js path:&quot;</span>+item.fridaJsPath+<span class="string">&quot; not found&quot;</span>);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        WriteConfig(configPath,item.fridaJsPath,item.port);</span><br><span class="line">                        WriteConfig(configPath2,item.fridaJsPath,item.port);</span><br><span class="line">                    &#125;</span><br><span class="line">                    String tagPath = <span class="string">&quot;/data/data/&quot;</span> + processName + <span class="string">&quot;/libfdgg.so&quot;</span>;<span class="comment">//64位so的目录</span></span><br><span class="line">                    String tagPath2 = <span class="string">&quot;/data/data/&quot;</span> + processName + <span class="string">&quot;/libfdgg32.so&quot;</span>;<span class="comment">//32位的so目录</span></span><br><span class="line">                    <span class="comment">//使用用户自己设置的gadget路径</span></span><br><span class="line">                    <span class="keyword">if</span>(item.gadgetPath!=<span class="keyword">null</span>&amp;&amp;item.gadgetPath.length()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        mycopy(item.gadgetArm64Path, tagPath);<span class="comment">//复制so到私有目录</span></span><br><span class="line">                        mycopy(item.gadgetPath, tagPath2);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        mycopy(<span class="string">&quot;/system/lib64/libfdgg.so&quot;</span>, tagPath);<span class="comment">//复制so到私有目录</span></span><br><span class="line">                        mycopy(<span class="string">&quot;/system/lib/libfdgg.so&quot;</span>, tagPath2);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">int</span> perm = FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IRWXO;</span><br><span class="line">                    FileUtils.setPermissions(tagPath, perm, -<span class="number">1</span>, -<span class="number">1</span>);<span class="comment">//将权限改为777</span></span><br><span class="line">                    FileUtils.setPermissions(tagPath2, perm, -<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">                    FileUtils.setPermissions(configPath, perm, -<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">                    FileUtils.setPermissions(configPath2, perm, -<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">                    File file1 = <span class="keyword">new</span> File(tagPath);</span><br><span class="line">                    File file2 = <span class="keyword">new</span> File(tagPath2);</span><br><span class="line">                    <span class="keyword">if</span> (file1.exists()) &#123;</span><br><span class="line">                        Log.e(<span class="string">&quot;mikrom&quot;</span>, <span class="string">&quot;app: &quot;</span> +System.getProperty(<span class="string">&quot;os.arch&quot;</span>));<span class="comment">//判断是64位还是32位</span></span><br><span class="line">                        <span class="keyword">if</span> (System.getProperty(<span class="string">&quot;os.arch&quot;</span>).indexOf(<span class="string">&quot;64&quot;</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            Log.e(<span class="string">&quot;mikrom&quot;</span>, <span class="string">&quot;initConfig package:&quot;</span> + processName+<span class="string">&quot; frida js path:&quot;</span>+item.fridaJsPath+<span class="string">&quot; load arch64&quot;</span>);</span><br><span class="line">                            System.load(tagPath);</span><br><span class="line">                            file1.delete();<span class="comment">//用完就删否则不会更新</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            Log.e(<span class="string">&quot;mikrom&quot;</span>, <span class="string">&quot;initConfig package:&quot;</span> + processName+<span class="string">&quot; frida js path:&quot;</span>+item.fridaJsPath+<span class="string">&quot; load 32&quot;</span>);</span><br><span class="line">                            System.load(tagPath2);</span><br><span class="line">                            file2.delete();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Log.e(<span class="string">&quot;mikrom&quot;</span>, <span class="string">&quot;initConfig package:&quot;</span> + processName+<span class="string">&quot; initConfig over&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">                    Log.e(<span class="string">&quot;mikrom&quot;</span>, <span class="string">&quot;initConfig package:&quot;</span> + processName+<span class="string">&quot; frida js path:&quot;</span>+item.fridaJsPath+<span class="string">&quot; load err:&quot;</span>+ex.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>同时也是支持以三种模式加载gadget的，比如默认加载脚本，或者监听模式，也就是可以frida连接上去，或者是监听并阻塞等待。不过我留意到，有些自己写的简单app似乎使用gadget注入似乎并不成功。好像需要app对native有什么实现才行。</p><h4 id="5、so注入以及dobby的内置"><a href="#5、so注入以及dobby的内置" class="headerlink" title="5、so注入以及dobby的内置"></a>5、so注入以及dobby的内置</h4><p>​        前面gadget的部分实际就是注入so了，但是前面的部分主要是针对gadget的注入相关处理的。我又特地单独处理了一下对so的注入，如果我们自己写了一个so想要单独注入进去也是可以的。为了方便演示，我特地将dobby内置进去。由于dobby是一个hook框架，并且没有注入功能，往往都是需要通过其他手段注入到应用中。所以我直接内置进来了。下面贴上相关代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadSo</span><span class="params">(String path)</span></span>&#123;</span><br><span class="line">       String processName = ActivityThread.currentProcessName();</span><br><span class="line">       String fName = path.trim();</span><br><span class="line">       String fileName = fName.substring(fName.lastIndexOf(<span class="string">&quot;/&quot;</span>)+<span class="number">1</span>);</span><br><span class="line">       String tagPath = <span class="string">&quot;/data/data/&quot;</span> + processName + <span class="string">&quot;/&quot;</span>+fileName;<span class="comment">//64位so的目录</span></span><br><span class="line">       mycopy(path, tagPath);</span><br><span class="line">       <span class="keyword">int</span> perm = FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IRWXO;</span><br><span class="line">       FileUtils.setPermissions(tagPath, perm, -<span class="number">1</span>, -<span class="number">1</span>);<span class="comment">//将权限改为777</span></span><br><span class="line">       File file = <span class="keyword">new</span> File(tagPath);</span><br><span class="line">       <span class="keyword">if</span> (file.exists())&#123;</span><br><span class="line">           Log.e(<span class="string">&quot;mikrom&quot;</span>, <span class="string">&quot;load so:&quot;</span>+tagPath);</span><br><span class="line">           System.load(tagPath);</span><br><span class="line">           file.delete();<span class="comment">//用完就删否则不会更新</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//注入so</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadConfigSo</span><span class="params">()</span></span>&#123;</span><br><span class="line">       String processName = ActivityThread.currentProcessName();</span><br><span class="line">       <span class="keyword">for</span>(PackageItem item : mikConfigs)&#123;</span><br><span class="line">           <span class="keyword">if</span>(!item.packageName.equals(processName))</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           <span class="keyword">if</span>(item.soPath.length()&lt;=<span class="number">0</span>)</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(item.isDobby)&#123;</span><br><span class="line">               <span class="keyword">if</span>(System.getProperty(<span class="string">&quot;os.arch&quot;</span>).indexOf(<span class="string">&quot;64&quot;</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                   loadSo(<span class="string">&quot;/system/lib64/libdby_64.so&quot;</span>);</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   loadSo(<span class="string">&quot;/system/lib/libdby.so&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           String[] soList=item.soPath.split(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">           <span class="keyword">for</span>(String sopath :soList)&#123;</span><br><span class="line">               loadSo(sopath);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="6、smali-trace"><a href="#6、smali-trace" class="headerlink" title="6、smali trace"></a>6、smali trace</h4><p>​        实际上这个功能在ROM中是有的，就是TraceExecution函数，只是需要控制打开就行了，但是必须走switch解释器执行才能执行到便于我们修改的地方。所以这个就有两个地方需要修改，第一个是判断打印的部分，第二个是强制以解释器执行的部分。下面看看我的修改部分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">TraceExecution</span><span class="params">(<span class="keyword">const</span> ShadowFrame&amp; shadow_frame, <span class="keyword">const</span> Instruction* inst,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">const</span> <span class="keyword">uint32_t</span> dex_pc)</span></span></span><br><span class="line"><span class="function">    <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(shadow_frame.GetMethod()!=<span class="literal">nullptr</span> &amp;&amp; ArtMethod::GetTraceMethod()!=<span class="literal">nullptr</span>&amp;&amp;<span class="built_in">strlen</span>(ArtMethod::GetTraceMethod())&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* methodName=shadow_frame.GetMethod()-&gt;PrettyMethod().c_str();</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(methodName,ArtMethod::GetTraceMethod())) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">ostringstream</span> oss;</span><br><span class="line">                    oss &lt;&lt; android::base::StringPrintf(<span class="string">&quot;mikrom smaliTrace 0x%x: &quot;</span>, dex_pc)</span><br><span class="line">                            &lt;&lt; inst-&gt;DumpString(shadow_frame.GetMethod()-&gt;GetDexFile()) &lt;&lt; <span class="string">&quot;\t//&quot;</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; shadow_frame.NumberOfVRegs(); ++i) &#123;</span><br><span class="line">                        <span class="keyword">uint32_t</span> raw_value = shadow_frame.GetVReg(i);</span><br><span class="line">                        ObjPtr&lt;mirror::Object&gt; ref_value = shadow_frame.GetVRegReference(i);</span><br><span class="line">                        oss &lt;&lt; android::base::StringPrintf(<span class="string">&quot; vreg%u=0x%08X&quot;</span>, i, raw_value);</span><br><span class="line">                        <span class="keyword">if</span> (ref_value != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (ref_value-&gt;GetClass()-&gt;IsStringClass() &amp;&amp;</span><br><span class="line">                                    !ref_value-&gt;AsString()-&gt;IsValueNull()) &#123;</span><br><span class="line">                                oss &lt;&lt; <span class="string">&quot;/java.lang.String \&quot;&quot;</span> &lt;&lt; ref_value-&gt;AsString()-&gt;ToModifiedUtf8() &lt;&lt; <span class="string">&quot;\&quot;&quot;</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                oss &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; ref_value-&gt;PrettyTypeOf();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    LOG(ERROR)&lt;&lt;oss.str();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外就是强制以解释器执行的部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static inline JValue Execute(</span><br><span class="line">    Thread* self,</span><br><span class="line">    const CodeItemDataAccessor&amp; accessor,</span><br><span class="line">    ShadowFrame&amp; shadow_frame,</span><br><span class="line">    JValue result_register,</span><br><span class="line">    bool stay_in_interpreter &#x3D; false,</span><br><span class="line">    bool from_deoptimize &#x3D; false) REQUIRES_SHARED(Locks::mutator_lock_) &#123;</span><br><span class="line">  DCHECK(!shadow_frame.GetMethod()-&gt;IsAbstract());</span><br><span class="line">  DCHECK(!shadow_frame.GetMethod()-&gt;IsNative());</span><br><span class="line">  ...</span><br><span class="line">  if(ArtMethod::GetTraceMethod()!&#x3D;nullptr &amp;&amp; strlen(ArtMethod::GetTraceMethod())&gt;0)&#123;</span><br><span class="line"></span><br><span class="line">            if(strstr(method-&gt;PrettyMethod().c_str(),ArtMethod::GetTraceMethod()))&#123;</span><br><span class="line">                std::ostringstream oss;</span><br><span class="line">                oss&lt;&lt; &quot;mikrom Execute strstr:&quot;&lt;&lt;method-&gt;PrettyMethod().c_str()&lt;&lt;&quot;\t&quot;&lt;&lt;ArtMethod::GetTraceMethod();</span><br><span class="line">                LOG(ERROR) &lt;&lt;oss.str();</span><br><span class="line">                return ExecuteSwitchImpl&lt;false, false&gt;(self, accessor, shadow_frame, result_register,false);</span><br><span class="line">            &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;add end</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了这里，在LinkerCode的地方也需要修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LinkCode</span><span class="params">(ClassLinker* class_linker,</span></span></span><br><span class="line"><span class="function"><span class="params">                     ArtMethod* method,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">const</span> OatFile::OatClass* oat_class,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">uint32_t</span> class_def_method_index)</span> <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">void</span>* quick_code = method-&gt;GetEntryPointFromQuickCompiledCode();</span><br><span class="line">  <span class="keyword">bool</span> enter_interpreter = class_linker-&gt;ShouldUseInterpreterEntrypoint(method, quick_code);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">strlen</span>(ArtMethod::GetTraceMethod())&gt;<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="built_in">std</span>::<span class="built_in">ostringstream</span> oss;</span><br><span class="line">        oss&lt;&lt;<span class="string">&quot;mikrom LinkCode method:&quot;</span>&lt;&lt;method-&gt;PrettyMethod().c_str();</span><br><span class="line">        LOG(ERROR)&lt;&lt;oss.str();</span><br><span class="line">        enter_interpreter=<span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量enter_interpreter决定了是否使用解释器执行，如果是quick快速模式执行，将无法执行到我们修改的函数。最后测试发现，函数第一次调用的时候，是走的解释执行，成功打印出trace记录，第二次调用时，又被优化到快速模式执行了。不过我们已经拿到想要的结果了，我就不继续优化了。关于LinkCode这里的修改如果不理解的，可以看看下面的参考文章，里面有详细的流程图了。我就不重复了。</p><blockquote><p>参考文章：<a href="https://bbs.pediy.com/thread-260052.htm">将FART和Youpk结合来做一次针对函数抽取壳的全面提升</a></p></blockquote><h4 id="7、dex注入（未完成）"><a href="#7、dex注入（未完成）" class="headerlink" title="7、dex注入（未完成）"></a>7、dex注入（未完成）</h4><p>​        这个功能我原本是想内置一个IO重定向，或者是内置一个Sandhook，然后直接通过配置勾选就能自动注入使用了。然后我们修改的dex直接注入进去即可使用。不过目前还没想好怎么设计里面的一些交互部分。所以只是简单的做了下注入的步骤。后续也不一定有时间继续实现，先暂时搁置把。</p><h3 id="MikManager展示"><a href="#MikManager展示" class="headerlink" title="MikManager展示"></a>MikManager展示</h3><p><img src="/2022/01/27/MikRom/mikmanager.gif"></p><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><p>​        操作起来非常简单，选择想要处理的应用，然后选择对应功能即可。记得勾选完后，回到应用栏目点保存，如果是要使用frida脚本，或者是要选择so，需要把文件放在sdcard中的对应应用的目录中。如果sdcard中没有对应目录，可以打开一下应用会自动生成的。</p><p>​        脱壳功能的保存结果在<code>/sdcard/Android/data/&lt;PackageName&gt;/dump</code>中查看</p><p>​        查看logcat输出日志统一搜索mikrom，jni调用的输出的格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2022-01-30 19:43:30.198 4105-4105&#x2F;com.kanxue.crackme E&#x2F;.kanxue.crackm: mikrom jni CallNonvirtualVoidMethodV    void java.lang.ClassNotFoundException.&lt;init&gt;(java.lang.String, java.lang.Throwable)    arg1:android.widget.ViewStubarg2:0x6fcc6f50    </span><br><span class="line">2022-01-30 19:43:30.198 4105-4105&#x2F;com.kanxue.crackme E&#x2F;.kanxue.crackm: mikrom jni GetArrayLength</span><br><span class="line">2022-01-30 19:43:30.198 4105-4105&#x2F;com.kanxue.crackme E&#x2F;.kanxue.crackm: mikrom jni GetStringUTFChars    android.widget.ViewStub</span><br><span class="line">2022-01-30 19:43:30.199 4105-4105&#x2F;com.kanxue.crackme E&#x2F;.kanxue.crackm: mikrom jni CallNonvirtualVoidMethodV    void java.lang.ClassNotFoundException.&lt;init&gt;(java.lang.String, java.lang.Throwable)    arg1:android.widget.ViewStubarg2:0x12c2a5e8    </span><br><span class="line">2022-01-30 19:43:30.199 4105-4105&#x2F;com.kanxue.crackme E&#x2F;.kanxue.crackm: mikrom jni GetStringUTFChars    android.webkit.ViewStub</span><br><span class="line">2022-01-30 19:43:30.199 4105-4105&#x2F;com.kanxue.crackme E&#x2F;.kanxue.crackm: mikrom jni NewStringUTF    android.webkit.ViewStub</span><br><span class="line">2022-01-30 19:43:30.199 4105-4105&#x2F;com.kanxue.crackme E&#x2F;.kanxue.crackm: mikrom jni CallObjectMethodV    java.lang.Class java.lang.ClassLoader.loadClass(java.lang.String)    arg1:android.webkit.ViewStub</span><br><span class="line">2022-01-30 19:43:30.199 4105-4105&#x2F;com.kanxue.crackme E&#x2F;.kanxue.crackm: mikrom jni GetStringUTFChars    android.webkit.ViewStub</span><br><span class="line">2022-01-30 19:43:30.199 4105-4105&#x2F;com.kanxue.crackme E&#x2F;.kanxue.crackm: mikrom jni GetStringUTFChars    android.webkit.ViewStub</span><br><span class="line">2022-01-30 19:43:30.199 4105-4105&#x2F;com.kanxue.crackme E&#x2F;.kanxue.crackm: mikrom jni CallNonvirtualVoidMethodV    void java.lang.ClassNotFoundException.&lt;init&gt;(java.lang.String, java.lang.Throwable)    arg1:android.webkit.ViewStubarg2:0x6fcc6f50    </span><br><span class="line">2022-01-30 19:43:30.199 4105-4105&#x2F;com.kanxue.crackme E&#x2F;.kanxue.crackm: mikrom jni GetArrayLength</span><br></pre></td></tr></table></figure><p>​        RegisterNative的输出格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2022-01-30 19:48:43.219 4576-4576&#x2F;com.kanxue.crackme E&#x2F;.kanxue.crackm: mikrom RomPrint RegisterNative name:boolean com.kanxue.crackme.MainActivity.jnicheck(java.lang.String) native_ptr:0x75a5735904 method_idx:568</span><br><span class="line">2022-01-30 19:48:43.219 4576-4576&#x2F;com.kanxue.crackme E&#x2F;.kanxue.crackm: mikrom RomPrint RegisterNative name:boolean com.kanxue.crackme.MainActivity.crypt2(java.lang.String) native_ptr:0x75a5739750 method_idx:2</span><br></pre></td></tr></table></figure><p>​        ArtInvoke的输出格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2022-01-30 19:50:16.247 4686-4686&#x2F;com.kanxue.crackme E&#x2F;.kanxue.crackm: mikrom [PerformCall] caller:boolean sun.misc.Unsafe.compareAndSwapInt(java.lang.Object, long, int, int)---called:boolean sun.misc.Unsafe.compareAndSwapInt(java.lang.Object, long, int, int)</span><br><span class="line">2022-01-30 19:50:16.247 4686-4686&#x2F;com.kanxue.crackme E&#x2F;.kanxue.crackm: mikrom [PerformCall] caller:void android.graphics.Paint.nSetFlags(long, int)---called:void android.graphics.Paint.nSetFlags(long, int)</span><br><span class="line">2022-01-30 19:50:16.247 4686-4686&#x2F;com.kanxue.crackme E&#x2F;.kanxue.crackm: mikrom [PerformCall] caller:int java.lang.String.hashCode()---called:int java.lang.String.hashCode()</span><br><span class="line">2022-01-30 19:50:16.247 4686-4686&#x2F;com.kanxue.crackme E&#x2F;.kanxue.crackm: mikrom [PerformCall] caller:void android.graphics.Paint.nSetTextLocalesByMinikinLocaleListId(long, int)---called:void android.graphics.Paint.nSetTextLocalesByMinikinLocaleListId(long, int)</span><br><span class="line">2022-01-30 19:50:16.247 4686-4686&#x2F;com.kanxue.crackme E&#x2F;.kanxue.crackm: mikrom [PerformCall] caller:void android.graphics.Paint.nSetDither(long, boolean)---called:void android.graphics.Paint.nSetDither(long, boolean)</span><br><span class="line">2022-01-30 19:50:16.247 4686-4686&#x2F;com.kanxue.crackme E&#x2F;.kanxue.crackm: mikrom [PerformCall] caller:void android.graphics.Paint.nSetDither(long, boolean)---called:void android.graphics.Paint.nSetDither(long, boolean)</span><br></pre></td></tr></table></figure><p>​        smali trace日志的输出结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">2022-01-30 20:06:11.003 5157-5157&#x2F;com.mik.miktest E&#x2F;com.mik.miktes: mikrom smaliTrace 0x0: invoke-static &#123;&#125;, void com.mik.miktest.CommonTools.Test() &#x2F;&#x2F; method@7    &#x2F;&#x2F; vreg0&#x3D;0x00000000 vreg1&#x3D;0x00000000 vreg2&#x3D;0x00000000 vreg3&#x3D;0x00000000 vreg4&#x3D;0x00000000 vreg5&#x3D;0x00000001 vreg6&#x3D;0x0000000F</span><br><span class="line">2022-01-30 20:06:11.003 5157-5157&#x2F;com.mik.miktest E&#x2F;com.mik.miktes: mikrom smaliTrace 0x3: const-string v0, &quot;MainActivity&quot; &#x2F;&#x2F; string@30    &#x2F;&#x2F; vreg0&#x3D;0x00000000 vreg1&#x3D;0x00000000 vreg2&#x3D;0x00000000 vreg3&#x3D;0x00000000 vreg4&#x3D;0x00000000 vreg5&#x3D;0x00000001 vreg6&#x3D;0x0000000F</span><br><span class="line">2022-01-30 20:06:11.008 5157-5157&#x2F;com.mik.miktest E&#x2F;com.mik.miktes: mikrom smaliTrace 0x5: const-string v1, &quot;TraceTest&quot; &#x2F;&#x2F; string@33    &#x2F;&#x2F; vreg0&#x3D;0x12C89670&#x2F;java.lang.String &quot;MainActivity&quot; vreg1&#x3D;0x00000000 vreg2&#x3D;0x00000000 vreg3&#x3D;0x00000000 vreg4&#x3D;0x00000000 vreg5&#x3D;0x00000001 vreg6&#x3D;0x0000000F</span><br><span class="line">2022-01-30 20:06:11.008 5157-5157&#x2F;com.mik.miktest E&#x2F;com.mik.miktes: mikrom smaliTrace 0x7: invoke-static &#123;v0, v1&#125;, int android.util.Log.i(java.lang.String, java.lang.String) &#x2F;&#x2F; method@0    &#x2F;&#x2F; vreg0&#x3D;0x12C89670&#x2F;java.lang.String &quot;MainActivity&quot; vreg1&#x3D;0x12C896A8&#x2F;java.lang.String &quot;TraceTest&quot; vreg2&#x3D;0x00000000 vreg3&#x3D;0x00000000 vreg4&#x3D;0x00000000 vreg5&#x3D;0x00000001 vreg6&#x3D;0x0000000F</span><br><span class="line">2022-01-30 20:06:11.008 5157-5157&#x2F;com.mik.miktest E&#x2F;com.mik.miktes: mikrom smaliTrace 0xa: add-int v1, v5, v6    &#x2F;&#x2F; vreg0&#x3D;0x12C89670&#x2F;java.lang.String &quot;MainActivity&quot; vreg1&#x3D;0x12C896A8&#x2F;java.lang.String &quot;TraceTest&quot; vreg2&#x3D;0x00000000 vreg3&#x3D;0x00000000 vreg4&#x3D;0x00000000 vreg5&#x3D;0x00000001 vreg6&#x3D;0x0000000F</span><br><span class="line">2022-01-30 20:06:11.008 5157-5157&#x2F;com.mik.miktest E&#x2F;com.mik.miktes: mikrom smaliTrace 0xc: new-instance v2, java.lang.StringBuilder &#x2F;&#x2F; type@TypeIndex[16]    &#x2F;&#x2F; vreg0&#x3D;0x12C89670&#x2F;java.lang.String &quot;MainActivity&quot; vreg1&#x3D;0x00000010 vreg2&#x3D;0x00000000 vreg3&#x3D;0x00000000 vreg4&#x3D;0x00000000 vreg5&#x3D;0x00000001 vreg6&#x3D;0x0000000F</span><br><span class="line">2022-01-30 20:06:11.010 5157-5157&#x2F;com.mik.miktest E&#x2F;com.mik.miktes: mikrom smaliTrace 0xe: invoke-direct &#123;v2&#125;, void java.lang.StringBuilder.&lt;init&gt;() &#x2F;&#x2F; method@17    &#x2F;&#x2F; vreg0&#x3D;0x12C89670&#x2F;java.lang.String &quot;MainActivity&quot; vreg1&#x3D;0x00000010 vreg2&#x3D;0x12C896C8&#x2F;java.lang.StringBuilder vreg3&#x3D;0x00000000 vreg4&#x3D;0x00000000 vreg5&#x3D;0x00000001 vreg6&#x3D;0x0000000F</span><br><span class="line">2022-01-30 20:06:11.010 5157-5157&#x2F;com.mik.miktest E&#x2F;com.mik.miktes: mikrom smaliTrace 0x11: const-string v3, &quot;TraceTest,&quot; &#x2F;&#x2F; string@34    &#x2F;&#x2F; vreg0&#x3D;0x12C89670&#x2F;java.lang.String &quot;MainActivity&quot; vreg1&#x3D;0x00000010 vreg2&#x3D;0x12C896C8&#x2F;java.lang.StringBuilder vreg3&#x3D;0x00000000 vreg4&#x3D;0x00000000 vreg5&#x3D;0x00000001 vreg6&#x3D;0x0000000F</span><br><span class="line">2022-01-30 20:06:11.010 5157-5157&#x2F;com.mik.miktest E&#x2F;com.mik.miktes: mikrom smaliTrace 0x13: invoke-virtual &#123;v2, v3&#125;, java.lang.StringBuilder java.lang.StringBuilder.append(java.lang.String) &#x2F;&#x2F; method@19    &#x2F;&#x2F; vreg0&#x3D;0x12C89670&#x2F;java.lang.String &quot;MainActivity&quot; vreg1&#x3D;0x00000010 vreg2&#x3D;0x12C896C8&#x2F;java.lang.StringBuilder vreg3&#x3D;0x12C89708&#x2F;java.lang.String &quot;TraceTest,&quot; vreg4&#x3D;0x00000000 vreg5&#x3D;0x00000001 vreg6&#x3D;0x0000000F</span><br><span class="line">2022-01-30 20:06:11.010 5157-5157&#x2F;com.mik.miktest E&#x2F;com.mik.miktes: mikrom smaliTrace 0x16: move-result-object v2    &#x2F;&#x2F; vreg0&#x3D;0x12C89670&#x2F;java.lang.String &quot;MainActivity&quot; vreg1&#x3D;0x00000010 vreg2&#x3D;0x12C896C8&#x2F;java.lang.StringBuilder vreg3&#x3D;0x12C89708&#x2F;java.lang.String &quot;TraceTest,&quot; vreg4&#x3D;0x00000000 vreg5&#x3D;0x00000001 vreg6&#x3D;0x0000000F</span><br><span class="line">2022-01-30 20:06:11.010 5157-5157&#x2F;com.mik.miktest E&#x2F;com.mik.miktes: mikrom smaliTrace 0x17: invoke-virtual &#123;v2, v1&#125;, java.lang.StringBuilder java.lang.StringBuilder.append(int) &#x2F;&#x2F; method@18    &#x2F;&#x2F; vreg0&#x3D;0x12C89670&#x2F;java.lang.String &quot;MainActivity&quot; vreg1&#x3D;0x00000010 vreg2&#x3D;0x12C896C8&#x2F;java.lang.StringBuilder vreg3&#x3D;0x12C89708&#x2F;java.lang.String &quot;TraceTest,&quot; vreg4&#x3D;0x00000000 vreg5&#x3D;0x00000001 vreg6&#x3D;0x0000000F</span><br><span class="line">2022-01-30 20:06:11.010 5157-5157&#x2F;com.mik.miktest E&#x2F;com.mik.miktes: mikrom smaliTrace 0x1a: move-result-object v2    &#x2F;&#x2F; vreg0&#x3D;0x12C89670&#x2F;java.lang.String &quot;MainActivity&quot; vreg1&#x3D;0x00000010 vreg2&#x3D;0x12C896C8&#x2F;java.lang.StringBuilder vreg3&#x3D;0x12C89708&#x2F;java.lang.String &quot;TraceTest,&quot; vreg4&#x3D;0x00000000 vreg5&#x3D;0x00000001 vreg6&#x3D;0x0000000F</span><br><span class="line">2022-01-30 20:06:11.010 5157-5157&#x2F;com.mik.miktest E&#x2F;com.mik.miktes: mikrom smaliTrace 0x1b: invoke-virtual &#123;v2&#125;, java.lang.String java.lang.StringBuilder.toString() &#x2F;&#x2F; method@20    &#x2F;&#x2F; vreg0&#x3D;0x12C89670&#x2F;java.lang.String &quot;MainActivity&quot; vreg1&#x3D;0x00000010 vreg2&#x3D;0x12C896C8&#x2F;java.lang.StringBuilder vreg3&#x3D;0x12C89708&#x2F;java.lang.String &quot;TraceTest,&quot; vreg4&#x3D;0x00000000 vreg5&#x3D;0x00000001 vreg6&#x3D;0x0000000F</span><br><span class="line">2022-01-30 20:06:11.010 5157-5157&#x2F;com.mik.miktest E&#x2F;com.mik.miktes: mikrom smaliTrace 0x1e: move-result-object v2    &#x2F;&#x2F; vreg0&#x3D;0x12C89670&#x2F;java.lang.String &quot;MainActivity&quot; vreg1&#x3D;0x00000010 vreg2&#x3D;0x12C896C8&#x2F;java.lang.StringBuilder vreg3&#x3D;0x12C89708&#x2F;java.lang.String &quot;TraceTest,&quot; vreg4&#x3D;0x00000000 vreg5&#x3D;0x00000001 vreg6&#x3D;0x0000000F</span><br><span class="line">2022-01-30 20:06:11.010 5157-5157&#x2F;com.mik.miktest E&#x2F;com.mik.miktes: mikrom smaliTrace 0x1f: invoke-static &#123;v0, v2&#125;, int android.util.Log.i(java.lang.String, java.lang.String) &#x2F;&#x2F; method@0    &#x2F;&#x2F; vreg0&#x3D;0x12C89670&#x2F;java.lang.String &quot;MainActivity&quot; vreg1&#x3D;0x00000010 vreg2&#x3D;0x12C89738&#x2F;java.lang.String &quot;TraceTest,16&quot; vreg3&#x3D;0x12C89708&#x2F;java.lang.String &quot;TraceTest,&quot; vreg4&#x3D;0x00000000 vreg5&#x3D;0x00000001 vreg6&#x3D;0x0000000F</span><br><span class="line">2022-01-30 20:06:11.010 5157-5157&#x2F;com.mik.miktest E&#x2F;com.mik.miktes: mikrom smaliTrace 0x22: mul-int v2, v5, v6    &#x2F;&#x2F; vreg0&#x3D;0x12C89670&#x2F;java.lang.String &quot;MainActivity&quot; vreg1&#x3D;0x00000010 vreg2&#x3D;0x12C89738&#x2F;java.lang.String &quot;TraceTest,16&quot; vreg3&#x3D;0x12C89708&#x2F;java.lang.String &quot;TraceTest,&quot; vreg4&#x3D;0x00000000 vreg5&#x3D;0x00000001 vreg6&#x3D;0x0000000F</span><br><span class="line">2022-01-30 20:06:11.010 5157-5157&#x2F;com.mik.miktest E&#x2F;com.mik.miktes: mikrom smaliTrace 0x24: new-instance v4, java.lang.StringBuilder &#x2F;&#x2F; type@TypeIndex[16]    &#x2F;&#x2F; vreg0&#x3D;0x12C89670&#x2F;java.lang.String &quot;MainActivity&quot; vreg1&#x3D;0x00000010 vreg2&#x3D;0x0000000F vreg3&#x3D;0x12C89708&#x2F;java.lang.String &quot;TraceTest,&quot; vreg4&#x3D;0x00000000 vreg5&#x3D;0x00000001 vreg6&#x3D;0x0000000F</span><br><span class="line">2022-01-30 20:06:11.010 5157-5157&#x2F;com.mik.miktest E&#x2F;com.mik.miktes: mikrom smaliTrace 0x26: invoke-direct &#123;v4&#125;, void java.lang.StringBuilder.&lt;init&gt;() &#x2F;&#x2F; method@17    &#x2F;&#x2F; vreg0&#x3D;0x12C89670&#x2F;java.lang.String &quot;MainActivity&quot; vreg1&#x3D;0x00000010 vreg2&#x3D;0x0000000F vreg3&#x3D;0x12C89708&#x2F;java.lang.String &quot;TraceTest,&quot; vreg4&#x3D;0x12C89758&#x2F;java.lang.StringBuilder vreg5&#x3D;0x00000001 vreg6&#x3D;0x0000000F</span><br><span class="line">2022-01-30 20:06:11.010 5157-5157&#x2F;com.mik.miktest E&#x2F;com.mik.miktes: mikrom smaliTrace 0x29: invoke-virtual &#123;v4, v3&#125;, java.lang.StringBuilder java.lang.StringBuilder.append(java.lang.String) &#x2F;&#x2F; method@19    &#x2F;&#x2F; vreg0&#x3D;0x12C89670&#x2F;java.lang.String &quot;MainActivity&quot; vreg1&#x3D;0x00000010 vreg2&#x3D;0x0000000F vreg3&#x3D;0x12C89708&#x2F;java.lang.String &quot;TraceTest,&quot; vreg4&#x3D;0x12C89758&#x2F;java.lang.StringBuilder vreg5&#x3D;0x00000001 vreg6&#x3D;0x0000000F</span><br><span class="line">2022-01-30 20:06:11.010 5157-5157&#x2F;com.mik.miktest E&#x2F;com.mik.miktes: mikrom smaliTrace 0x2c: move-result-object v3    &#x2F;&#x2F; vreg0&#x3D;0x12C89670&#x2F;java.lang.String &quot;MainActivity&quot; vreg1&#x3D;0x00000010 vreg2&#x3D;0x0000000F vreg3&#x3D;0x12C89708&#x2F;java.lang.String &quot;TraceTest,&quot; vreg4&#x3D;0x12C89758&#x2F;java.lang.StringBuilder vreg5&#x3D;0x00000001 vreg6&#x3D;0x0000000F</span><br><span class="line">2022-01-30 20:06:11.010 5157-5157&#x2F;com.mik.miktest E&#x2F;com.mik.miktes: mikrom smaliTrace 0x2d: invoke-virtual &#123;v3, v2&#125;, java.lang.StringBuilder java.lang.StringBuilder.append(int) &#x2F;&#x2F; method@18    &#x2F;&#x2F; vreg0&#x3D;0x12C89670&#x2F;java.lang.String &quot;MainActivity&quot; vreg1&#x3D;0x00000010 vreg2&#x3D;0x0000000F vreg3&#x3D;0x12C89758&#x2F;java.lang.StringBuilder vreg4&#x3D;0x12C89758&#x2F;java.lang.StringBuilder vreg5&#x3D;0x00000001 vreg6&#x3D;0x0000000F</span><br><span class="line">2022-01-30 20:06:11.010 5157-5157&#x2F;com.mik.miktest E&#x2F;com.mik.miktes: mikrom smaliTrace 0x30: move-result-object v3    &#x2F;&#x2F; vreg0&#x3D;0x12C89670&#x2F;java.lang.String &quot;MainActivity&quot; vreg1&#x3D;0x00000010 vreg2&#x3D;0x0000000F vreg3&#x3D;0x12C89758&#x2F;java.lang.StringBuilder vreg4&#x3D;0x12C89758&#x2F;java.lang.StringBuilder vreg5&#x3D;0x00000001 vreg6&#x3D;0x0000000F</span><br><span class="line">2022-01-30 20:06:11.011 5157-5157&#x2F;com.mik.miktest E&#x2F;com.mik.miktes: mikrom smaliTrace 0x31: invoke-virtual &#123;v3&#125;, java.lang.String java.lang.StringBuilder.toString() &#x2F;&#x2F; method@20    &#x2F;&#x2F; vreg0&#x3D;0x12C89670&#x2F;java.lang.String &quot;MainActivity&quot; vreg1&#x3D;0x00000010 vreg2&#x3D;0x0000000F vreg3&#x3D;0x12C89758&#x2F;java.lang.StringBuilder vreg4&#x3D;0x12C89758&#x2F;java.lang.StringBuilder vreg5&#x3D;0x00000001 vreg6&#x3D;0x0000000F</span><br><span class="line">2022-01-30 20:06:11.011 5157-5157&#x2F;com.mik.miktest E&#x2F;com.mik.miktes: mikrom smaliTrace 0x34: move-result-object v3    &#x2F;&#x2F; vreg0&#x3D;0x12C89670&#x2F;java.lang.String &quot;MainActivity&quot; vreg1&#x3D;0x00000010 vreg2&#x3D;0x0000000F vreg3&#x3D;0x12C89758&#x2F;java.lang.StringBuilder vreg4&#x3D;0x12C89758&#x2F;java.lang.StringBuilder vreg5&#x3D;0x00000001 vreg6&#x3D;0x0000000F</span><br><span class="line">2022-01-30 20:06:11.011 5157-5157&#x2F;com.mik.miktest E&#x2F;com.mik.miktes: mikrom smaliTrace 0x35: invoke-static &#123;v0, v3&#125;, int android.util.Log.i(java.lang.String, java.lang.String) &#x2F;&#x2F; method@0    &#x2F;&#x2F; vreg0&#x3D;0x12C89670&#x2F;java.lang.String &quot;MainActivity&quot; vreg1&#x3D;0x00000010 vreg2&#x3D;0x0000000F vreg3&#x3D;0x12C897A8&#x2F;java.lang.String &quot;TraceTest,15&quot; vreg4&#x3D;0x12C89758&#x2F;java.lang.StringBuilder vreg5&#x3D;0x00000001 vreg6&#x3D;0x0000000F</span><br><span class="line">2022-01-30 20:06:11.011 5157-5157&#x2F;com.mik.miktest E&#x2F;com.mik.miktes: mikrom smaliTrace 0x38: add-int v0, v1, v2    &#x2F;&#x2F; vreg0&#x3D;0x12C89670&#x2F;java.lang.String &quot;MainActivity&quot; vreg1&#x3D;0x00000010 vreg2&#x3D;0x0000000F vreg3&#x3D;0x12C897A8&#x2F;java.lang.String &quot;TraceTest,15&quot; vreg4&#x3D;0x12C89758&#x2F;java.lang.StringBuilder vreg5&#x3D;0x00000001 vreg6&#x3D;0x0000000F</span><br><span class="line">2022-01-30 20:06:11.011 5157-5157&#x2F;com.mik.miktest E&#x2F;com.mik.miktes: mikrom smaliTrace 0x3a: return v0    &#x2F;&#x2F; vreg0&#x3D;0x0000001F vreg1&#x3D;0x00000010 vreg2&#x3D;0x0000000F vreg3&#x3D;0x12C897A8&#x2F;java.lang.String &quot;TraceTest,15&quot; vreg4&#x3D;0x12C89758&#x2F;java.lang.StringBuilder vreg5&#x3D;0x00000001 vreg6&#x3D;0x0000000F</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        so注入如果勾选自动注入dobby后，就会注入系统中自带的，如果你想注入自己编译的dobby，也可以在so注入里面导入dobby，注入顺序会默认按照导入顺序。</p><h3 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h3><p>​        整理一遍之后，感觉好像做了很多，又感觉好像也没搞点啥。也碰到很多问题让我一遍又一遍的编译测试。不过总算大致实现了当时的想法。后续应该不会有啥升级了。调转方向研究点其他东西了。如果以后内核功底深一些了，可能会回头扩展把。重要的事情再提一次，不知道修改到了art部分的哪个点，导致了调试超级慢，如果有大佬知道啥原因的，麻烦指导一下。</p>]]></content>
      
      
      
        <tags>
            
            <tag> rom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FartExt之优化更深主动调用的FART10</title>
      <link href="/2021/07/26/fartext/"/>
      <url>/2021/07/26/fartext/</url>
      
        <content type="html"><![CDATA[<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p><a href="https://bbs.pediy.com/thread-260052.htm">将FART和Youpk结合来做一次针对函数抽取壳的全面提升</a></p><p>看雪高研班课程</p></blockquote><p>寒冰大佬的FART带动了不少新的主动调用思想的抽取壳方案。看了上面这篇文章，感觉意犹未尽，当然是要动手实践一翻来优化一波。于是我重新翻阅FART和Youpk的源码，我准备和那位大佬一样，参考Youpk在FART的基础上进行升级改造。开工前先明确出我的需求。</p><a id="more"></a><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><blockquote><ul><li>对指定进程脱壳，非目标进程不要执行脱壳线程。</li><li>对指定类列表进行脱壳</li><li>将FART升级到aosp10实现。</li><li>去FART指纹</li><li>FART保存出的函数修复合并为dex。</li><li>实现FART更深的主动调用</li><li>更快的主动调用（暂未优化）</li></ul></blockquote><h2 id="一、什么是FART"><a href="#一、什么是FART" class="headerlink" title="一、什么是FART"></a>一、什么是FART</h2><p>还未了解过的请看原作者对于fart的介绍</p><blockquote><p><a href="https://bbs.pediy.com/thread-252630.htm">FART：ART环境下基于主动调用的自动化脱壳方案</a></p><p><a href="https://bbs.pediy.com/thread-254028.htm">FART正餐前甜点：ART下几个通用简单高效的dump内存中dex方法</a></p><p><a href="https://bbs.pediy.com/thread-254555.htm">拨云见日：安卓APP脱壳的本质以及如何快速发现ART下的脱壳点</a></p></blockquote><p>关于fart源码的调用流程可以看看我以前整理的一篇文章</p><blockquote><p><a href="https://bbs.pediy.com/thread-263401.htm">fart的理解和分析过程</a></p></blockquote><p><strong>简单总结：</strong></p><p>这是一个基于主动调用来脱抽取壳的方案。</p><p><strong>简述实现原理：</strong></p><p>在进程启动的时候通过双亲委派机制遍历所有classloader，然后遍历里面的所有class，取出所有函数，直接调用。然后在ArtMethod的Invoke函数这里根据参数判断出这是主动调用触发的，然后就取消函数的正常执行，并执行脱壳操作。</p><h2 id="二、对指定进程脱壳"><a href="#二、对指定进程脱壳" class="headerlink" title="二、对指定进程脱壳"></a>二、对指定进程脱壳</h2><p>首先看看FART源码中，脱壳线程的入口点ActivityThread.java的performLaunchActivity这个函数中开始的FART处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        fartthread();</span><br><span class="line">              ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>也就是说，所有的进程都会执行脱壳的流程。所以这个地方我觉得还是有必要优化的。应该是对指定的进程脱壳会更加好一些。Youpk中已经有了这个优化。所以我直接拿Youpk的处理来使用。下面是修改后的入口启动部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//判断这个进程是否应该脱壳</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldUnpack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> should_unpack = <span class="keyword">false</span>;</span><br><span class="line">      String processName = ActivityThread.currentProcessName();</span><br><span class="line">      BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">      String configPath=<span class="string">&quot;/data/local/tmp/fext.config&quot;</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(configPath));</span><br><span class="line">          String line;</span><br><span class="line">          <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (processName.equals(line))) &#123;</span><br><span class="line">                  should_unpack = <span class="keyword">true</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          br.close();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> should_unpack;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//启动FART脱壳线程</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fartthread</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!shouldUnpack()) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  Log.e(<span class="string">&quot;ActivityThread&quot;</span>, <span class="string">&quot;start sleep......&quot;</span>);</span><br><span class="line">                  Thread.sleep(<span class="number">1</span> * <span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">              Log.e(<span class="string">&quot;ActivityThread&quot;</span>, <span class="string">&quot;sleep over and start fart&quot;</span>);</span><br><span class="line">              fart();</span><br><span class="line">              Log.e(<span class="string">&quot;ActivityThread&quot;</span>, <span class="string">&quot;fart run over&quot;</span>);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindApplication</span><span class="params">(AppBindData data)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">      app = data.info.makeApplication(data.restrictedBackupMode, <span class="keyword">null</span>);</span><br><span class="line">        app.setAutofillOptions(data.autofillOptions);</span><br><span class="line">        app.setContentCaptureOptions(data.contentCaptureOptions);</span><br><span class="line">        mInitialApplication = app;</span><br><span class="line">        fartthread();</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>这里主要是做了两点修改：</strong></p><p>1、把启动FART线程的处理放到了handleBindApplication函数，这是因为performLaunchActivity这个函数调用有的时候可能会触发两次，而handleBindApplication确定只会触发一次。</p><p>2、FART线程启动前加了个判断，在配置文件中的进程才需要脱壳。这样基本第一个优化就完成了。</p><h2 id="三、对指定类列表进行脱壳"><a href="#三、对指定类列表进行脱壳" class="headerlink" title="三、对指定类列表进行脱壳"></a>三、对指定类列表进行脱壳</h2><p>由于应用的有些类可能是被特殊处理了，主动调用的情况会导致程序崩溃或者退出。所以最好是可以单独对某些类进行主动调用。我调整了FART线程启动的逻辑，先是上面的判断是不是要脱壳的目标进程，然后判断有没有设定类列表，如果有类列表就只脱壳类列表，否则就完整主动调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取类列表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getClassList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String processName = ActivityThread.currentProcessName();</span><br><span class="line">        BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">        String configPath=<span class="string">&quot;/data/local/tmp/&quot;</span>+processName;</span><br><span class="line">        Log.e(<span class="string">&quot;ActivityThread&quot;</span>, <span class="string">&quot;getClassList processName:&quot;</span>+processName);</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(configPath));</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(line.length()&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">                    sb.append(line+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            br.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            Log.e(<span class="string">&quot;ActivityThread&quot;</span>, <span class="string">&quot;getClassList err:&quot;</span>+ex.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//对指定类进行主动调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fartWithClassList</span><span class="params">(String classlist)</span></span>&#123;</span><br><span class="line">        ClassLoader appClassloader = getClassloader();</span><br><span class="line">        <span class="keyword">if</span>(appClassloader==<span class="keyword">null</span>)&#123;</span><br><span class="line">            Log.e(<span class="string">&quot;ActivityThread&quot;</span>, <span class="string">&quot;appClassloader is null&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Class DexFileClazz = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DexFileClazz = appClassloader.loadClass(<span class="string">&quot;dalvik.system.DexFile&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Method dumpMethodCode_method = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Method field : DexFileClazz.getDeclaredMethods()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (field.getName().equals(<span class="string">&quot;fartextMethodCode&quot;</span>)) &#123;</span><br><span class="line">                dumpMethodCode_method = field;</span><br><span class="line">                dumpMethodCode_method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] classes=classlist.split(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String clsname : classes)&#123;</span><br><span class="line">            String line=clsname;</span><br><span class="line">            <span class="keyword">if</span>(line.startsWith(<span class="string">&quot;L&quot;</span>)&amp;&amp;line.endsWith(<span class="string">&quot;;&quot;</span>)&amp;&amp;line.contains(<span class="string">&quot;/&quot;</span>))&#123;</span><br><span class="line">                line=line.substring(<span class="number">1</span>,line.length()-<span class="number">1</span>);</span><br><span class="line">                line=line.replace(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            loadClassAndInvoke(appClassloader, line, dumpMethodCode_method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fartthread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!shouldUnpack()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="comment">//获取类列表。如果有的话就不要完整主动调用了</span></span><br><span class="line">        String classlist=getClassList();</span><br><span class="line">        <span class="keyword">if</span>(!classlist.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">            fartWithClassList(classlist);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">                ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="四、FART升级AOSP10"><a href="#四、FART升级AOSP10" class="headerlink" title="四、FART升级AOSP10"></a>四、FART升级AOSP10</h2><p>直接将FART修改的代码部分直接替换到AOSP10中。毫不意外的出现了一堆错误。不过问题比较集中。主要是对于CodeItem的成员访问方式发生了变化。这里可以参考下面的文章</p><blockquote><p><a href="https://www.jianshu.com/p/18ff0b8e0b01">Android ART 虚拟机 - dex 文件格式要旨</a></p></blockquote><p>根据这篇文章中对CodeItem对象新的访问方式。对FART的源码部分做出修改</p><p>修改文件是art_method.cc。我这里只贴上部分关键修改的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">dumpArtMethod</span><span class="params">(ArtMethod* artmethod)</span>  <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">                ...</span><br><span class="line">        <span class="keyword">const</span> dex::CodeItem* code_item = artmethod-&gt;GetCodeItem();</span><br><span class="line">              <span class="keyword">const</span> DexFile* dex_=artmethod-&gt;GetDexFile();</span><br><span class="line">              <span class="function">CodeItemDataAccessor <span class="title">accessor</span><span class="params">(*dex_, dex_-&gt;GetCodeItem(artmethod-&gt;GetCodeItemOffset()))</span></span>;</span><br><span class="line">              <span class="keyword">if</span> (LIKELY(code_item != <span class="literal">nullptr</span>))</span><br><span class="line">        &#123;</span><br><span class="line">              <span class="keyword">int</span> code_item_len = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">uint8_t</span> *item=(<span class="keyword">uint8_t</span> *) code_item;</span><br><span class="line">              <span class="keyword">if</span> (accessor.TriesSize()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="keyword">const</span> <span class="keyword">uint8_t</span> *handler_data = accessor.GetCatchHandlerData();</span><br><span class="line">                  <span class="keyword">uint8_t</span> * tail = codeitem_end(&amp;handler_data);</span><br><span class="line">                  code_item_len = (<span class="keyword">int</span>)(tail - item);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  code_item_len = <span class="number">16</span>+accessor.InsnsSizeInCodeUnits()*<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                        ...</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要修改的不止上面这几个地方。但是主要都是针对CodeItem的使用以及命名空间的修改。这里我就不全部贴出了。最后我会贴出改完后的版本。</p><h2 id="五、去FART指纹"><a href="#五、去FART指纹" class="headerlink" title="五、去FART指纹"></a>五、去FART指纹</h2><p>由于FART的知名度还是挺高的，所以最好还是把FART中特有的一些函数名和文件保存路径给修改一下。下面整理下我参考Youpk做的一些修改。</p><p>1、将ActivityThread中的FART相关函数全部单独放到一个类cn.mik.Fartext中。这样如果别人对ActivityThread的函数检测就找不到FART相关的了。</p><p>2、将DexFile中的dumpMethodCode函数名修改为fartextMethodCode</p><p>3、将myfartInvoke函数名改成fartextInvoke</p><p>4、将所有使用/sdcard/fart的这个路径全部修改成/sdcard/fext</p><p>把这些常见的可能识别的方式都修改之后。一般就识别不出来了。我这种完全没知名度的，想必不会被人检测到了。暗自欣喜。</p><h2 id="六、FART的函数修复"><a href="#六、FART的函数修复" class="headerlink" title="六、FART的函数修复"></a>六、FART的函数修复</h2><p>抽取壳的应用在脱壳后，有两种文件，一个是在当前时机dump出来的dex文件。另一个是保存codeitem出来的bin文件。</p><p>FART的修复组件是使用开源项目<a href="https://github.com/hanbinglengyue/FART">FART</a>中那个py的脚本来解析dex文件，将bin的codeitem修复打印。对于里面的代码解析部分我之前也写了文章。感兴趣可以看看</p><blockquote><p><a href="https://bbs.pediy.com/thread-268465.htm">dex起步探索</a></p></blockquote><p>但是我仔细研究后，发现修复组件只进行了打印。并没有修复成dex，而是直接解析打印。最理想的还是修复到dex，方便使用静态分析工具查看。有大佬也已经写了这个工具。那就是前面参考的Youpk。他的内部有个dexfixer的目录，就是实现了对导出的codeitem数据修复到dex中。不过他的codeitem的保存结构和FART的并不大一样。不过没关系，修改一下codeitem文件的解析部分就好了。下面贴上Youpk和我修改后专门处理fart结果的dexfixer。</p><blockquote><p><a href="https://github.com/Youlor/Youpk">Youpk</a></p><p><a href="https://github.com/dqzg12300/dexfixer">dexfixer</a></p></blockquote><h2 id="七、更深的主动调用"><a href="#七、更深的主动调用" class="headerlink" title="七、更深的主动调用"></a>七、更深的主动调用</h2><h3 id="FART的主动调用深度"><a href="#FART的主动调用深度" class="headerlink" title="FART的主动调用深度"></a>FART的主动调用深度</h3><p>首先当然是看看FART的主动调用的深度是在哪里，这里的深度其实就是在函数的主动执行过程中，FART是在执行到哪个流程时，进行的脱壳处理。下面贴上FART主动调用的脱壳位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArtMethod::Invoke</span><span class="params">(Thread* self, <span class="keyword">uint32_t</span>* args, <span class="keyword">uint32_t</span> args_size, JValue* result,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> <span class="keyword">char</span>* shorty)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (self== <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        dumpArtMethod(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上面可以看到。当函数执行流程到达ArtMethod::Invoke时，就根据参数判断是主动调用的情况，就脱壳并结束了。</p><h3 id="为什么需要更深的主动调用"><a href="#为什么需要更深的主动调用" class="headerlink" title="为什么需要更深的主动调用"></a>为什么需要更深的主动调用</h3><p>一般的函数抽取壳，在执行到ArtMethod::Invoke前就已经对抽取函数还原了。但是也有一些抽取壳，执行到Invoke时依然还没有还原函数。譬如下面这种抽取壳。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">.method <span class="keyword">public</span> constructor &lt;init&gt;()V</span><br><span class="line">    .registers <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    goto :goto_c</span><br><span class="line"></span><br><span class="line">    :goto_1</span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>-<span class="keyword">void</span></span><br><span class="line"></span><br><span class="line">    :goto_c</span><br><span class="line">    <span class="keyword">const</span> v0, <span class="number">0x1669</span></span><br><span class="line"></span><br><span class="line">    invoke-<span class="keyword">static</span> &#123;v0&#125;, Ls/h/e/l/l/H;-&gt;i(I)V</span><br><span class="line"></span><br><span class="line">    goto :goto_1</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure><p>可以看到这个抽取的函数，进来之后就goto，然后执行invoke-static。接着在goto到函数的开始位置。</p><p>也就是说。这个抽取壳，必须在函数执行了之后，才会还原出真实的函数。回想一下前面说的FART的主动调用深度。发现函数真正执行前就已经被我们直接结束掉了。所以我们需要更深的主动调用才能够解决这个抽取壳。</p><h3 id="Youpk更深的主动调用"><a href="#Youpk更深的主动调用" class="headerlink" title="Youpk更深的主动调用"></a>Youpk更深的主动调用</h3><p>我们回头看看上面的抽取壳，我们的目标是要判断如果这个函数的第一个指令是goto，就正常执行，然后执行到invoke-static的指令。这个指令完成之后就直接结束掉函数调用。避免真实函数调用会出现异常。</p><p>先参考Youpk的看看他是如何实现更深的主动调用来解决这个问题的。下面是第一步，先修改默认的解释器为Switch的解释器。这是因为Switch解释器的可读性更加高，方便我们直接修改源码来达到目的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> InterpreterImplKind kInterpreterImplKind = kSwitchImplKind;</span><br></pre></td></tr></table></figure><p>然后我们看看主动调用时Youpk是怎么模拟参数的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Unpacker::invokeAllMethods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          ...</span><br><span class="line">      <span class="keyword">auto</span> methods = klass-&gt;GetDeclaredMethods(pointer_size);</span><br><span class="line">      Unpacker::enableFakeInvoke();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; m : methods) &#123;</span><br><span class="line">        ArtMethod* method = &amp;m;</span><br><span class="line">        <span class="keyword">if</span> (!method-&gt;IsProxyMethod() &amp;&amp; method-&gt;IsInvokable()) &#123;</span><br><span class="line">          <span class="comment">//获取参数个数</span></span><br><span class="line">          <span class="keyword">uint32_t</span> args_size = (<span class="keyword">uint32_t</span>)ArtMethod::NumArgRegisters(method-&gt;GetShorty());</span><br><span class="line">          <span class="keyword">if</span> (!method-&gt;IsStatic()) &#123;</span><br><span class="line">            args_size += <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//模拟参数</span></span><br><span class="line">          JValue result;</span><br><span class="line">          <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint32_t</span>&gt; <span class="title">args</span><span class="params">(args_size, <span class="number">0</span>)</span></span>;</span><br><span class="line">          <span class="keyword">if</span> (!method-&gt;IsStatic()) &#123;</span><br><span class="line">            mirror::Object* thiz = klass-&gt;AllocObject(self);</span><br><span class="line">            args[<span class="number">0</span>] = StackReference&lt;mirror::Object&gt;::FromMirrorPtr(thiz).AsVRegValue();  </span><br><span class="line">          &#125;</span><br><span class="line">          method-&gt;Invoke(self, args.data(), args_size, &amp;result, method-&gt;GetShorty());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      Unpacker::disableFakeInvoke();</span><br><span class="line">      cJSON_ReplaceItemInObject(current, <span class="string">&quot;status&quot;</span>, cJSON_CreateString(<span class="string">&quot;Dumped&quot;</span>));</span><br><span class="line">      writeJson();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到Youpk的参数是模拟赋值进去的。而寒冰大佬的做法不大一样。看看FART的函数调用模拟。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">myfartInvoke</span><span class="params">(ArtMethod* artmethod)</span>  <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">    JValue *result=<span class="literal">nullptr</span>;</span><br><span class="line">    Thread *self=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> temp=<span class="number">6</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span>* args=&amp;temp;</span><br><span class="line">    <span class="keyword">uint32_t</span> args_size=<span class="number">6</span>;</span><br><span class="line">    artmethod-&gt;Invoke(self, args, args_size, result, <span class="string">&quot;fart&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样肯定没法顺利往后执行。我们先继续参考Youpk的后续。</p><p>然后看看Youpk的ArtMethod::Invoke的处理，如果是主动调用并且非Native函数就正常执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArtMethod::Invoke</span><span class="params">(Thread* self, <span class="keyword">uint32_t</span>* args, <span class="keyword">uint32_t</span> args_size, JValue* result,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> <span class="keyword">char</span>* shorty)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//patch by Youlor</span></span><br><span class="line">  <span class="comment">//++++++++++++++++++++++++++++</span></span><br><span class="line">  <span class="comment">//如果是主动调用fake invoke并且不是native方法则强制走解释器</span></span><br><span class="line">  <span class="keyword">if</span> (UNLIKELY(!runtime-&gt;IsStarted() || Dbg::IsForcedInterpreterNeededForCalling(self, <span class="keyword">this</span>) </span><br><span class="line">      || (Unpacker::isFakeInvoke(self, <span class="keyword">this</span>) &amp;&amp; !<span class="keyword">this</span>-&gt;IsNative()))) &#123;</span><br><span class="line">  <span class="comment">//++++++++++++++++++++++++++++</span></span><br><span class="line">    <span class="keyword">if</span> (IsStatic()) &#123;</span><br><span class="line">      art::interpreter::EnterInterpreterFromInvoke(</span><br><span class="line">          self, <span class="keyword">this</span>, <span class="literal">nullptr</span>, args, result, <span class="comment">/*stay_in_interpreter*/</span> <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      mirror::Object* receiver =</span><br><span class="line">          <span class="keyword">reinterpret_cast</span>&lt;StackReference&lt;mirror::Object&gt;*&gt;(&amp;args[<span class="number">0</span>])-&gt;AsMirrorPtr();</span><br><span class="line">      art::interpreter::EnterInterpreterFromInvoke(</span><br><span class="line">          self, <span class="keyword">this</span>, receiver, args + <span class="number">1</span>, result, <span class="comment">/*stay_in_interpreter*/</span> <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//patch by Youlor</span></span><br><span class="line">    <span class="comment">//++++++++++++++++++++++++++++</span></span><br><span class="line">    <span class="comment">//如果是主动调用fake invoke并且是native方法则不执行</span></span><br><span class="line">    <span class="keyword">if</span> (Unpacker::isFakeInvoke(self, <span class="keyword">this</span>) &amp;&amp; <span class="keyword">this</span>-&gt;IsNative()) &#123;</span><br><span class="line">      <span class="comment">// Pop transition.</span></span><br><span class="line">      self-&gt;PopManagedStackFragment(fragment);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//++++++++++++++++++++++++++++</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看解释器的EnterInterpreterFromInvoke函数处理。这里Youpk没有什么处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnterInterpreterFromInvoke</span><span class="params">(Thread* self, ArtMethod* method, Object* receiver,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">uint32_t</span>* args, JValue* result,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">bool</span> stay_in_interpreter)</span> </span>&#123;</span><br><span class="line">         ...</span><br><span class="line">    JValue r = Execute(self, code_item, *shadow_frame, JValue(), stay_in_interpreter);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看看函数Execute。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> JValue <span class="title">Execute</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Thread* self,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> DexFile::CodeItem* code_item,</span></span></span><br><span class="line"><span class="function"><span class="params">    ShadowFrame&amp; shadow_frame,</span></span></span><br><span class="line"><span class="function"><span class="params">    JValue result_register,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">bool</span> stay_in_interpreter = <span class="literal">false</span>)</span> <span class="title">SHARED_REQUIRES</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (kInterpreterImplKind == kSwitchImplKind) &#123;</span><br><span class="line">      <span class="keyword">if</span> (transaction_active) &#123;</span><br><span class="line">        <span class="keyword">return</span> ExecuteSwitchImpl&lt;<span class="literal">false</span>, <span class="literal">true</span>&gt;(self, code_item, shadow_frame, result_register,</span><br><span class="line">                                              <span class="literal">false</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExecuteSwitchImpl&lt;<span class="literal">false</span>, <span class="literal">false</span>&gt;(self, code_item, shadow_frame, result_register,</span><br><span class="line">                                               <span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这ExecuteSwitchImpl就是关键的解释指令的函数了。到这里终于有Youpk修改的部分了。先看看修改的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//patch by Youlor</span></span><br><span class="line"><span class="comment">//++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREAMBLE()                                                                              \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;                                                                                          \</span><br><span class="line">    inst_count++;                                                                               \</span><br><span class="line">    <span class="keyword">bool</span> dumped = Unpacker::beforeInstructionExecute(self, shadow_frame.GetMethod(),            \</span><br><span class="line">                                                     dex_pc, inst_count);                       \</span><br><span class="line">    <span class="keyword">if</span> (dumped) &#123;                                                                               \</span><br><span class="line">      <span class="keyword">return</span> JValue();                                                                          \</span><br><span class="line">    &#125;                                                                                           \</span><br><span class="line">    <span class="keyword">if</span> (UNLIKELY(instrumentation-&gt;HasDexPcListeners())) &#123;                                       \</span><br><span class="line">      instrumentation-&gt;DexPcMovedEvent(self, shadow_frame.GetThisObject(code_item-&gt;ins_size_),  \</span><br><span class="line">                                       shadow_frame.GetMethod(), dex_pc);                       \</span><br><span class="line">    &#125;                                                                                           \</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="literal">false</span>)</span><br><span class="line"><span class="comment">//++++++++++++++++++++++++++++</span></span><br></pre></td></tr></table></figure><p>PREAMBLE这个函数基本每个指令执行前都会调用beforeInstructionExecute来判断下。如果这里dump脱壳了，就直接结束掉，这个函数不再往下执行了。如果是上面那种特殊壳，这里就可以暂时先不要dump。让他正常执行先。下面看看里面的逻辑处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继续解释执行返回false, dump完成返回true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Unpacker::beforeInstructionExecute</span><span class="params">(Thread *self, ArtMethod *method, <span class="keyword">uint32_t</span> dex_pc, <span class="keyword">int</span> inst_count)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Unpacker::isFakeInvoke(self, method)) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint16_t</span>* <span class="keyword">const</span> insns = method-&gt;GetCodeItem()-&gt;insns_;</span><br><span class="line">    <span class="keyword">const</span> Instruction* inst = Instruction::At(insns + dex_pc);</span><br><span class="line">    <span class="keyword">uint16_t</span> inst_data = inst-&gt;Fetch16(<span class="number">0</span>);</span><br><span class="line">    Instruction::Code opcode = inst-&gt;Opcode(inst_data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对于一般的方法抽取(非ijiami, najia), 直接在第一条指令处dump即可</span></span><br><span class="line">    <span class="keyword">if</span> (inst_count == <span class="number">0</span> &amp;&amp; opcode != Instruction::GOTO &amp;&amp; opcode != Instruction::GOTO_16 &amp;&amp; opcode != Instruction::GOTO_32) &#123;</span><br><span class="line">      Unpacker::dumpMethod(method);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ijiami, najia的特征为: goto: goto_decrypt; nop; ... ; return; const vx, n; invoke-static xxx; goto: goto_origin;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (inst_count == <span class="number">0</span> &amp;&amp; opcode &gt;= Instruction::GOTO &amp;&amp; opcode &lt;= Instruction::GOTO_32) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inst_count == <span class="number">1</span> &amp;&amp; opcode &gt;= Instruction::CONST_4 &amp;&amp; opcode &lt;= Instruction::CONST_WIDE_HIGH16) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inst_count == <span class="number">2</span> &amp;&amp; (opcode == Instruction::INVOKE_STATIC || opcode == Instruction::INVOKE_STATIC_RANGE)) &#123;</span><br><span class="line">      <span class="comment">//让这条指令真正的执行</span></span><br><span class="line">      Unpacker::disableFakeInvoke();</span><br><span class="line">      Unpacker::enableRealInvoke();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inst_count == <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (opcode &gt;= Instruction::GOTO &amp;&amp; opcode &lt;= Instruction::GOTO_32) &#123;</span><br><span class="line">        <span class="comment">//写入时将第一条GOTO用nop填充</span></span><br><span class="line">        <span class="keyword">const</span> Instruction* inst_first = Instruction::At(insns);</span><br><span class="line">        Instruction::Code first_opcode = inst_first-&gt;Opcode(inst-&gt;Fetch16(<span class="number">0</span>));</span><br><span class="line">        CHECK(first_opcode &gt;= Instruction::GOTO &amp;&amp; first_opcode &lt;= Instruction::GOTO_32);</span><br><span class="line">        ULOGD(<span class="string">&quot;found najia/ijiami %s&quot;</span>, PrettyMethod(method).c_str());</span><br><span class="line">        <span class="keyword">switch</span> (first_opcode)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> Instruction::GOTO:</span><br><span class="line">          Unpacker::dumpMethod(method, <span class="number">2</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Instruction::GOTO_16:</span><br><span class="line">          Unpacker::dumpMethod(method, <span class="number">4</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Instruction::GOTO_32:</span><br><span class="line">          Unpacker::dumpMethod(method, <span class="number">8</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Unpacker::dumpMethod(method);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Unpacker::dumpMethod(method);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到。如果是INVOKE_STATIC就让指令正常执行。其他正常的抽取壳的深度就是在这里。这相当于就是指令执行前进行dump了。但是这里依然没解决特殊壳的深度问题。必须执行完INVOKE_STATIC之后。再进行脱壳并结束掉函数。继续看Youpk下面的处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> do_access_check, <span class="keyword">bool</span> transaction_active&gt;</span><br><span class="line"><span class="function">JValue <span class="title">ExecuteSwitchImpl</span><span class="params">(Thread* self, <span class="keyword">const</span> DexFile::CodeItem* code_item,</span></span></span><br><span class="line"><span class="function"><span class="params">                         ShadowFrame&amp; shadow_frame, JValue result_register,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">bool</span> interpret_one_instruction)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//patch by Youlor</span></span><br><span class="line">  <span class="comment">//++++++++++++++++++++++++++++</span></span><br><span class="line">  <span class="keyword">int</span> inst_count = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">//++++++++++++++++++++++++++++</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    dex_pc = inst-&gt;GetDexPc(insns);</span><br><span class="line">    shadow_frame.SetDexPC(dex_pc);</span><br><span class="line">    TraceExecution(shadow_frame, inst, dex_pc);</span><br><span class="line">    inst_data = inst-&gt;Fetch16(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">switch</span> (inst-&gt;Opcode(inst_data)) &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">case</span> Instruction::GOTO: &#123;</span><br><span class="line">        PREAMBLE();</span><br><span class="line">        <span class="keyword">int8_t</span> offset = inst-&gt;VRegA_10t(inst_data);</span><br><span class="line">        BRANCH_INSTRUMENTATION(offset);</span><br><span class="line">        <span class="keyword">if</span> (IsBackwardBranch(offset)) &#123;</span><br><span class="line">          HOTNESS_UPDATE();</span><br><span class="line">          self-&gt;AllowThreadSuspension();</span><br><span class="line">        &#125;</span><br><span class="line">        inst = inst-&gt;RelativeAt(offset);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">case</span> Instruction::INVOKE_STATIC: &#123;</span><br><span class="line">        PREAMBLE();</span><br><span class="line">        <span class="keyword">bool</span> success = DoInvoke&lt;kStatic, <span class="literal">false</span>, do_access_check&gt;(</span><br><span class="line">            self, shadow_frame, inst, inst_data, &amp;result_register);</span><br><span class="line">        POSSIBLY_HANDLE_PENDING_EXCEPTION(!success, Next_3xx);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> Instruction::INVOKE_STATIC_RANGE: &#123;</span><br><span class="line">        PREAMBLE();</span><br><span class="line">        <span class="keyword">bool</span> success = DoInvoke&lt;kStatic, <span class="literal">true</span>, do_access_check&gt;(</span><br><span class="line">            self, shadow_frame, inst, inst_data, &amp;result_register);</span><br><span class="line">        POSSIBLY_HANDLE_PENDING_EXCEPTION(!success, Next_3xx);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//patch by Youlor</span></span><br><span class="line">    <span class="comment">//++++++++++++++++++++++++++++</span></span><br><span class="line">    <span class="keyword">bool</span> dumped = Unpacker::afterInstructionExecute(self, shadow_frame.GetMethod(), dex_pc, inst_count);</span><br><span class="line">    <span class="keyword">if</span> (dumped) &#123;</span><br><span class="line">      <span class="keyword">return</span> JValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//++++++++++++++++++++++++++++</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (!interpret_one_instruction);</span><br><span class="line">  <span class="comment">// Record where we stopped.</span></span><br><span class="line">  shadow_frame.SetDexPC(inst-&gt;GetDexPc(insns));</span><br><span class="line">  <span class="keyword">return</span> result_register;</span><br><span class="line">&#125;  <span class="comment">// NOLINT(readability/fn_size)</span></span><br></pre></td></tr></table></figure><p>这里就看到每个指令都执行了PREAMBLE函数。然后每个指令执行完都执行了afterInstructionExecute这个函数。在这里就可以判断，如果执行完的指令是INVOKE_STATIC。就可以直接return结束掉函数执行了。看看Youpk的处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Unpacker::afterInstructionExecute</span><span class="params">(Thread *self, ArtMethod *method, <span class="keyword">uint32_t</span> dex_pc, <span class="keyword">int</span> inst_count)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint16_t</span>* <span class="keyword">const</span> insns = method-&gt;GetCodeItem()-&gt;insns_;</span><br><span class="line">  <span class="keyword">const</span> Instruction* inst = Instruction::At(insns + dex_pc);</span><br><span class="line">  <span class="keyword">uint16_t</span> inst_data = inst-&gt;Fetch16(<span class="number">0</span>);</span><br><span class="line">  Instruction::Code opcode = inst-&gt;Opcode(inst_data);</span><br><span class="line">  <span class="keyword">if</span> (inst_count == <span class="number">2</span> &amp;&amp; (opcode == Instruction::INVOKE_STATIC || opcode == Instruction::INVOKE_STATIC_RANGE) </span><br><span class="line">      &amp;&amp; Unpacker::isRealInvoke(self, method)) &#123;</span><br><span class="line">    Unpacker::enableFakeInvoke();</span><br><span class="line">    Unpacker::disableRealInvoke();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里留意了一下。这个函数固定返回的false。但是通过设置enableFakeInvoke和disableRealInvoke来控制下一个指令执行的时候来进行退出函数。我感觉这里退出应该也没啥问题。</p><p>到这里基本就走完大致的流程了。那么欣赏完别人的代码。可以开始我们的改造工作了。</p><h3 id="FartExt更深的主动调用"><a href="#FartExt更深的主动调用" class="headerlink" title="FartExt更深的主动调用"></a>FartExt更深的主动调用</h3><p>和Youpk一样。第一步就是先把解释器给改成使用Switch解释器。但是由于我使用的是AOSP10。所以发现修改部分果然不大一样了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ART_USE_CXX_INTERPRETER</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> InterpreterImplKind kInterpreterImplKind = kSwitchImplKind;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> InterpreterImplKind kInterpreterImplKind = kMterpImplKind;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>发现这里变成可以通过编译参数来控制的了。搜索一下ART_USE_CXX_INTERPRETER的使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">envTrue</span><span class="params">(ctx, <span class="string">&quot;ART_USE_CXX_INTERPRETER&quot;</span>)</span> </span>&#123;</span><br><span class="line">        cflags = append(cflags, <span class="string">&quot;-DART_USE_CXX_INTERPRETER=1&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>发现这个好像可以通过cflags来配置了。所以我修改了下runtime下的Android.pb。如果不想改全局的。也可以在源码里面直接判断是主动调用就强制走switch解释器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cflags: [</span><br><span class="line">    &#x2F;&#x2F; ART is allowed to link to libicuuc directly</span><br><span class="line">    &#x2F;&#x2F; since they are in the same module</span><br><span class="line">    &quot;-DANDROID_LINK_SHARED_ICU4C&quot;,</span><br><span class="line">    &quot;-Wno-error&quot;,</span><br><span class="line">    &quot;-DART_USE_CXX_INTERPRETER&#x3D;1&quot;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>接着就是ArtMethod::Invoke的时候不要直接结束了。但是这里我们需要留意的是。第一个参数的Thread是fart用来判断是否为主动调用的。为了让后面能正常执行，我就直接把第一个参数给赋值了。而后面的调用流程也是需要判断当前执行函数是否为主动调用。Youpk是用线程和一个变量来控制判断是否为主动调用的。这里使用result=111111在后续判断是否为主动调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">fartextInvoke</span><span class="params">(ArtMethod* artmethod)</span>  <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(artmethod-&gt;IsNative()||artmethod-&gt;IsAbstract())&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    JValue result;</span><br><span class="line">  <span class="comment">//模拟参数</span></span><br><span class="line">    Thread *self=Thread::Current();</span><br><span class="line">    <span class="keyword">uint32_t</span> temp[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">uint32_t</span>* args=temp;</span><br><span class="line">    <span class="keyword">uint32_t</span> args_size = (<span class="keyword">uint32_t</span>)ArtMethod::NumArgRegisters(artmethod-&gt;GetShorty());</span><br><span class="line">    <span class="keyword">if</span> (!artmethod-&gt;IsStatic()) &#123;</span><br><span class="line">      args_size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//靠这个值，在后续来判断当前函数是否为主动调用。</span></span><br><span class="line">    result.SetI(<span class="number">111111</span>);</span><br><span class="line">    LOG(ERROR) &lt;&lt; <span class="string">&quot;fartext fartextInvoke&quot;</span>;</span><br><span class="line">    Unpacker_self_=self;</span><br><span class="line">    artmethod-&gt;Invoke(self, args, args_size, &amp;result,artmethod-&gt;GetShorty());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArtMethod::Invoke</span><span class="params">(Thread* self, <span class="keyword">uint32_t</span>* args, <span class="keyword">uint32_t</span> args_size, JValue* result,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> <span class="keyword">char</span>* shorty)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//add</span></span><br><span class="line">  <span class="keyword">if</span> (result!=<span class="literal">nullptr</span> &amp;&amp; result-&gt;GetI()==<span class="number">111111</span>)&#123;</span><br><span class="line">      LOG(ERROR) &lt;&lt; <span class="string">&quot;fartext artMethod::Invoke Method &quot;</span>&lt;&lt;<span class="keyword">this</span>-&gt;PrettyMethod().c_str();</span><br><span class="line">      <span class="keyword">if</span> (IsStatic()) &#123;</span><br><span class="line">        art::interpreter::EnterInterpreterFromInvoke(</span><br><span class="line">                        self, <span class="keyword">this</span>, <span class="literal">nullptr</span>, args, result, <span class="comment">/*stay_in_interpreter=*/</span> <span class="literal">true</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//注意这里是把非静态的也当静态的方式处理的。避免使用引用类型参数。</span></span><br><span class="line">        art::interpreter::EnterInterpreterFromInvoke(</span><br><span class="line">                  self, <span class="keyword">this</span>, <span class="literal">nullptr</span>, args + <span class="number">1</span>, result, <span class="comment">/*stay_in_interpreter=*/</span> <span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">        LOG(ERROR) &lt;&lt; <span class="string">&quot;fartext artMethod::Invoke Method Over &quot;</span>&lt;&lt;<span class="keyword">this</span>-&gt;PrettyMethod().c_str();</span><br><span class="line">      self-&gt;PopManagedStackFragment(fragment);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//add end</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个问题是上面这种模拟参数的方式，碰到引用类型的参数会报错。所以在处理参数入栈的时候，也要进行判断处理一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnterInterpreterFromInvoke</span><span class="params">(Thread* self,</span></span></span><br><span class="line"><span class="function"><span class="params">                                ArtMethod* method,</span></span></span><br><span class="line"><span class="function"><span class="params">                                ObjPtr&lt;mirror::Object&gt; receiver,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">uint32_t</span>* args,</span></span></span><br><span class="line"><span class="function"><span class="params">                                JValue* result,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">bool</span> stay_in_interpreter)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (!method-&gt;IsStatic()) &#123;</span><br><span class="line">    <span class="comment">//add  避免使用引用类型的参数</span></span><br><span class="line">    <span class="keyword">if</span>(result!=<span class="literal">nullptr</span>&amp;&amp;result-&gt;GetI()==<span class="number">111111</span>)&#123;</span><br><span class="line">        shadow_frame-&gt;SetVReg(cur_reg, args[<span class="number">0</span>]);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        CHECK(receiver != <span class="literal">nullptr</span>);</span><br><span class="line">        shadow_frame-&gt;SetVRegReference(cur_reg, receiver);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//add end</span></span><br><span class="line">    <span class="comment">//shadow_frame-&gt;SetVRegReference(cur_reg, receiver);</span></span><br><span class="line">    ++cur_reg;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">uint32_t</span> shorty_len = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* shorty = method-&gt;GetShorty(&amp;shorty_len);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> shorty_pos = <span class="number">0</span>, arg_pos = <span class="number">0</span>; cur_reg &lt; num_regs; ++shorty_pos, ++arg_pos, cur_reg++) &#123;</span><br><span class="line">    DCHECK_LT(shorty_pos + <span class="number">1</span>, shorty_len);</span><br><span class="line">    <span class="keyword">switch</span> (shorty[shorty_pos + <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>: &#123;</span><br><span class="line">        <span class="comment">//add  避免使用引用类型的参数</span></span><br><span class="line">        <span class="keyword">if</span>(result!=<span class="literal">nullptr</span>&amp;&amp;result-&gt;GetI()==<span class="number">111111</span>)&#123;</span><br><span class="line">            shadow_frame-&gt;SetVReg(cur_reg, args[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//add end</span></span><br><span class="line">        ObjPtr&lt;mirror::Object&gt; o =</span><br><span class="line">            <span class="keyword">reinterpret_cast</span>&lt;StackReference&lt;mirror::Object&gt;*&gt;(&amp;args[arg_pos])-&gt;AsMirrorPtr();</span><br><span class="line">        shadow_frame-&gt;SetVRegReference(cur_reg, o);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;J&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>: &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> wide_value = (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(args[arg_pos + <span class="number">1</span>]) &lt;&lt; <span class="number">32</span>) | args[arg_pos];</span><br><span class="line">        shadow_frame-&gt;SetVRegLong(cur_reg, wide_value);</span><br><span class="line">        cur_reg++;</span><br><span class="line">        arg_pos++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        shadow_frame-&gt;SetVReg(cur_reg, args[arg_pos]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (LIKELY(!method-&gt;IsNative())) &#123;</span><br><span class="line">    <span class="comment">//这里把我们主动调用函数的标志继续往后面传递</span></span><br><span class="line">    <span class="keyword">if</span>(result!=<span class="literal">nullptr</span>&amp;&amp;result-&gt;GetI()==<span class="number">111111</span>)&#123;</span><br><span class="line">        JValue r = Execute(self, accessor, *shadow_frame, *result, stay_in_interpreter);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          *result = r;</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        JValue r = Execute(self, accessor, *shadow_frame, JValue(), stay_in_interpreter);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          *result = r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就开始修改解释器部分的逻辑了。我们只要做到几点处理。就可以搞定这种壳了。</p><p>1、如果是主动调用并且第一个指令如果不是GOTO的。就直接脱壳并结束</p><p>2、如果是主动调用并且第一个指令是GOTO的。让他继续执行</p><p>3、如果第三个指令是INVOKE-STATIC的执行完后直接结束掉</p><p>接下来准备改代码。然后碰到一个问题。同样也是AOSP10的版本导致的。Switch解释器的逻辑发生了较大的变动。先看看变成了啥样子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> do_access_check, <span class="keyword">bool</span> transaction_active&gt;</span><br><span class="line"><span class="function">ATTRIBUTE_NO_SANITIZE_ADDRESS <span class="keyword">void</span> <span class="title">ExecuteSwitchImplCpp</span><span class="params">(SwitchImplContext* ctx)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">const</span> interpret_one_instruction = ctx-&gt;interpret_one_instruction;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    dex_pc = inst-&gt;GetDexPc(insns);</span><br><span class="line">    shadow_frame.SetDexPC(dex_pc);</span><br><span class="line">    TraceExecution(shadow_frame, inst, dex_pc);</span><br><span class="line">    inst_data = inst-&gt;Fetch16(<span class="number">0</span>);</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">bool</span> exit_loop = <span class="literal">false</span>;</span><br><span class="line">      InstructionHandler&lt;do_access_check, transaction_active&gt; handler(</span><br><span class="line">          ctx, instrumentation, self, shadow_frame, dex_pc, inst, inst_data, exit_loop);</span><br><span class="line">      <span class="comment">//PREAMBLE变成这种方式调用了</span></span><br><span class="line">      <span class="keyword">if</span> (!handler.Preamble()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (UNLIKELY(exit_loop)) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (UNLIKELY(interpret_one_instruction)) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (inst-&gt;Opcode(inst_data)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPCODE_CASE(OPCODE, OPCODE_NAME, pname, f, i, a, e, v)                                    \</span></span><br><span class="line">      <span class="keyword">case</span> OPCODE: &#123;                                                                              \</span><br><span class="line">        <span class="keyword">bool</span> exit_loop = <span class="literal">false</span>;                                                                   \</span><br><span class="line">        InstructionHandler&lt;do_access_check, transaction_active&gt; handler(                          \</span><br><span class="line">            ctx, instrumentation, self, shadow_frame, dex_pc, inst, inst_data, exit_loop);        \</span><br><span class="line">        handler.OPCODE_NAME();                                                                    \</span><br><span class="line">        <span class="comment">/* <span class="doctag">TODO:</span> Advance &#x27;inst&#x27; here, instead of explicitly in each handler */</span>                    \</span><br><span class="line">        <span class="keyword">if</span> (UNLIKELY(exit_loop)) &#123;                                                                \</span><br><span class="line">          <span class="keyword">return</span>;                                                                                 \</span><br><span class="line">        &#125;                                                                                         \</span><br><span class="line">        <span class="keyword">break</span>;                                                                                    \</span><br><span class="line">      &#125;</span><br><span class="line">DEX_INSTRUCTION_LIST(OPCODE_CASE)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> OPCODE_CASE</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (UNLIKELY(interpret_one_instruction)) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Record where we stopped.</span></span><br><span class="line">  shadow_frame.SetDexPC(inst-&gt;GetDexPc(insns));</span><br><span class="line">  ctx-&gt;result = ctx-&gt;result_register;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;  <span class="comment">// NOLINT(readability/fn_size)</span></span><br></pre></td></tr></table></figure><p>看到了这两个部分都发生了较大的变化。那个超大的case都不见了。不过也只是处理的方式发生变化。我们跟着调整下就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> do_access_check, <span class="keyword">bool</span> transaction_active&gt;</span><br><span class="line"><span class="function">ATTRIBUTE_NO_SANITIZE_ADDRESS <span class="keyword">void</span> <span class="title">ExecuteSwitchImplCpp</span><span class="params">(SwitchImplContext* ctx)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//add</span></span><br><span class="line">  <span class="keyword">int32_t</span> regvalue=ctx-&gt;result_register.GetI();</span><br><span class="line">  <span class="comment">//这里很重要。需要把我们用来作为主动调用的值给改了。不然调用另外一个函数也会当成fart的主动调用的。</span></span><br><span class="line">  ctx-&gt;result_register=JValue();</span><br><span class="line">  <span class="keyword">int</span> inst_count = <span class="number">-1</span>;            <span class="comment">//当前第几个指令</span></span><br><span class="line">  <span class="keyword">bool</span> flag=<span class="literal">false</span>;                    <span class="comment">//第一个指令是否为goto</span></span><br><span class="line">  <span class="comment">//add end</span></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">const</span> interpret_one_instruction = ctx-&gt;interpret_one_instruction;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//add</span></span><br><span class="line">    inst_count++;</span><br><span class="line">    <span class="keyword">uint8_t</span> opcode = inst-&gt;Opcode(inst_data)</span><br><span class="line">    <span class="comment">//如果是主动调用</span></span><br><span class="line">    <span class="keyword">if</span>(regvalue==<span class="number">111111</span>)&#123;</span><br><span class="line">          <span class="comment">//第一个指令是goto的处理</span></span><br><span class="line">        <span class="keyword">if</span>(inst_count == <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">if</span>(opcode == Instruction::GOTO || opcode == Instruction::GOTO_16 || opcode == Instruction::GOTO_32)&#123;</span><br><span class="line">                LOG(ERROR) &lt;&lt; <span class="string">&quot;fartext ExecuteSwitchImplCpp Switch inst_count=0 opcode==GOTO &quot;</span>&lt;&lt;shadow_frame.GetMethod()-&gt;PrettyMethod().c_str();</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                LOG(ERROR) &lt;&lt; <span class="string">&quot;fartext ExecuteSwitchImplCpp Switch inst_count=0 opcode!=GOTO &quot;</span>&lt;&lt;shadow_frame.GetMethod()-&gt;PrettyMethod().c_str();</span><br><span class="line">                dumpArtMethod(shadow_frame.GetMethod());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="comment">//第二个指令是const的处理</span></span><br><span class="line">        <span class="keyword">if</span>(inst_count == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(opcode &gt;= Instruction::CONST_4 &amp;&amp; opcode &lt;= Instruction::CONST_WIDE_HIGH16)&#123;</span><br><span class="line">                LOG(ERROR) &lt;&lt; <span class="string">&quot;fartext ExecuteSwitchImplCpp Switch inst_count=1 opcode==CONST &quot;</span>&lt;&lt;shadow_frame.GetMethod()-&gt;PrettyMethod().c_str();</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                LOG(ERROR) &lt;&lt; <span class="string">&quot;fartext ExecuteSwitchImplCpp Switch inst_count=1 opcode!=CONST &quot;</span>&lt;&lt;shadow_frame.GetMethod()-&gt;PrettyMethod().c_str();</span><br><span class="line">                dumpArtMethod(shadow_frame.GetMethod());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//add end</span></span><br><span class="line">    <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPCODE_CASE(OPCODE, OPCODE_NAME, pname, f, i, a, e, v)                                    \</span></span><br><span class="line">      <span class="keyword">case</span> OPCODE: &#123;                                                                              \</span><br><span class="line">        <span class="keyword">bool</span> exit_loop = <span class="literal">false</span>;                                                                   \</span><br><span class="line">        InstructionHandler&lt;do_access_check, transaction_active&gt; handler(                          \</span><br><span class="line">            ctx, instrumentation, self, shadow_frame, dex_pc, inst, inst_data, exit_loop);        \</span><br><span class="line">        handler.OPCODE_NAME();                                                                    \</span><br><span class="line">        <span class="comment">/* <span class="doctag">TODO:</span> Advance &#x27;inst&#x27; here, instead of explicitly in each handler */</span>                    \</span><br><span class="line">        <span class="keyword">if</span> (UNLIKELY(exit_loop)) &#123;                                                                \</span><br><span class="line">          <span class="keyword">return</span>;                                                                                 \</span><br><span class="line">        &#125;                                                                                         \</span><br><span class="line">        <span class="keyword">break</span>;                                                                                    \</span><br><span class="line">      &#125;</span><br><span class="line">DEX_INSTRUCTION_LIST(OPCODE_CASE)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> OPCODE_CASE</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//add</span></span><br><span class="line">      <span class="comment">//指令执行结束后，再判断一下是不是主动调用的</span></span><br><span class="line">    <span class="keyword">if</span>(regvalue==<span class="number">111111</span>)&#123;</span><br><span class="line">          <span class="comment">//如果这是第3个指令</span></span><br><span class="line">        <span class="keyword">if</span>(inst_count==<span class="number">2</span>&amp;&amp;flag)&#123;</span><br><span class="line">              <span class="comment">//如果是下面两种操作码，就可以脱壳并结束了。</span></span><br><span class="line">            <span class="keyword">if</span>(opcode == Instruction::INVOKE_STATIC || opcode == Instruction::INVOKE_STATIC_RANGE)&#123;</span><br><span class="line">                dumpArtMethod(shadow_frame.GetMethod());</span><br><span class="line">                  ArtMethod::disableFartextInvoke();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="comment">//如果主动调用的情况还能执行到第4个指令。那就直接脱壳并结束掉。</span></span><br><span class="line">          <span class="keyword">if</span>(inst_count&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            dumpArtMethod(shadow_frame.GetMethod());</span><br><span class="line">              ArtMethod::disableFartextInvoke();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//add end</span></span><br><span class="line">    <span class="keyword">if</span> (UNLIKELY(interpret_one_instruction)) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Record where we stopped.</span></span><br><span class="line">  shadow_frame.SetDexPC(inst-&gt;GetDexPc(insns));</span><br><span class="line">  ctx-&gt;result = ctx-&gt;result_register;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;  <span class="comment">// NOLINT(readability/fn_size)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="八、流程图"><a href="#八、流程图" class="headerlink" title="八、流程图"></a>八、流程图</h2><p><img src="/2021/07/26/fartext/image-20210803194824914.png" alt="image-20210803194824914"></p><h2 id="九、更快的主动调用-暂未优化"><a href="#九、更快的主动调用-暂未优化" class="headerlink" title="九、更快的主动调用(暂未优化)"></a>九、更快的主动调用(暂未优化)</h2><p>在测试FART的主动调用中发现，主动调用的耗时较长，根据上面的流程图。我们可以看到调用最耗时最核心的函数dumpArtMethod。就是在这里进行脱壳的。先看看FART里面做了什么</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">dumpArtMethod</span><span class="params">(ArtMethod* artmethod)</span>  <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">          <span class="comment">//存放保存的dex路径</span></span><br><span class="line">            <span class="keyword">char</span> *dexfilepath=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">1000</span>);    </span><br><span class="line">            <span class="keyword">if</span>(dexfilepath==<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                LOG(ERROR) &lt;&lt; <span class="string">&quot;ArtMethod::dumpArtMethodinvoked,methodname:&quot;</span>&lt;&lt;artmethod-&gt;PrettyMethod().c_str()&lt;&lt;<span class="string">&quot;malloc 1000 byte failed&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> fcmdline =<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">char</span> szCmdline[<span class="number">64</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">char</span> szProcName[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">int</span> procid = getpid();</span><br><span class="line">          <span class="comment">//获取进程包名</span></span><br><span class="line">            <span class="built_in">sprintf</span>(szCmdline,<span class="string">&quot;/proc/%d/cmdline&quot;</span>, procid);</span><br><span class="line">            fcmdline = <span class="built_in">open</span>(szCmdline, O_RDONLY,<span class="number">0644</span>);</span><br><span class="line">            <span class="keyword">if</span>(fcmdline &gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                result=<span class="built_in">read</span>(fcmdline, szProcName,<span class="number">256</span>);</span><br><span class="line">                <span class="keyword">if</span>(result&lt;<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    LOG(ERROR) &lt;&lt; <span class="string">&quot;ArtMethod::dumpdexfilebyArtMethod,open cmdline file file error&quot;</span>;                                    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">close</span>(fcmdline);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(szProcName[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                      <span class="keyword">const</span> DexFile* dex_file = artmethod-&gt;GetDexFile();</span><br><span class="line">                      <span class="keyword">const</span> <span class="keyword">uint8_t</span>* begin_=dex_file-&gt;Begin();  <span class="comment">// Start of data.</span></span><br><span class="line">                      <span class="keyword">size_t</span> size_=dex_file-&gt;Size();  <span class="comment">// Length of data.</span></span><br><span class="line">                      </span><br><span class="line">                      <span class="built_in">memset</span>(dexfilepath,<span class="number">0</span>,<span class="number">1000</span>);</span><br><span class="line">                      <span class="keyword">int</span> size_int_=(<span class="keyword">int</span>)size_;</span><br><span class="line">                      <span class="comment">//创建目录</span></span><br><span class="line">                      <span class="built_in">memset</span>(dexfilepath,<span class="number">0</span>,<span class="number">1000</span>);</span><br><span class="line">                      <span class="built_in">sprintf</span>(dexfilepath,<span class="string">&quot;%s&quot;</span>,<span class="string">&quot;/sdcard/fart&quot;</span>);</span><br><span class="line">                      <span class="built_in">mkdir</span>(dexfilepath,<span class="number">0777</span>);</span><br><span class="line">                        <span class="comment">//创建目录      </span></span><br><span class="line">                      <span class="built_in">memset</span>(dexfilepath,<span class="number">0</span>,<span class="number">1000</span>);</span><br><span class="line">                      <span class="built_in">sprintf</span>(dexfilepath,<span class="string">&quot;/sdcard/fart/%s&quot;</span>,szProcName);</span><br><span class="line">                      <span class="built_in">mkdir</span>(dexfilepath,<span class="number">0777</span>);</span><br><span class="line">                        <span class="comment">//文件大小_dexfile.dex            </span></span><br><span class="line">                      <span class="built_in">memset</span>(dexfilepath,<span class="number">0</span>,<span class="number">1000</span>);</span><br><span class="line">                      <span class="built_in">sprintf</span>(dexfilepath,<span class="string">&quot;/sdcard/fart/%s/%d_dexfile.dex&quot;</span>,szProcName,size_int_);</span><br><span class="line">                      <span class="keyword">int</span> dexfilefp=<span class="built_in">open</span>(dexfilepath,O_RDONLY,<span class="number">0666</span>);</span><br><span class="line">                <span class="comment">//存在则略过</span></span><br><span class="line">                      <span class="keyword">if</span>(dexfilefp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                          <span class="built_in">close</span>(dexfilefp);</span><br><span class="line">                          dexfilefp=<span class="number">0</span>;</span><br><span class="line">                          </span><br><span class="line">                          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                          <span class="comment">//dex的数据保存</span></span><br><span class="line">                                      <span class="keyword">int</span> fp=<span class="built_in">open</span>(dexfilepath,O_CREAT|O_APPEND|O_RDWR,<span class="number">0666</span>);</span><br><span class="line">                                      <span class="keyword">if</span>(fp&gt;<span class="number">0</span>)</span><br><span class="line">                                      &#123;</span><br><span class="line">                                          result=<span class="built_in">write</span>(fp,(<span class="keyword">void</span>*)begin_,size_);</span><br><span class="line">                                          <span class="keyword">if</span>(result&lt;<span class="number">0</span>)</span><br><span class="line">                                            &#123;</span><br><span class="line">                                                LOG(ERROR) &lt;&lt; <span class="string">&quot;ArtMethod::dumpdexfilebyArtMethod,open dexfilepath file error&quot;</span>;</span><br><span class="line">                                                        </span><br><span class="line">                                            &#125;</span><br><span class="line">                                          fsync(fp); </span><br><span class="line">                                          <span class="built_in">close</span>(fp);  </span><br><span class="line">                                          <span class="built_in">memset</span>(dexfilepath,<span class="number">0</span>,<span class="number">1000</span>);</span><br><span class="line">                      <span class="comment">//保存对应的classlist</span></span><br><span class="line">                                          <span class="built_in">sprintf</span>(dexfilepath,<span class="string">&quot;/sdcard/fart/%s/%d_classlist.txt&quot;</span>,szProcName,size_int_);</span><br><span class="line">                                          <span class="keyword">int</span> classlistfile=<span class="built_in">open</span>(dexfilepath,O_CREAT|O_APPEND|O_RDWR,<span class="number">0666</span>);</span><br><span class="line">                                            <span class="keyword">if</span>(classlistfile&gt;<span class="number">0</span>)</span><br><span class="line">                                            &#123;</span><br><span class="line">                                                <span class="keyword">for</span> (<span class="keyword">size_t</span> ii= <span class="number">0</span>; ii&lt; dex_file-&gt;NumClassDefs(); ++ii) </span><br><span class="line">                                                &#123;</span><br><span class="line">                                                    <span class="keyword">const</span> DexFile::ClassDef&amp; class_def = dex_file-&gt;GetClassDef(ii);</span><br><span class="line">                                                    <span class="keyword">const</span> <span class="keyword">char</span>* descriptor = dex_file-&gt;GetClassDescriptor(class_def);</span><br><span class="line">                                                    result=<span class="built_in">write</span>(classlistfile,(<span class="keyword">void</span>*)descriptor,<span class="built_in">strlen</span>(descriptor));</span><br><span class="line">                                                    <span class="keyword">if</span>(result&lt;<span class="number">0</span>)</span><br><span class="line">                                                    &#123;</span><br><span class="line">                                                        LOG(ERROR) &lt;&lt; <span class="string">&quot;ArtMethod::dumpdexfilebyArtMethod,write classlistfile file error&quot;</span>;</span><br><span class="line">                                                        </span><br><span class="line">                                                        &#125;</span><br><span class="line">                                                    <span class="keyword">const</span> <span class="keyword">char</span>* temp=<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                                                    result=<span class="built_in">write</span>(classlistfile,(<span class="keyword">void</span>*)temp,<span class="number">1</span>);</span><br><span class="line">                                                    <span class="keyword">if</span>(result&lt;<span class="number">0</span>)</span><br><span class="line">                                                    &#123;</span><br><span class="line">                                                        LOG(ERROR) &lt;&lt; <span class="string">&quot;ArtMethod::dumpdexfilebyArtMethod,write classlistfile file error&quot;</span>;</span><br><span class="line">                                                        </span><br><span class="line">                                                        &#125;</span><br><span class="line">                                                    &#125;</span><br><span class="line">                                                  fsync(classlistfile); </span><br><span class="line">                                                  <span class="built_in">close</span>(classlistfile); </span><br><span class="line">                                                </span><br><span class="line">                                                &#125;</span><br><span class="line">                                          &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                    <span class="comment">//获取codeItem</span></span><br><span class="line">                          <span class="keyword">const</span> DexFile::CodeItem* code_item = artmethod-&gt;GetCodeItem();</span><br><span class="line">                          <span class="keyword">if</span> (LIKELY(code_item != <span class="literal">nullptr</span>)) </span><br><span class="line">                          &#123;</span><br><span class="line">                                  <span class="keyword">int</span> code_item_len = <span class="number">0</span>;</span><br><span class="line">                                  <span class="keyword">uint8_t</span> *item=(<span class="keyword">uint8_t</span> *) code_item;</span><br><span class="line">                    <span class="comment">//计算codeitem的大小</span></span><br><span class="line">                                  <span class="keyword">if</span> (code_item-&gt;tries_size_&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                                      <span class="keyword">const</span> <span class="keyword">uint8_t</span> *handler_data = (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)(DexFile::GetTryItems(*code_item, code_item-&gt;tries_size_));</span><br><span class="line">                                      <span class="keyword">uint8_t</span> * tail = codeitem_end(&amp;handler_data);</span><br><span class="line">                                      code_item_len = (<span class="keyword">int</span>)(tail - item);</span><br><span class="line">                                  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                      code_item_len = <span class="number">16</span>+code_item-&gt;insns_size_in_code_units_*<span class="number">2</span>;</span><br><span class="line">                                  &#125;  </span><br><span class="line">                    <span class="comment">//下面就是获取codeitem的idx和偏移，大小之类的。然后写入数据保存了</span></span><br><span class="line">                                      <span class="built_in">memset</span>(dexfilepath,<span class="number">0</span>,<span class="number">1000</span>);</span><br><span class="line">                                      <span class="keyword">int</span> size_int=(<span class="keyword">int</span>)dex_file-&gt;Size();  </span><br><span class="line">                                      <span class="keyword">uint32_t</span> method_idx=artmethod-&gt;GetDexMethodIndexUnchecked();</span><br><span class="line">                                      <span class="built_in">sprintf</span>(dexfilepath,<span class="string">&quot;/sdcard/fart/%s/%d_ins_%d.bin&quot;</span>,szProcName,size_int,(<span class="keyword">int</span>)gettidv1());</span><br><span class="line">                                      <span class="keyword">int</span> fp2=<span class="built_in">open</span>(dexfilepath,O_CREAT|O_APPEND|O_RDWR,<span class="number">0666</span>);</span><br><span class="line">                                      <span class="keyword">if</span>(fp2&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                      <span class="comment">//跳到文件末尾写入</span></span><br><span class="line">                                          lseek(fp2,<span class="number">0</span>,SEEK_END);</span><br><span class="line">                                          <span class="built_in">memset</span>(dexfilepath,<span class="number">0</span>,<span class="number">1000</span>);</span><br><span class="line">                                          <span class="keyword">int</span> offset=(<span class="keyword">int</span>)(item - begin_);</span><br><span class="line">                                          <span class="built_in">sprintf</span>(dexfilepath,<span class="string">&quot;&#123;name:%s,method_idx:%d,offset:%d,code_item_len:%d,ins:&quot;</span>,artmethod-&gt;PrettyMethod().c_str(),method_idx,offset,code_item_len);</span><br><span class="line">                                          <span class="keyword">int</span> contentlength=<span class="number">0</span>;</span><br><span class="line">                                          <span class="keyword">while</span>(dexfilepath[contentlength]!=<span class="number">0</span>) contentlength++;</span><br><span class="line">                                          result=<span class="built_in">write</span>(fp2,(<span class="keyword">void</span>*)dexfilepath,contentlength);</span><br><span class="line">                                          <span class="keyword">if</span>(result&lt;<span class="number">0</span>)</span><br><span class="line">                                                    &#123;</span><br><span class="line">                                                        LOG(ERROR) &lt;&lt; <span class="string">&quot;ArtMethod::dumpdexfilebyArtMethod,write ins file error&quot;</span>;</span><br><span class="line">                                                        </span><br><span class="line">                                                        &#125;</span><br><span class="line">                                          <span class="keyword">long</span> outlen=<span class="number">0</span>;</span><br><span class="line">                                          <span class="keyword">char</span>* base64result=base64_encode((<span class="keyword">char</span>*)item,(<span class="keyword">long</span>)code_item_len,&amp;outlen);</span><br><span class="line">                                          result=<span class="built_in">write</span>(fp2,base64result,outlen);</span><br><span class="line">                                          <span class="keyword">if</span>(result&lt;<span class="number">0</span>)</span><br><span class="line">                                                    &#123;</span><br><span class="line">                                                        LOG(ERROR) &lt;&lt; <span class="string">&quot;ArtMethod::dumpdexfilebyArtMethod,write ins file error&quot;</span>;</span><br><span class="line">                                                        </span><br><span class="line">                                                        &#125;</span><br><span class="line">                                          result=<span class="built_in">write</span>(fp2,<span class="string">&quot;&#125;;&quot;</span>,<span class="number">2</span>);</span><br><span class="line">                                          <span class="keyword">if</span>(result&lt;<span class="number">0</span>)</span><br><span class="line">                                                    &#123;</span><br><span class="line">                                                        LOG(ERROR) &lt;&lt; <span class="string">&quot;ArtMethod::dumpdexfilebyArtMethod,write ins file error&quot;</span>;</span><br><span class="line">                                                        </span><br><span class="line">                                                        &#125;</span><br><span class="line">                                          fsync(fp2); </span><br><span class="line">                                          <span class="built_in">close</span>(fp2);</span><br><span class="line">                                          <span class="keyword">if</span>(base64result!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                                              <span class="built_in">free</span>(base64result);</span><br><span class="line">                                              base64result=<span class="literal">nullptr</span>;</span><br><span class="line">                                              &#125;</span><br><span class="line">                                           &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dexfilepath!=<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">free</span>(dexfilepath);</span><br><span class="line">                dexfilepath=<span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到dump的规则是相同大小的dex就跳过。非相同的就写入文件保存。相当于算是一个整体脱壳非常晚的时机。不过这个时机的调用频率较多。相对会影响性能，好处是这个整体脱壳点的时机够晚，绝对能脱掉除抽取函数外的整体壳。而Youpk中的优化是不使用这个整体脱壳点，只单纯的把codeitem写入bin文件，这样就能提高一定的效率。这里我就暂时不修改了。毕竟在这里脱整体壳也有一定的优势。如果想要更快的速度。也可以选择过滤主动调用的范围，来降低调用频率。</p><h2 id="十、实战测试"><a href="#十、实战测试" class="headerlink" title="十、实战测试"></a>十、实战测试</h2><p>编译完成之后，我们就可以来试试深度主动调用+dex修复的效果。为了防止风险，就不放测试的apk样本了。</p><p>安装好apk后，先去/data/local/tmp/fext.config中填入我们的目标进程。如果主动调用出现崩溃的情况。可以将class.txt的文件复制到<code>/data/local/tmp/进程名称</code> 来对指定的类进行主动调用。然后打开应用静静的等待脱壳结果。</p><p>或者是使用整合怪来对指定类进行处理</p><p><img src="/2021/07/26/fartext/image-20210805101250258.png" alt="image-20210805101250258"></p><blockquote><p>Ps1:如果第二次打开应用发现没有触发主动调用，请清理应用：<code>adb shell pm clear packageName</code></p><p>Ps2:如果不想等待60秒，想自己触发fart的主动调用。可以使用frida扩展</p><p>Ps3:如果想看logcat日志。搜索fartext即可，日志统一都添加了这个头部。方便查日志。</p></blockquote><p>修复前的数据</p><p><img src="/2021/07/26/fartext/image-20210805094452509.png" alt="image-20210805094452509"></p><p>使用前面我修改的修复工具，用下面的命令来修复</p><p><code>java -jar dexfixer.jar dexpath binpath outpath</code></p><p>或者是使用我整合怪的工具来修复</p><p><img src="/2021/07/26/fartext/image-20210805100310939.png" alt="image-20210805100310939"></p><p>修复后的函数结果如下</p><p><img src="/2021/07/26/fartext/image-20210805104155838.png" alt="image-20210805104155838"></p><h2 id="十一、联合frida扩展"><a href="#十一、联合frida扩展" class="headerlink" title="十一、联合frida扩展"></a>十一、联合frida扩展</h2><p>可以结合frida来直接调用FART中准备的函数来对单个类或者类列表进行脱壳。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">romClassesInvoke</span>(<span class="params">classes</span>)</span>&#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        klog(<span class="string">&quot;romClassesInvoke start load&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> fartExt=Java.use(<span class="string">&quot;cn.mik.Fartext&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!fartExt.fartWithClassList)&#123;</span><br><span class="line">            klog(<span class="string">&quot;fartExt中未找到fartWithClassList函数，可能是未使用Fartext的rom&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        fartExt.fartWithClassList(classes);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">romFartAllClassLoader</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">var</span> fartExt=Java.use(<span class="string">&quot;cn.mik.Fartext&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span>(!fartExt.fartWithClassLoader)&#123;</span><br><span class="line">           klog(<span class="string">&quot;fartExt中未找到fartWithClassLoader函数，可能是未使用Fartext的rom&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       Java.enumerateClassLoadersSync().forEach(<span class="function"><span class="keyword">function</span>(<span class="params">loader</span>)</span>&#123;</span><br><span class="line">           klog(<span class="string">&quot;romFartAllClassLoader to loader:&quot;</span>+loader);</span><br><span class="line">           <span class="keyword">if</span>(loader.toString().indexOf(<span class="string">&quot;BootClassLoader&quot;</span>)==<span class="number">-1</span>)&#123;</span><br><span class="line">               klog(<span class="string">&quot;fart start loader:&quot;</span>+loader);</span><br><span class="line">               fartExt.fartWithClassLoader(loader);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时我的整合怪里面也添加了对我这个rom的主动调用和类列表主动调用支持</p><p><img src="/2021/07/26/fartext/image-20210805100343385.png" alt="image-20210805100343385"></p><h2 id="十二、思考"><a href="#十二、思考" class="headerlink" title="十二、思考"></a>十二、思考</h2><p>整个流程梳理完成后，我们可以由此来借鉴来思考延伸一下。</p><p>比如，包装一些属于自己的系统层api调用。便于我们使用xposed或者是frida来调用一些功能。</p><p>再比如，加载应用时，读取配置文件作为开关，我们来对网络流量进行拦截写入保存，或者对所有的jni函数调用，或者是java函数调用进行trace。这种就属于是rom级别的打桩。</p><p>再比如，可以做一个应用来读写作为开关的配置文件，而rom读取配置文件后，对一些流程进行调整。例如控制FART是否使用更深调用。控制是否开启rom级别的打桩。</p><p>以上纯属个人瞎想。刚刚入门，想的有点多，以后了解更深了，我再看看如何定制一个专属的rom逆向集合</p><h2 id="十三、补充"><a href="#十三、补充" class="headerlink" title="十三、补充"></a>十三、补充</h2><p>整理一下前面所有的资料。</p><h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><blockquote><p><a href="https://bbs.pediy.com/thread-252630.htm">FART：ART环境下基于主动调用的自动化脱壳方案</a></p><p><a href="https://bbs.pediy.com/thread-254028.htm">FART正餐前甜点：ART下几个通用简单高效的dump内存中dex方法</a></p><p><a href="https://bbs.pediy.com/thread-254555.htm">拨云见日：安卓APP脱壳的本质以及如何快速发现ART下的脱壳点</a></p><p><a href="https://bbs.pediy.com/thread-260052.htm">将FART和Youpk结合来做一次针对函数抽取壳的全面提升</a></p><p><a href="https://bbs.pediy.com/thread-263401.htm">fart的理解和分析过程</a></p><p><a href="https://www.jianshu.com/p/18ff0b8e0b01">Android ART 虚拟机 - dex 文件格式要旨</a></p><p><a href="https://bbs.pediy.com/thread-268465.htm">dex起步探索</a></p></blockquote><h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><blockquote><p><a href="https://github.com/hanbinglengyue/FART">FART</a></p><p><a href="https://github.com/Youlor/Youpk">Youpk</a></p><p><a href="https://github.com/dqzg12300/dexfixer">dexfixer</a></p><p><a href="https://github.com/dqzg12300/fridaUiTools">fridaUiTools</a></p></blockquote><p>因特殊原因，暂时取消开源。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 脱壳 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载器</title>
      <link href="/2021/07/15/classloader/"/>
      <url>/2021/07/15/classloader/</url>
      
        <content type="html"><![CDATA[<p>双亲委派</p><p>就是加载类的时候，先交给自己的父类来加载，然后父类看自己是否也有父类，有的话，也转交给父类，一直到最顶端的类，如果最顶端的类加载失败，再一层层的由子类来加载，直到加载成功。</p><a id="more"></a><p>classloader的继承关系</p><p><img src="/2021/07/15/classloader/image-20210715212931668.png" alt="image-20210715212931668"></p><p>InMemoryDexClassLoader：从内存中加载dex。android7.0以后才有的</p><p>PathClassLoader：一般没加壳的app会用这个来加载类</p><p>DexClassLoader：一般加壳保护的app会用这个或者自定义ClassLoader来加载类</p><p>BaseDexClassLoader可以获取所有DexFile，详细获取途径：<code>DexPathList pathList -&gt; Element[] dexElements -&gt; DexFile dexFile;</code></p><p>DexFile可以通过getClassNameList获取到所有的类名。</p><p>使用这个方式遍历出来的所有类名比frida的遍历类名的结果更加完整。因为frida是遍历出加载了的数据。这里把没有加载的dexfile的所有类名也都打印了。</p><p>但是这里只是获取BaseDexClassLoader的所有DexFile。frida把BootClassLoader下加载的类也都打印了。</p><p>动态加载</p><p>loadClass、findClass、forName 都会触发动态加载dex。</p><p>第一节课主要是一段android层的反射调用打印MainActivity所在的ClassLoader的所有父级。和一段打印BaseDexClassLoader下的所有DexFile的类名。</p><p>第二节课是frida的反射实现第一课的打印所有classloader下的DexFile的所有类名，第二个例子是使用DexClassLoader动态加载一个dex，并且调用dex里面的指定类的方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 脱壳基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dex起步探索</title>
      <link href="/2021/07/08/android4/"/>
      <url>/2021/07/08/android4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>部分内容摘自：android软件安全权威指南：丰生强</p><p>从根源上搞懂基础的原理是很有必要的，这样有助于我们更方便的利用它的特性，达到我们的目的。</p><p>我把内容主要分为二个部分。原理探索、案例分析</p></blockquote><h1 id="原理探索"><a href="#原理探索" class="headerlink" title="原理探索"></a>原理探索</h1><h2 id="dex文件"><a href="#dex文件" class="headerlink" title="dex文件"></a>dex文件</h2><p>我们在正向开发app编译时，编写的java代码，会编译成java字节码保存在.class后缀的文件中。然后再用dx工具将java字节码转换成dex文件（Dalvik字节码）。在转换的过程中，会将所有java字节码中的所有冗余信息组成一个常量池。例如多个class文件中都存在的字符串”hello world”。转换后将单独存放在一个地方，并且所有类共享。包括方法的签名也会组成常量池。我们将编译好的apk文件解压后就能拿到classes.dex文件。</p><a id="more"></a><h2 id="dex文件格式"><a href="#dex文件格式" class="headerlink" title="dex文件格式"></a>dex文件格式</h2><h3 id="1、DexFile结构"><a href="#1、DexFile结构" class="headerlink" title="1、DexFile结构"></a>1、DexFile结构</h3><p>上面拿到的classes.dex文件包含了apk的可执行代码。Dalvik虚拟机会解析加载文件并执行代码。只要我们了解这个文件格式的组成，那么就可以自己解析这个文件获取到想要的数据。</p><p>首先是安卓源码中的<code>dalvik/libdex/DexFile.h</code>这里可以找到dex文件的数据结构。下面贴上源码部分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexFile</span> &#123;</span></span><br><span class="line">    <span class="comment">/* odex的头 */</span></span><br><span class="line">    <span class="keyword">const</span> DexOptHeader* pOptHeader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* dex文件头，指定了dex文件的一些数据，记录了其他数据结构在dex文件中的物理偏移 */</span></span><br><span class="line">    <span class="keyword">const</span> DexHeader*    pHeader;</span><br><span class="line">      <span class="comment">/* 索引结构区 */</span></span><br><span class="line">    <span class="keyword">const</span> DexStringId*  pStringIds;</span><br><span class="line">    <span class="keyword">const</span> DexTypeId*    pTypeIds;</span><br><span class="line">    <span class="keyword">const</span> DexFieldId*   pFieldIds;</span><br><span class="line">    <span class="keyword">const</span> DexMethodId*  pMethodIds;</span><br><span class="line">    <span class="keyword">const</span> DexProtoId*   pProtoIds;</span><br><span class="line">      <span class="comment">/* 真实的数据存放 */</span></span><br><span class="line">    <span class="keyword">const</span> DexClassDef*  pClassDefs;</span><br><span class="line">      <span class="comment">/* 静态链接数据区 */</span></span><br><span class="line">    <span class="keyword">const</span> DexLink*      pLinkData;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * These are mapped out of the &quot;auxillary&quot; section, and may not be</span></span><br><span class="line"><span class="comment">     * included in the file.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> DexClassLookup* pClassLookup;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span>*         pRegisterMapPool;       <span class="comment">// RegisterMapClassPool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* points to start of DEX file data */</span></span><br><span class="line">    <span class="keyword">const</span> u1*           baseAddr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* track memory overhead for auxillary structures */</span></span><br><span class="line">    <span class="keyword">int</span>                 overhead;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* additional app-specific data structures associated with the DEX */</span></span><br><span class="line">    <span class="comment">//void*               auxData;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了更好的理解。dex文件格式，我们可以用010编辑器打开一个dex文件对照这个结构体来观察一下。</p><p><img src="/2021/07/08/android4/image-20210709222613035.png" alt="image-20210709222613035"></p><p>可以看到，这个dex文件由这8个部分组成。</p><p>dex_header：dex文件头，指定了dex文件的一些数据，记录了其他数据结构在dex文件中的物理偏移</p><p>string_ids：字符串列表（前面说的去掉冗余信息组成的常量池，全局共享使用的）</p><p>type_ids：类型签名列表（去掉冗余信息组成的常量池）</p><p>proto_ids：方法声明列表（去掉冗余信息组成的常量池）</p><p>field_ids：字段列表（去掉冗余信息组成的常量池）</p><p>method_ids：方法列表（去掉冗余信息组成的常量池）</p><p>class_def：类型结构体列表（去掉冗余信息组成的常量池）</p><p>map_list：这里记录了前面7个部分的偏移和大小。</p><p>然后我们开始逐个的看各个部分的结构。</p><h3 id="2、dex-header"><a href="#2、dex-header" class="headerlink" title="2、dex_header"></a>2、dex_header</h3><p>先是贴上源码看看这个部分的结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexHeader</span> &#123;</span></span><br><span class="line">    u1  magic[<span class="number">8</span>];           <span class="comment">/* 表示是一个有效的dex文件。值一般固定为64 65 78 0A 30 33 35 00（dex.035） */</span></span><br><span class="line">    u4  checksum;           <span class="comment">/* adler32 checksum dex文件的校验和，用来判断文件是否已经损坏或者篡改 */</span></span><br><span class="line">    u1  signature[kSHA1DigestLen]; <span class="comment">/* SHA-1 hash 用来识别未经dexopt优化的dex文件*/</span></span><br><span class="line">    u4  fileSize;           <span class="comment">/* length of entire file 记录了包括dexHeader在内的整个dex文件的大小*/</span></span><br><span class="line">    u4  headerSize;         <span class="comment">/* offset to start of next section  dexHeader占用的字节数，一般都是0x70*/</span></span><br><span class="line">    u4  endianTag;                    <span class="comment">/* 指定dex运行环境的cpu字节序。预设是ENDIAN_CONSTANT等于0x12345678，也就是默认小端字节序 */</span></span><br><span class="line">    u4  linkSize;                        <span class="comment">/* 链接段的大小 */</span></span><br><span class="line">    u4  linkOff;                        <span class="comment">/* 链接段的偏移 */</span></span><br><span class="line">    u4  mapOff;                            <span class="comment">/* DexMapList结构的文件偏移 */</span></span><br><span class="line">    u4  stringIdsSize;            <span class="comment">/* 下面都是数据段的大小和文件偏移 */</span></span><br><span class="line">    u4  stringIdsOff;</span><br><span class="line">    u4  typeIdsSize;</span><br><span class="line">    u4  typeIdsOff;</span><br><span class="line">    u4  protoIdsSize;</span><br><span class="line">    u4  protoIdsOff;</span><br><span class="line">    u4  fieldIdsSize;</span><br><span class="line">    u4  fieldIdsOff;</span><br><span class="line">    u4  methodIdsSize;</span><br><span class="line">    u4  methodIdsOff;</span><br><span class="line">    u4  classDefsSize;</span><br><span class="line">    u4  classDefsOff;</span><br><span class="line">    u4  dataSize;</span><br><span class="line">    u4  dataOff;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里可以看到，如果在DexHeader中，可以找到其他部分的偏移和大小，以及整个文件的大小，解析出这块数据，其他部分的任意数据，我们都可以获取到。然后再使用对应的结构体来解析。另外留意这里DexHeader的结构体的大小是固定0x70字节的。所以有的脱壳工具中会将<code>70 00 00 00</code>来作为特征在内存中查找dex进行脱壳（比如FRIDA-DEXDump的深度检索）</p><p>然后我们贴一下真实classes.dex文件的DexHeader数据是什么样的。</p><p><img src="/2021/07/08/android4/image-20210709230216293.png" alt="image-20210709230216293"></p><h3 id="3、string-ids"><a href="#3、string-ids" class="headerlink" title="3、string_ids"></a>3、string_ids</h3><p>先看看字符串列表的结构体，非常简单，就是字符串的偏移，但是并不是普通的ascii字符串，而是MUTF-8编码的。这个是一个经过修改的UTF-8编码。和传统的UTF-8相似</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexStringId</span> &#123;</span></span><br><span class="line">    u4 stringDataOff;      <span class="comment">/* 字符串数据偏移 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2021/07/08/android4/image-20210709230959417.png" alt="image-20210709230959417"></p><h3 id="4、type-ids"><a href="#4、type-ids" class="headerlink" title="4、type_ids"></a>4、type_ids</h3><p>类型签名列表的结构体也是非常简单，和上面字符串列表差不多</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexTypeId</span> &#123;</span></span><br><span class="line">    u4  descriptorIdx;      <span class="comment">/* index into stringIds list for type descriptor */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>真实数据图如下，可以看到值类型签名都在前面，后面都是引用类型签名。</p><p><img src="/2021/07/08/android4/image-20210709231537899.png" alt="image-20210709231537899"></p><h3 id="5、proto-ids"><a href="#5、proto-ids" class="headerlink" title="5、proto_ids"></a>5、proto_ids</h3><p>方法声明的列表的结构体较为复杂，因为方法签名必然是有几点信息构成：返回值类型、参数类型列表（就是每个参数是什么类型）。方法声明的结构体如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexTypeList</span> &#123;</span></span><br><span class="line">    u4  <span class="built_in">size</span>;               <span class="comment">/* dexTypeItem的个数 */</span></span><br><span class="line">    DexTypeItem <span class="built_in">list</span>[<span class="number">1</span>];    <span class="comment">/* entries */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexTypeItem</span> &#123;</span></span><br><span class="line">    u2  typeIdx;            <span class="comment">/* DexTypeId的索引 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexProtoId</span> &#123;</span></span><br><span class="line">    u4  shortyIdx;          <span class="comment">/* DexStringId列表的索引，方法签名字符串，由返回值和参数类型列表组合*/</span></span><br><span class="line">    u4  returnTypeIdx;      <span class="comment">/* DexTypeId的索引，返回值的类型 */</span></span><br><span class="line">    u4  parametersOff;      <span class="comment">/* 指向DexTypeList的偏移，参数类型列表 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同样看看这个结构的真实数据</p><p><img src="/2021/07/08/android4/image-20210709233715171.png" alt="image-20210709233715171"></p><h3 id="6、field-ids"><a href="#6、field-ids" class="headerlink" title="6、field_ids"></a>6、field_ids</h3><p>字段描述的结构体，我们可以先想象一下，要找一个字段，我们需要些什么：字段所属的类，字段的类型，字段名称。有这些信息，就可以找到各自对应的字段了。接下来看看定义的结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexFieldId</span> &#123;</span></span><br><span class="line">    u2  classIdx;           <span class="comment">/* 类的类型，指向DexTypeId的索引，字段所属的类 */</span></span><br><span class="line">    u2  typeIdx;            <span class="comment">/* 字段类型，指向DexTypeId的索引，字段的类型 */</span></span><br><span class="line">    u4  nameIdx;            <span class="comment">/* 字段名，指向DexStringId的索引，字段的名称 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后看一段真实数据</p><p><img src="/2021/07/08/android4/image-20210712203611954.png" alt="image-20210712203611954"></p><h3 id="7、method-ids"><a href="#7、method-ids" class="headerlink" title="7、method_ids"></a>7、method_ids</h3><p>方法描述的结构体，同样先了解找一个方法的几个必须项：方法所属的类，方法的签名（签名中有方法的返回值和方法的参数，也就是上面的proto_ids中记录的），方法的名称。然后下面看结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexMethodId</span> &#123;</span></span><br><span class="line">    u2  classIdx;           <span class="comment">/* 类的类型，指向DexTypeId的索引，方法所属的类 */</span></span><br><span class="line">    u2  protoIdx;           <span class="comment">/* 声明类型，指向DexProtoId的索引，方法的签名 */</span></span><br><span class="line">    u4  nameIdx;            <span class="comment">/* 方法名，指向DexStringId索引，方法的名称 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看看一组方法的真实数据</p><p><img src="/2021/07/08/android4/image-20210712204141588.png" alt="image-20210712204141588"></p><h3 id="8、class-def"><a href="#8、class-def" class="headerlink" title="8、class_def"></a>8、class_def</h3><p>类定义的结构体，这个比较复杂。直接贴上结构体和原文的说明。这里大致可以看出来，和上面的原理差不多，通过这个结构体来描述类的内容。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexClassDef</span> &#123;</span></span><br><span class="line">    u4  classIdx;           <span class="comment">/* 类的类型，指向DexTypeId的索引 */</span></span><br><span class="line">    u4  accessFlags;                <span class="comment">/* 访问标志 */</span></span><br><span class="line">    u4  superclassIdx;      <span class="comment">/* 父类的类型，指向DexTypeId的索引 */</span></span><br><span class="line">    u4  interfacesOff;      <span class="comment">/* 接口，指向DexTypeList的偏移，如果没有接口的声明和实现，值为0 */</span></span><br><span class="line">    u4  sourceFileIdx;      <span class="comment">/* 类所在的源文件名，指向DexStringId的索引 */</span></span><br><span class="line">    u4  annotationsOff;     <span class="comment">/* 注释，根据类型不同会有注解类，注解字段，注解方法，注解参数，没有注解值就是0，指向DexAnnotationsDirectoryItem的结构体 */</span></span><br><span class="line">    u4  classDataOff;       <span class="comment">/* 类的数据部分，指向DexClassData结构的偏移 */</span></span><br><span class="line">    u4  staticValuesOff;    <span class="comment">/* 类中的静态数据，指向DexEncodeArray结构的偏移 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面同样展示一组真实数据</p><p><img src="/2021/07/08/android4/image-20210712204920689.png" alt="image-20210712204920689"></p><p>上面数据看到里面的class_data也是一个结构体，然后继续看这个类数据的结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* expanded form of a class_data_item header */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexClassDataHeader</span> &#123;</span></span><br><span class="line">    u4 staticFieldsSize;                <span class="comment">/* 静态字段的个数 */</span></span><br><span class="line">    u4 instanceFieldsSize;            <span class="comment">/* 实例字段的个数 */</span></span><br><span class="line">    u4 directMethodsSize;                <span class="comment">/* 直接方法的个数 */</span></span><br><span class="line">    u4 virtualMethodsSize;            <span class="comment">/* 虚方法的个数 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* expanded form of encoded_field */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexField</span> &#123;</span></span><br><span class="line">    u4 fieldIdx;    <span class="comment">/* 指向DexFieldId的索引 */</span></span><br><span class="line">    u4 accessFlags;    <span class="comment">/* 访问标志 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* expanded form of encoded_method */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexMethod</span> &#123;</span></span><br><span class="line">    u4 methodIdx;    <span class="comment">/* 指向DexMethodId的索引 */</span></span><br><span class="line">    u4 accessFlags;     <span class="comment">/* 访问标志 */</span></span><br><span class="line">    u4 codeOff;      <span class="comment">/* 指向DexCode结构的偏移 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexClassData</span> &#123;</span></span><br><span class="line">    DexClassDataHeader header;                            <span class="comment">/* 指定字段和方法的个数 */</span></span><br><span class="line">    DexField*          staticFields;                <span class="comment">/* 静态字段 */</span></span><br><span class="line">    DexField*          instanceFields;            <span class="comment">/* 实例字段 */</span></span><br><span class="line">    DexMethod*         directMethods;                <span class="comment">/* 直接方法 */</span></span><br><span class="line">    DexMethod*         virtualMethods;            <span class="comment">/* 虚方法 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>到这里我们基本看到了在开发中，一个类的所有特征。完整的描述出了一个类的所有信息。</p><p>9、DexCode上面最后看到方法的代码是通过上面的DexCode结构体来找到的。最后看下这个结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexCode</span> &#123;</span></span><br><span class="line">    u2  registersSize;            <span class="comment">/* 使用寄存器的个数 */</span></span><br><span class="line">    u2  insSize;                        <span class="comment">/* 参数的个数 */</span></span><br><span class="line">    u2  outsSize;                        <span class="comment">/* 调用其他方法时使用的寄存器个数 */</span></span><br><span class="line">    u2  triesSize;                    <span class="comment">/* try/catch语句的个数 */</span></span><br><span class="line">    u4  debugInfoOff;       <span class="comment">/* 指向调试信息的偏移 */</span></span><br><span class="line">    u4  insnsSize;          <span class="comment">/* 指令集的个数，以2字节为单位 */</span></span><br><span class="line">    u2  insns[<span class="number">1</span>];                        <span class="comment">/* 指令集 */</span></span><br><span class="line">    <span class="comment">/* 2字节空间用于对齐 */</span></span><br><span class="line">    <span class="comment">/* followed by try_item[triesSize] DexTry结构体 */</span></span><br><span class="line">    <span class="comment">/* followed by uleb128 handlersSize */</span></span><br><span class="line">    <span class="comment">/* followed by catch_handler_item[handlersSize] DexCatchHandler结构体 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>到了这里，存储的就是执行的指令集了。通过执行指令来跑这个方法。下面看一组真实数据</p><p><img src="/2021/07/08/android4/image-20210712212204361.png" alt="image-20210712212204361"></p><p>这里看到这个类的具体描述字段和函数，还有访问标志等等信息。然后我们继续看里面函数的执行代码部分。看下面一组数据</p><p>观察的函数是MainActivity类的DoTcp函数。DexCode（也就是code_item，也叫codeOff）的偏移地址是0x127ec。</p><p>下面观察到DexCode结构体的偏移到指令集insns字段的偏移是codeOff+2+2+2+2+4+4=0x127fc（这里+的2和4是看下面结构体insns前面的字段占了多少个字节计算的，可以当做固定+16个字节）。指令集的长度是0x93。</p><p><img src="/2021/07/08/android4/image-20210712213004176.png" alt="image-20210712213004176"></p><p>最后看看指令集的开始数据是0x62、0xe26、0x11a、0x232。但是我们要注意前面有说明，这里是两字节空间对齐。所以，这里的值我们应该前面填充一下。</p><p>前面四个字节我们要看做0x0062、0x0e26、0x011a、0x0232。但是我们还要注意，还有个端序问题会影响字节的顺序，这里是小端序，所以我们再调整下</p><p>前面四个字节我们要看做0x6200、0x260e、0x1a01、0x3202。把这段指令集的数据看明白后，我们用gda打开这个dex文件。然后找到对应的方法，查看一下。</p><p>然后发现数据对上了。这里存储的果然就是我们dex分析方法的字节码了。</p><p><img src="/2021/07/08/android4/image-20210712214604522.png" alt="image-20210712214604522"></p><h3 id="9、map-list"><a href="#9、map-list" class="headerlink" title="9、map_list"></a>9、map_list</h3><p>在书中的意思是，Dalvik虚拟机解析Dex后，将其映射成DexMapList的数据结构，然后在里面可以找到前面8个部分的偏移和大小。先看看结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexMapItem</span> &#123;</span></span><br><span class="line">    u2 type;              <span class="comment">/* kDexType开头的类型 */</span></span><br><span class="line">    u2 unused;                        <span class="comment">/* 未使用，用于字节对齐 */</span></span><br><span class="line">    u4 <span class="built_in">size</span>;              <span class="comment">/* 数据的大小 */</span></span><br><span class="line">    u4 offset;            <span class="comment">/* 指定类型数据的文件偏移 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Direct-mapped &quot;map_list&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexMapList</span> &#123;</span></span><br><span class="line">    u4  <span class="built_in">size</span>;               <span class="comment">/* 有多少个DexMapItem */</span></span><br><span class="line">    DexMapItem <span class="built_in">list</span>[<span class="number">1</span>];     <span class="comment">/* entries */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    kDexTypeHeaderItem               = <span class="number">0x0000</span>,</span><br><span class="line">    kDexTypeStringIdItem             = <span class="number">0x0001</span>,</span><br><span class="line">    kDexTypeTypeIdItem               = <span class="number">0x0002</span>,</span><br><span class="line">    kDexTypeProtoIdItem              = <span class="number">0x0003</span>,</span><br><span class="line">    kDexTypeFieldIdItem              = <span class="number">0x0004</span>,</span><br><span class="line">    kDexTypeMethodIdItem             = <span class="number">0x0005</span>,</span><br><span class="line">    kDexTypeClassDefItem             = <span class="number">0x0006</span>,</span><br><span class="line">    kDexTypeCallSiteIdItem           = <span class="number">0x0007</span>,</span><br><span class="line">    kDexTypeMethodHandleItem         = <span class="number">0x0008</span>,</span><br><span class="line">    kDexTypeMapList                  = <span class="number">0x1000</span>,</span><br><span class="line">    kDexTypeTypeList                 = <span class="number">0x1001</span>,</span><br><span class="line">    kDexTypeAnnotationSetRefList     = <span class="number">0x1002</span>,</span><br><span class="line">    kDexTypeAnnotationSetItem        = <span class="number">0x1003</span>,</span><br><span class="line">    kDexTypeClassDataItem            = <span class="number">0x2000</span>,</span><br><span class="line">    kDexTypeCodeItem                 = <span class="number">0x2001</span>,</span><br><span class="line">    kDexTypeStringDataItem           = <span class="number">0x2002</span>,</span><br><span class="line">    kDexTypeDebugInfoItem            = <span class="number">0x2003</span>,</span><br><span class="line">    kDexTypeAnnotationItem           = <span class="number">0x2004</span>,</span><br><span class="line">    kDexTypeEncodedArrayItem         = <span class="number">0x2005</span>,</span><br><span class="line">    kDexTypeAnnotationsDirectoryItem = <span class="number">0x2006</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个DexMapItem对应了一块数据，例如type=kDexTypeHeaderItem则对应DexHeader的偏移地址和大小。下面看真实数据</p><p><img src="/2021/07/08/android4/image-20210712222724586.png" alt="image-20210712222724586"></p><p>这里就能看到string_ids的偏移和大小。如此，根据这个map_list就能找到所有块的数据了。</p><p>那么在源码中是如何使用这个数据的呢，我好奇的翻了一下。然后再dex文件优化的流程中dexSwapAndVerify函数找到了使用的地方。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字节排序优化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dexSwapAndVerify</span><span class="params">(u1* addr, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (okay) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Look for the map. Swap it and then use it to find and swap</span></span><br><span class="line"><span class="comment">         * everything else.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (pHeader-&gt;mapOff != <span class="number">0</span>) &#123;</span><br><span class="line">            DexFile dexFile;</span><br><span class="line">            DexMapList* pDexMap = (DexMapList*) (addr + pHeader-&gt;mapOff);</span><br><span class="line">                        </span><br><span class="line">            okay = okay &amp;&amp; swapMap(&amp;state, pDexMap);</span><br><span class="line">            okay = okay &amp;&amp; swapEverythingButHeaderAndMap(&amp;state, pDexMap);</span><br><span class="line"></span><br><span class="line">            dexFileSetupBasicPointers(&amp;dexFile, addr);</span><br><span class="line">            state.pDexFile = &amp;dexFile;</span><br><span class="line"></span><br><span class="line">            okay = okay &amp;&amp; crossVerifyEverything(&amp;state, pDexMap);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;ERROR: No map found; impossible to byte-swap and verify&quot;</span>);</span><br><span class="line">            okay = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">return</span> !okay;       <span class="comment">// 0 == success</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数中获取了DexMapList。然后交给swapMap函数来处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">swapMap</span><span class="params">(CheckState* state, DexMapList* pMap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DexMapItem* item = pMap-&gt;<span class="built_in">list</span>;</span><br><span class="line">    u4 count;</span><br><span class="line">    u4 dataItemCount = <span class="number">0</span>; <span class="comment">// Total count of items in the data section.</span></span><br><span class="line">    u4 dataItemsLeft = state-&gt;pHeader-&gt;dataSize; <span class="comment">// See use below.</span></span><br><span class="line">    u4 usedBits = <span class="number">0</span>;      <span class="comment">// Bit set: one bit per section</span></span><br><span class="line">    <span class="keyword">bool</span> first = <span class="literal">true</span>;</span><br><span class="line">    u4 lastOffset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    SWAP_FIELD4(pMap-&gt;<span class="built_in">size</span>);</span><br><span class="line">    count = pMap-&gt;<span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">const</span> u4 sizeOfItem = (u4) <span class="keyword">sizeof</span>(DexMapItem);</span><br><span class="line">    CHECK_LIST_SIZE(item, count, sizeOfItem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (count--) &#123;</span><br><span class="line">        SWAP_FIELD2(item-&gt;type);</span><br><span class="line">        SWAP_FIELD2(item-&gt;unused);</span><br><span class="line">        SWAP_FIELD4(item-&gt;<span class="built_in">size</span>);</span><br><span class="line">        SWAP_OFFSET4(item-&gt;offset);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (first) &#123;</span><br><span class="line">            first = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastOffset &gt;= item-&gt;offset) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;Out-of-order map item: %#x then %#x&quot;</span>,</span><br><span class="line">                    lastOffset, item-&gt;offset);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (item-&gt;offset &gt;= state-&gt;pHeader-&gt;fileSize) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;Map item after end of file: %x, size %#x&quot;</span>,</span><br><span class="line">                    item-&gt;offset, state-&gt;pHeader-&gt;fileSize);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isDataSectionType(item-&gt;type)) &#123;</span><br><span class="line">            u4 icount = item-&gt;<span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This sanity check on the data section items ensures that</span></span><br><span class="line"><span class="comment">             * there are no more items than the number of bytes in</span></span><br><span class="line"><span class="comment">             * the data section.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (icount &gt; dataItemsLeft) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;Unrealistically many items in the data section: &quot;</span></span><br><span class="line">                        <span class="string">&quot;at least %d&quot;</span>, dataItemCount + icount);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dataItemsLeft -= icount;</span><br><span class="line">            dataItemCount += icount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        u4 <span class="built_in">bit</span> = mapTypeToBitMask(item-&gt;type);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">bit</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((usedBits &amp; <span class="built_in">bit</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;Duplicate map section of type %#x&quot;</span>, item-&gt;type);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (item-&gt;type == kDexTypeCallSiteIdItem) &#123;</span><br><span class="line">            state-&gt;pCallSiteIds = item;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item-&gt;type == kDexTypeMethodHandleItem) &#123;</span><br><span class="line">            state-&gt;pMethodHandleItems = item;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        usedBits |= <span class="built_in">bit</span>;</span><br><span class="line">        lastOffset = item-&gt;offset;</span><br><span class="line">        item++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((usedBits &amp; mapTypeToBitMask(kDexTypeHeaderItem)) == <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Map is missing header entry&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((usedBits &amp; mapTypeToBitMask(kDexTypeMapList)) == <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Map is missing map_list entry&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((usedBits &amp; mapTypeToBitMask(kDexTypeStringIdItem)) == <span class="number">0</span>)</span><br><span class="line">            &amp;&amp; ((state-&gt;pHeader-&gt;stringIdsOff != <span class="number">0</span>)</span><br><span class="line">                    || (state-&gt;pHeader-&gt;stringIdsSize != <span class="number">0</span>))) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Map is missing string_ids entry&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((usedBits &amp; mapTypeToBitMask(kDexTypeTypeIdItem)) == <span class="number">0</span>)</span><br><span class="line">            &amp;&amp; ((state-&gt;pHeader-&gt;typeIdsOff != <span class="number">0</span>)</span><br><span class="line">                    || (state-&gt;pHeader-&gt;typeIdsSize != <span class="number">0</span>))) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Map is missing type_ids entry&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((usedBits &amp; mapTypeToBitMask(kDexTypeProtoIdItem)) == <span class="number">0</span>)</span><br><span class="line">            &amp;&amp; ((state-&gt;pHeader-&gt;protoIdsOff != <span class="number">0</span>)</span><br><span class="line">                    || (state-&gt;pHeader-&gt;protoIdsSize != <span class="number">0</span>))) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Map is missing proto_ids entry&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((usedBits &amp; mapTypeToBitMask(kDexTypeFieldIdItem)) == <span class="number">0</span>)</span><br><span class="line">            &amp;&amp; ((state-&gt;pHeader-&gt;fieldIdsOff != <span class="number">0</span>)</span><br><span class="line">                    || (state-&gt;pHeader-&gt;fieldIdsSize != <span class="number">0</span>))) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Map is missing field_ids entry&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((usedBits &amp; mapTypeToBitMask(kDexTypeMethodIdItem)) == <span class="number">0</span>)</span><br><span class="line">            &amp;&amp; ((state-&gt;pHeader-&gt;methodIdsOff != <span class="number">0</span>)</span><br><span class="line">                    || (state-&gt;pHeader-&gt;methodIdsSize != <span class="number">0</span>))) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Map is missing method_ids entry&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((usedBits &amp; mapTypeToBitMask(kDexTypeClassDefItem)) == <span class="number">0</span>)</span><br><span class="line">            &amp;&amp; ((state-&gt;pHeader-&gt;classDefsOff != <span class="number">0</span>)</span><br><span class="line">                    || (state-&gt;pHeader-&gt;classDefsSize != <span class="number">0</span>))) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Map is missing class_defs entry&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state-&gt;pDataMap = dexDataMapAlloc(dataItemCount);</span><br><span class="line">    <span class="keyword">if</span> (state-&gt;pDataMap == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Unable to allocate data map (size %#x)&quot;</span>, dataItemCount);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这里的例子。我们可以看到他是如何使用这个map_list来访问所有的部分的。到这里dex文件的格式基本差不多了。</p><p>然后我们看看一个实战的项目。大佬写的fart中的py部分就的运用了dex文件格式相关的知识。</p><h1 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h1><h2 id="案例一：fart"><a href="#案例一：fart" class="headerlink" title="案例一：fart"></a>案例一：fart</h2><h3 id="1、github"><a href="#1、github" class="headerlink" title="1、github"></a>1、github</h3><blockquote><p><a href="https://github.com/hanbinglengyue/FART.git">FART</a></p></blockquote><h3 id="2、功能说明"><a href="#2、功能说明" class="headerlink" title="2、功能说明"></a>2、功能说明</h3><p>这是一个脱壳工具，使用主动调用的方式来解决二代抽取壳。脱出来的数据不止是dex。还有一种.bin的数据，这种数据可以用来辅助我们修复dex的一些没有脱出来的函数。我们先看下.bin数据是什么，下面是.bin中的一组数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;name:ooxx,method_idx:1830,offset:180516,code_item_len:24,ins:AQABAAEAAAB+oAMABAAAAHAQwAsAAA4A&#125;;</span><br></pre></td></tr></table></figure><p>name：是随意填的，因为并不是使用name来找对应函数，而是通过method_idx</p><p>method_idx：函数的索引。</p><p>offset：函数的偏移</p><p>code_item_len：code_item的大小</p><p>ins：code_item结构体这段数据的base64编码</p><p>另外贴一下这几个数据的dump来源的代码，以防有人把ins当成指令集了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> base64ptr = funcBase64_encode(ptr(codeitemstartaddr), codeitemlength, ptr(base64lengthptr));</span><br><span class="line"><span class="keyword">var</span> b64content = ptr(base64ptr).readCString(base64lengthptr.readInt());</span><br><span class="line">funcFreeptr(ptr(base64ptr));</span><br><span class="line"><span class="keyword">var</span> content = <span class="string">&quot;&#123;name:ooxx,method_idx:&quot;</span> + dex_method_index_ + <span class="string">&quot;,offset:&quot;</span> + dex_code_item_offset_ + <span class="string">&quot;,code_item_len:&quot;</span> + codeitemlength + <span class="string">&quot;,ins:&quot;</span> + b64content + <span class="string">&quot;&#125;;&quot;</span>;</span><br></pre></td></tr></table></figure><p>这几个数据是一个函数最关键的片段。拿到就可以还原出最关键的code_item了。</p><h3 id="3、使用"><a href="#3、使用" class="headerlink" title="3、使用"></a>3、使用</h3><p>然后看看fart.py的使用<code>./fart.py -d 431528_29868.dex -i 431528_29868.bin</code>。下面是执行结果，基本对这个dex进行完整的解析，打印出来大多数的数据。</p><p><img src="/2021/07/08/android4/image-20210713213412201.png" alt="image-20210713213412201"></p><h3 id="4、源码分析"><a href="#4、源码分析" class="headerlink" title="4、源码分析"></a>4、源码分析</h3><p>我们可以通过对这个项目的阅读，直观的了解到是如何进行dex文件格式进行解析的。下面开始看看具体的实现流程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment">#加载dex文件</span></span><br><span class="line">    dex = dex_parser(filename)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment">#获取到参数filename和insfilename</span></span><br><span class="line">    init()</span><br><span class="line">    methodTable.clear()</span><br><span class="line">    <span class="comment">#加载.bin文件的内容，也就是insfilename设置的文件，给methodTable填充上值。每项的数据是：方法名称，方法id，方法偏移，方法大小，指令集</span></span><br><span class="line">    parseinsfile()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;methodTable length:&quot;</span> + str(len(methodTable))</span><br><span class="line">    <span class="comment">#开始处理</span></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>然后看看是如何加载.bin文件的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parseinsfile</span>():</span></span><br><span class="line">    <span class="keyword">global</span> insfilename</span><br><span class="line">    insfile=open(insfilename)</span><br><span class="line">    content=insfile.read()</span><br><span class="line">    insfile.close()</span><br><span class="line">    <span class="comment">#;&#123;name:artMethod::dumpmethod DexFile_dumpDexFile&#x27;</span></span><br><span class="line">    <span class="comment"># dexfile name:classes.dex--</span></span><br><span class="line">    <span class="comment"># insfilepath:/data/data/com.wlqq/10668484_ins.bin--</span></span><br><span class="line">    <span class="comment"># code_item_len:40,</span></span><br><span class="line">    <span class="comment"># code_item_len:40,</span></span><br><span class="line">    <span class="comment"># ins:AgABAAIAAABLnY4ADAAAACIAFwNwEPoOAABuIP4OEAAMAR8BFwMRAQ==&#125;;</span></span><br><span class="line">    insarray=re.findall(<span class="string">r&quot;&#123;name:(.*?),method_idx:(.*?),offset:(.*?),code_item_len:(.*?),ins:(.*?)&#125;&quot;</span>,content) <span class="comment">#(.*?)最短匹配</span></span><br><span class="line">    <span class="comment">#按照我们前面看到的格式进行匹配数据并遍历</span></span><br><span class="line">    <span class="keyword">for</span> eachins <span class="keyword">in</span> insarray:</span><br><span class="line">      <span class="comment">#这里其实是固定的ooxx</span></span><br><span class="line">      methodname=eachins[<span class="number">0</span>].replace(<span class="string">&quot; &quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">      number=(int)(eachins[<span class="number">1</span>])</span><br><span class="line">      offset=(int)(eachins[<span class="number">2</span>])</span><br><span class="line">      inssize=int(eachins[<span class="number">3</span>])</span><br><span class="line">      ins=eachins[<span class="number">4</span>]</span><br><span class="line">      tempmethod=CodeItem(number,methodname,inssize,ins)</span><br><span class="line">      methodTable[number]=tempmethod <span class="comment">#添加method</span></span><br></pre></td></tr></table></figure><p>可以看到就是遍历，组装好那些数据，最后保存到一个methodTable里面，索引就是method_id。</p><p>再看看最关键的dex_parse</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dex_parser</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,filename</span>):</span></span><br><span class="line">        <span class="comment">#dex的标志</span></span><br><span class="line">        <span class="keyword">global</span> DEX_MAGIC</span><br><span class="line">        <span class="comment">#odex的标志</span></span><br><span class="line">        <span class="keyword">global</span> DEX_OPT_MAGIC</span><br><span class="line">        self.m_javaobject_id = <span class="number">0</span></span><br><span class="line">        <span class="comment">#dex的文件路径</span></span><br><span class="line">        self.m_filename = filename</span><br><span class="line">        self.m_fd = open(filename,<span class="string">&quot;rb&quot;</span>)</span><br><span class="line">        self.m_content = self.m_fd.read()</span><br><span class="line">        self.m_fd.close()</span><br><span class="line">        self.m_dex_optheader = <span class="literal">None</span></span><br><span class="line">        self.m_class_name_id = &#123;&#125;</span><br><span class="line">        self.string_table = []</span><br><span class="line">        <span class="comment">#如果发现是odex文件，则填充opt_header，否则只填充dex_header</span></span><br><span class="line">        <span class="keyword">if</span> self.m_content[<span class="number">0</span>:<span class="number">4</span>] == DEX_OPT_MAGIC:</span><br><span class="line">            self.init_optheader(self.m_content)</span><br><span class="line">            self.init_header(self.m_content,<span class="number">0x40</span>)</span><br><span class="line">        <span class="keyword">elif</span> self.m_content[<span class="number">0</span>:<span class="number">4</span>] == DEX_MAGIC:</span><br><span class="line">            self.init_header(self.m_content,<span class="number">0</span>)</span><br><span class="line">        <span class="comment">#上面填充dex_header的时候取到的string_ids的偏移位置和大小</span></span><br><span class="line">        bOffset = self.m_stringIdsOff</span><br><span class="line">        <span class="keyword">if</span> self.m_stringIdsSize &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment">#遍历字符串列表</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>,self.m_stringIdsSize):</span><br><span class="line">                <span class="comment">#这里是取出每个字符串的偏移地址</span></span><br><span class="line">                offset, = struct.unpack_from(<span class="string">&quot;I&quot;</span>,self.m_content,bOffset + i * <span class="number">4</span>)</span><br><span class="line">                <span class="comment">#如果是第一个则直接存放到start，然后处理下一次</span></span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                    start = offset</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment">#取出上一个偏移的字符串的偏移地址，这里由于存储格式是uleb128的。要转换成真正的偏移地址。</span></span><br><span class="line">                    skip, length = get_uleb128(self.m_content[start:start+<span class="number">5</span>])</span><br><span class="line">                    <span class="comment">#上面还原出了真实的偏移，这里取字符串的地址，保存起来</span></span><br><span class="line">                    self.string_table.append(self.m_content[start+skip:offset<span class="number">-1</span>])</span><br><span class="line">                    start = offset</span><br><span class="line">            <span class="comment">#处理最后的一条</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(start,len(self.m_content)):</span><br><span class="line">                <span class="keyword">if</span> self.m_content[i]==chr(<span class="number">0</span>):</span><br><span class="line">                    self.string_table.append(self.m_content[start+<span class="number">1</span>:i])</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="comment">#遍历classDef。填充m_class_name_id</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>,self.m_classDefSize):</span><br><span class="line">            str1 = self.getclassname(i)</span><br><span class="line">            self.m_class_name_id[str1] = i</span><br><span class="line">        <span class="comment">#遍历classDef，填充classdef相关的属性，并且打印，合并.bin的内容是在print中进行的。</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>,self.m_classDefSize):</span><br><span class="line">            str1 = self.getclassname(i)</span><br><span class="line">            dex_class(self,i).printf(self)</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>这里看到是通过init_header来解析dex文件中的dexHeader的。我就不贴代码了，整体就是偏移然后取数据。</p><p>这里有一点要说的是get_uleb128函数，uleb128在android里面是一个特殊的类型。是一个可变长度的类型。大致意思就是例如第一个字节的最高位，如果是1，则第二个字节也是有效数据，如果第二个字节的最高位也是1，下一个字节也是有效数据，如果最高位不是1，就结束了。最后左移拼接就ok了。</p><p>这个类型有没有很眼熟？没错，特别像是protobuf里面的varint编码。所以我觉得完全可以用protobuf包自带的varint解码来获取这个数据。也可以用这种自己写的函数来处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">varint_encode</span>(<span class="params">number</span>):</span></span><br><span class="line">    buf = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        towrite = number &amp; <span class="number">0x7f</span></span><br><span class="line">        number &gt;&gt;= <span class="number">7</span></span><br><span class="line">        <span class="keyword">if</span> number:</span><br><span class="line">            buf += struct.pack(<span class="string">&quot;B&quot;</span>,(towrite | <span class="number">0x80</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            buf +=  struct.pack(<span class="string">&quot;B&quot;</span>,towrite)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> buf</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">varint_decode</span>(<span class="params">buff</span>):</span></span><br><span class="line">    shift = <span class="number">0</span></span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    idx=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> idx&gt;len(buff):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        i = buff[idx]</span><br><span class="line">        idx+=<span class="number">1</span></span><br><span class="line">        result |= (i &amp; <span class="number">0x7f</span>) &lt;&lt; shift</span><br><span class="line">        shift += <span class="number">7</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (i &amp; <span class="number">0x80</span>):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>继续看后面的关键函数dex_class，这里来处理每一个类的打印</p><p>先看看初始化函数，基本和之前的initHeader的差不多，就是偏移取数据，然后保存下来。把classDef相关的数据都读取出来了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dex_class</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,dex_object,classid</span>):</span></span><br><span class="line">        <span class="keyword">if</span> classid &gt;= dex_object.m_classDefSize:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        offset = dex_object.m_classDefOffset + classid * struct.calcsize(<span class="string">&quot;8I&quot;</span>)</span><br><span class="line">        self.offset = offset</span><br><span class="line">        format = <span class="string">&quot;I&quot;</span></span><br><span class="line">        self.thisClass,=struct.unpack_from(format,dex_object.m_content,offset)</span><br><span class="line">        offset += struct.calcsize(format)</span><br><span class="line">        self.modifiers,=struct.unpack_from(format,dex_object.m_content,offset)</span><br><span class="line">        offset += struct.calcsize(format)</span><br><span class="line">        self.superClass,=struct.unpack_from(format,dex_object.m_content,offset)</span><br><span class="line">        offset += struct.calcsize(format)</span><br><span class="line">        self.interfacesOff,=struct.unpack_from(format,dex_object.m_content,offset)</span><br><span class="line">        offset += struct.calcsize(format)</span><br><span class="line">        self.sourceFileIdx,=struct.unpack_from(format,dex_object.m_content,offset)</span><br><span class="line">        offset += struct.calcsize(format)</span><br><span class="line">        self.annotationsOff,=struct.unpack_from(format,dex_object.m_content,offset)</span><br><span class="line">        offset += struct.calcsize(format)</span><br><span class="line">        self.classDataOff,=struct.unpack_from(format,dex_object.m_content,offset)</span><br><span class="line">        offset += struct.calcsize(format)</span><br><span class="line">        self.staticValuesOff,=struct.unpack_from(format,dex_object.m_content,offset)</span><br><span class="line">        offset += struct.calcsize(format)</span><br><span class="line">        self.index = classid</span><br><span class="line">        self.interfacesSize = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> self.interfacesOff != <span class="number">0</span>:</span><br><span class="line">            self.interfacesSize, = struct.unpack_from(<span class="string">&quot;I&quot;</span>,dex_object.m_content,self.interfacesOff)</span><br><span class="line">        <span class="keyword">if</span> self.classDataOff != <span class="number">0</span>:</span><br><span class="line">            offset = self.classDataOff</span><br><span class="line">            count,self.numStaticFields = get_uleb128(dex_object.m_content[offset:])</span><br><span class="line">            offset += count</span><br><span class="line">            count,self.numInstanceFields = get_uleb128(dex_object.m_content[offset:])</span><br><span class="line">            offset += count</span><br><span class="line">            count,self.numDirectMethods = get_uleb128(dex_object.m_content[offset:])</span><br><span class="line">            offset += count</span><br><span class="line">            count,self.numVirtualMethods = get_uleb128(dex_object.m_content[offset:])    </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.numStaticFields = <span class="number">0</span></span><br><span class="line">            self.numInstanceFields = <span class="number">0</span></span><br><span class="line">            self.numDirectMethods = <span class="number">0</span></span><br><span class="line">            self.numVirtualMethods = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>最后就是print函数，这里比较大，就只挑最关键的部分出来说下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printf</span>(<span class="params">self,dex_object</span>):</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;=========numDirectMethods[%d]=numVirtualMethods[%d]=numStaticMethods[0]=========&quot;</span>%(self.numDirectMethods,self.numVirtualMethods)</span><br><span class="line">    method_idx = <span class="number">0</span></span><br><span class="line">   <span class="comment"># 遍历实例函数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>,self.numDirectMethods):    </span><br><span class="line">     <span class="comment">#获取到method_id</span></span><br><span class="line">        n,method_idx_diff = get_uleb128(dex_object.m_content[offset:offset+<span class="number">5</span>])</span><br><span class="line">        offset += n</span><br><span class="line">        n,access_flags = get_uleb128(dex_object.m_content[offset:offset+<span class="number">5</span>])</span><br><span class="line">        offset += n</span><br><span class="line">        n,code_off = get_uleb128(dex_object.m_content[offset:offset+<span class="number">5</span>])</span><br><span class="line">        offset += n</span><br><span class="line">     <span class="comment">#这里看到method_idx实际上是累加的。我们可以找例子去看下。例如第一个函数的idx是0xd2。第二个的idx是1，实际上是0xd3。也就是上一个的值+1</span></span><br><span class="line">        method_idx += method_idx_diff</span><br><span class="line">        <span class="keyword">if</span> code_off != <span class="number">0</span>:</span><br><span class="line">            methodname=dex_object.getmethodfullname(method_idx,<span class="literal">True</span>).replace(<span class="string">&quot;::&quot;</span>,<span class="string">&quot;.&quot;</span>).replace(<span class="string">&quot; &quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">            method=<span class="literal">None</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">         <span class="comment">#这里获取了之前的.bin文件中对应的数据</span></span><br><span class="line">                method = methodTable[method_idx]</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">if</span> method != <span class="literal">None</span>:</span><br><span class="line">         <span class="comment">#如果bin文件中有这个函数，则先打印下dex中的对应函数</span></span><br><span class="line">                <span class="keyword">print</span> <span class="string">&quot;\nDirectMethod:&quot;</span> + dex_object.getmethodfullname(method_idx, <span class="literal">True</span>) + <span class="string">&quot;\n&quot;</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">&quot;before repire method+++++++++++++++++++++++++++++++++++\n&quot;</span></span><br><span class="line">                    method_code(dex_object, code_off).printf(dex_object, <span class="string">&quot;\t\t&quot;</span>)</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    <span class="keyword">print</span> e</span><br><span class="line">         <span class="comment">#然后再把bin文件中的给转换成method_code，然后打印</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    bytearray_str = base64.b64decode(method.insarray)</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">&quot;after repire method++++++++++++++++++++++++++++++++++++\n&quot;</span></span><br><span class="line">                    repired_method_code(dex_object, bytearray_str).printf(dex_object, <span class="string">&quot;\t\t&quot;</span>)</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    <span class="keyword">print</span> e</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>最后我们看下怎么获取的bin文件数据的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">repired_method_code</span>:</span></span><br><span class="line">    dex_obj=<span class="literal">None</span></span><br><span class="line">    content = <span class="string">&quot;&quot;</span></span><br><span class="line">    trylist = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, dex_obj,content</span>):</span></span><br><span class="line">        offset=<span class="number">0</span></span><br><span class="line">        format = <span class="string">&quot;H&quot;</span></span><br><span class="line">        self.dex_obj=dex_obj</span><br><span class="line">        self.content=content</span><br><span class="line">    <span class="comment"># 这段数据我们之前看到就是存的DexCode的结构体，所以直接按格式进行读取数据出来</span></span><br><span class="line">        self.registers_size, = struct.unpack_from(format, content, offset)</span><br><span class="line">        offset += struct.calcsize(format)</span><br><span class="line">        self.ins_size, = struct.unpack_from(format, content, offset)</span><br><span class="line">        offset += struct.calcsize(format)</span><br><span class="line">        self.outs_size, = struct.unpack_from(format, content, offset)</span><br><span class="line">        offset += struct.calcsize(format)</span><br><span class="line">        self.tries_size, = struct.unpack_from(format, content, offset)</span><br><span class="line">        offset += struct.calcsize(format)</span><br><span class="line">        format = <span class="string">&quot;I&quot;</span></span><br><span class="line">        self.debug_info_off, = struct.unpack_from(format, content, offset)</span><br><span class="line">        offset += struct.calcsize(format)</span><br><span class="line">        self.insns_size, = struct.unpack_from(format, content, offset)</span><br><span class="line">        offset += struct.calcsize(format)</span><br><span class="line">        self.insns = offset</span><br><span class="line">        offset += <span class="number">2</span> * self.insns_size</span><br><span class="line">        <span class="keyword">if</span> self.insns_size % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            offset += <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> self.tries_size == <span class="number">0</span>:</span><br><span class="line">            self.tries = <span class="number">0</span></span><br><span class="line">            self.handlers = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.handlerlist_offset = offset + <span class="number">8</span> * self.tries_size</span><br><span class="line">            self.tries = offset</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, self.tries_size):</span><br><span class="line">                temptryitem = tryitem(self.dex_obj,content, self.handlerlist_offset, offset + <span class="number">8</span> * i)</span><br><span class="line">                self.trylist.append(temptryitem)</span><br><span class="line">            self.handlers = offset + self.tries_size * struct.calcsize(<span class="string">&quot;I2H&quot;</span>)  <span class="comment">#</span></span><br></pre></td></tr></table></figure><p>最后还有个打印指令集的部分就不贴了。感兴趣的可以自己看一看</p><h2 id="案例二：dex2jar"><a href="#案例二：dex2jar" class="headerlink" title="案例二：dex2jar"></a>案例二：dex2jar</h2><h3 id="1、github："><a href="#1、github：" class="headerlink" title="1、github："></a>1、github：</h3><blockquote><p><a href="https://github.com/pxb1988/dex2jar.git">dex2jar</a></p></blockquote><h3 id="2、功能说明-1"><a href="#2、功能说明-1" class="headerlink" title="2、功能说明"></a>2、功能说明</h3><p>这个工具基本大家都用过。功能非常强大，不过这里只分析下d2j_dex2jar功能。也就是把dex给转换成jar文件。</p><h3 id="3、使用-1"><a href="#3、使用-1" class="headerlink" title="3、使用"></a>3、使用</h3><p>下载release版本直接<code>./d2j-dex2jar.sh classes.dex</code>，就生成出了对应的classes-dex2jar.jar文件。然后我们直接用其他分析工具就能愉快的看java代码了。那么神奇的事情是如何做到的呢。下面跟踪分析一下大佬的作品。</p><h3 id="4、源码分析-1"><a href="#4、源码分析-1" class="headerlink" title="4、源码分析"></a>4、源码分析</h3><p>第一步是找到入口，根据我们上面的使用例子，先搜索下d2j-dex2jar。然后找到了下面的文件</p><p><code>./dex2jar/dex-tools/src/main/java/com/googlecode/dex2jar/tools/Dex2jarCmd.java</code></p><p>先简单的看一下这里的代码，看来这里就是入口函数了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BaseCmd</span>.Syntax(cmd = <span class="string">&quot;d2j-dex2jar&quot;</span>, syntax = <span class="string">&quot;[options] &lt;file0&gt; [file1 ... fileN]&quot;</span>, desc = <span class="string">&quot;convert dex to jar&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dex2jarCmd</span> <span class="keyword">extends</span> <span class="title">BaseCmd</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Dex2jarCmd().doMain(args);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后看看doMain的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doMain</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        doCommandLine();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里调用了抽象方法，doCommandLine，所以继续看看实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doCommandLine</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">for</span> (String fileName : remainingArgs) &#123;</span><br><span class="line">            <span class="comment">// long baseTS = System.currentTimeMillis();</span></span><br><span class="line">            String baseName = getBaseName(<span class="keyword">new</span> File(fileName).toPath());</span><br><span class="line">              <span class="comment">//这里看到默认使用的jar文件名</span></span><br><span class="line">            Path file = output == <span class="keyword">null</span> ? currentDir.resolve(baseName + <span class="string">&quot;-dex2jar.jar&quot;</span>) : output;</span><br><span class="line">            System.err.println(<span class="string">&quot;dex2jar &quot;</span> + fileName + <span class="string">&quot; -&gt; &quot;</span> + file);</span><br><span class="line">                        <span class="comment">//BaseDexFileReader这个类型就是dex的所有解析处理</span></span><br><span class="line">            BaseDexFileReader reader = MultiDexFileReader.open(Files.readAllBytes(<span class="keyword">new</span> File(fileName).toPath()));</span><br><span class="line">              <span class="comment">//用来处理异常信息的</span></span><br><span class="line">            BaksmaliBaseDexExceptionHandler handler = notHandleException ? <span class="keyword">null</span> : <span class="keyword">new</span> BaksmaliBaseDexExceptionHandler();</span><br><span class="line">              <span class="comment">//这句就是最关键的转换部分，前面都是设置转换的一些参数，最后的to用来执行dex转换jar</span></span><br><span class="line">            Dex2jar.from(reader).withExceptionHandler(handler).reUseReg(reuseReg).topoLogicalSort()</span><br><span class="line">                    .skipDebug(!debugInfo).optimizeSynchronized(<span class="keyword">this</span>.optmizeSynchronized).printIR(printIR)</span><br><span class="line">                    .noCode(noCode).skipExceptions(skipExceptions).to(file);</span><br><span class="line">                        <span class="comment">//有异常的话，就通过异常处理handler保存信息</span></span><br><span class="line">            <span class="keyword">if</span> (!notHandleException) &#123;</span><br><span class="line">                <span class="keyword">if</span> (handler.hasException()) &#123;</span><br><span class="line">                    Path errorFile = exceptionFile == <span class="keyword">null</span> ? currentDir.resolve(baseName + <span class="string">&quot;-error.zip&quot;</span>)</span><br><span class="line">                            : exceptionFile;</span><br><span class="line">                    System.err.println(<span class="string">&quot;Detail Error Information in File &quot;</span> + errorFile);</span><br><span class="line">                    System.err.println(BaksmaliBaseDexExceptionHandler.REPORT_MESSAGE);</span><br><span class="line">                    handler.dump(errorFile, orginalArgs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// long endTS = System.currentTimeMillis();</span></span><br><span class="line">            <span class="comment">// System.err.println(String.format(&quot;%.2f&quot;, (float) (endTS - baseTS) / 1000));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>到这里就可以看出来两个最重要的部分了</p><p>1、解析dex的 MultiDexFileReader.open方法</p><p>2、执行转换的Dex2jar的to方法</p><p>下面先看看解析的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BaseDexFileReader <span class="title">open</span><span class="params">(<span class="keyword">byte</span>[] data)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">              <span class="comment">//dex文件太小就直接抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (data.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;File too small to be a dex/zip&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;dex&quot;</span>.equals(<span class="keyword">new</span> String(data, <span class="number">0</span>, <span class="number">3</span>, StandardCharsets.ISO_8859_1))) &#123;<span class="comment">// dex</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DexFileReader(data);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;PK&quot;</span>.equals(<span class="keyword">new</span> String(data, <span class="number">0</span>, <span class="number">2</span>, StandardCharsets.ISO_8859_1))) &#123;<span class="comment">// ZIP</span></span><br><span class="line">              <span class="comment">//可以看到如果是zip文件，它会帮我们在里面找classes开头并且.dex结尾的文件来处理，也就是说直接参数使用apk也是可以的。</span></span><br><span class="line">            TreeMap&lt;String, DexFileReader&gt; dexFileReaders = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">try</span> (ZipFile zipFile = <span class="keyword">new</span> ZipFile(data)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (ZipEntry e : zipFile.entries()) &#123;</span><br><span class="line">                    String entryName = e.getName();</span><br><span class="line">                    <span class="keyword">if</span> (entryName.startsWith(<span class="string">&quot;classes&quot;</span>) &amp;&amp; entryName.endsWith(<span class="string">&quot;.dex&quot;</span>)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!dexFileReaders.containsKey(entryName)) &#123; <span class="comment">// only the first one</span></span><br><span class="line">                            dexFileReaders.put(entryName, <span class="keyword">new</span> DexFileReader(toByteArray(zipFile.getInputStream(e))));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">              <span class="comment">//下面是单dex文件和多dex文件的处理</span></span><br><span class="line">            <span class="keyword">if</span> (dexFileReaders.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Can not find classes.dex in zip file&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dexFileReaders.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> dexFileReaders.firstEntry().getValue();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> MultiDexFileReader(dexFileReaders.values());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;the src file not a .dex or zip file&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们直接看参数为dex文件的情况就好了，所以继续看DexFileReader的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接调用了另一个重载</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DexFileReader</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(ByteBuffer.wrap(data));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//解析dex的关键位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DexFileReader</span><span class="params">(ByteBuffer in)</span> </span>&#123;</span><br><span class="line">        in.position(<span class="number">0</span>);</span><br><span class="line">        in = in.asReadOnlyBuffer().order(ByteOrder.BIG_ENDIAN);</span><br><span class="line">        <span class="keyword">int</span> magic = in.getInt() &amp; <span class="number">0xFFFFFF00</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> MAGIC_DEX = <span class="number">0x6465780A</span> &amp; <span class="number">0xFFFFFF00</span>;<span class="comment">// hex for &#x27;dex &#x27;, ignore the 0A</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> MAGIC_ODEX = <span class="number">0x6465790A</span> &amp; <span class="number">0xFFFFFF00</span>;<span class="comment">// hex for &#x27;dey &#x27;, ignore the 0A</span></span><br><span class="line">                <span class="comment">//这里区分一下是dex还是odex。odex情况就直接抛出异常了</span></span><br><span class="line">        <span class="keyword">if</span> (magic == MAGIC_DEX) &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (magic == MAGIC_ODEX) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> DexException(<span class="string">&quot;Not support odex&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> DexException(<span class="string">&quot;not support magic.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">              <span class="comment">//下面是取出dexHeader相关的一系列数据了</span></span><br><span class="line">        <span class="keyword">int</span> version = in.getInt() &gt;&gt; <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">if</span> (version &lt; <span class="number">0</span> || version &lt; DEX_035) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> DexException(<span class="string">&quot;not support version.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.dex_version = version;</span><br><span class="line">        in.order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// skip uint checksum</span></span><br><span class="line">        <span class="comment">// and 20 bytes signature</span></span><br><span class="line">        <span class="comment">// and uint file_size</span></span><br><span class="line">        <span class="comment">// and uint header_size 0x70</span></span><br><span class="line">              <span class="comment">// 意思是偏移跳过上面的那些数据，跳过是根据上面的字段占的空间来直接偏移即可</span></span><br><span class="line">        skip(in, <span class="number">4</span> + <span class="number">20</span> + <span class="number">4</span> + <span class="number">4</span>);</span><br><span class="line">                <span class="comment">//这个是cpu字节序，非小端序就直接抛出异常了。</span></span><br><span class="line">        <span class="keyword">int</span> endian_tag = in.getInt();</span><br><span class="line">        <span class="keyword">if</span> (endian_tag != ENDIAN_CONSTANT) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> DexException(<span class="string">&quot;not support endian_tag&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// skip uint link_size</span></span><br><span class="line">        <span class="comment">// and uint link_off</span></span><br><span class="line">              <span class="comment">//再跳过上面的两个字段</span></span><br><span class="line">        skip(in, <span class="number">4</span> + <span class="number">4</span>);</span><br><span class="line">                <span class="comment">//把下面那些重要部分的偏移全部取出来保存。</span></span><br><span class="line">        <span class="keyword">int</span> map_off = in.getInt();</span><br><span class="line">        string_ids_size = in.getInt();</span><br><span class="line">        <span class="keyword">int</span> string_ids_off = in.getInt();</span><br><span class="line">        type_ids_size = in.getInt();</span><br><span class="line">        <span class="keyword">int</span> type_ids_off = in.getInt();</span><br><span class="line">        proto_ids_size = in.getInt();</span><br><span class="line">        <span class="keyword">int</span> proto_ids_off = in.getInt();</span><br><span class="line">        field_ids_size = in.getInt();</span><br><span class="line">        <span class="keyword">int</span> field_ids_off = in.getInt();</span><br><span class="line">        method_ids_size = in.getInt();</span><br><span class="line">        <span class="keyword">int</span> method_ids_off = in.getInt();</span><br><span class="line">        class_defs_size = in.getInt();</span><br><span class="line">        <span class="keyword">int</span> class_defs_off = in.getInt();</span><br><span class="line">        <span class="comment">// skip uint data_size data_off</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> call_site_ids_off = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> call_site_ids_size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> method_handle_ids_off = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> method_handle_ids_size = <span class="number">0</span>;</span><br><span class="line">              <span class="comment">//如果是高版本的相关处理（大于DEX_037的版本我好像没见过。）</span></span><br><span class="line">        <span class="keyword">if</span> (dex_version &gt; DEX_037) &#123;</span><br><span class="line">            in.position(map_off);</span><br><span class="line">            <span class="keyword">int</span> size = in.getInt();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> type = in.getShort() &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">                in.getShort(); <span class="comment">// unused;</span></span><br><span class="line">                <span class="keyword">int</span> item_size = in.getInt();</span><br><span class="line">                <span class="keyword">int</span> item_offset = in.getInt();</span><br><span class="line">                <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">                <span class="keyword">case</span> TYPE_CALL_SITE_ID_ITEM:</span><br><span class="line">                    call_site_ids_off = item_offset;</span><br><span class="line">                    call_site_ids_size = item_size;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> TYPE_METHOD_HANDLE_ITEM:</span><br><span class="line">                    method_handle_ids_off = item_offset;</span><br><span class="line">                    method_handle_ids_size = item_size;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">              <span class="comment">//看这个意思是只有DEX_037以上的dex才有这个值，低版本默认0即可。</span></span><br><span class="line">        <span class="keyword">this</span>.call_site_ids_size = call_site_ids_size;</span><br><span class="line">        <span class="keyword">this</span>.method_handle_ids_size = method_handle_ids_size;</span><br><span class="line">                <span class="comment">//直接从内存中把这些重要数据的块给切片出来单独存放，后面使用就不需要全部通过偏移来找了。</span></span><br><span class="line">              <span class="comment">//这里的长度计算，是根据各个结构体的大小*列表长度计算。</span></span><br><span class="line">        stringIdIn = slice(in, string_ids_off, string_ids_size * <span class="number">4</span>);</span><br><span class="line">        typeIdIn = slice(in, type_ids_off, type_ids_size * <span class="number">4</span>);</span><br><span class="line">        protoIdIn = slice(in, proto_ids_off, proto_ids_size * <span class="number">12</span>);</span><br><span class="line">        fieldIdIn = slice(in, field_ids_off, field_ids_size * <span class="number">8</span>);</span><br><span class="line">        methoIdIn = slice(in, method_ids_off, method_ids_size * <span class="number">8</span>);</span><br><span class="line">        classDefIn = slice(in, class_defs_off, class_defs_size * <span class="number">32</span>);</span><br><span class="line">              <span class="comment">//下面这两个不用在意把，DEX_037以上的版本才有</span></span><br><span class="line">        callSiteIdIn = slice(in, call_site_ids_off, call_site_ids_size * <span class="number">4</span>);</span><br><span class="line">        methodHandleIdIn = slice(in, method_handle_ids_off, method_handle_ids_size * <span class="number">8</span>);</span><br><span class="line">                <span class="comment">//初始化下面这些数据，并且设置好字节序，这里还没设置偏移来着。感觉应该用一个变量就行了。</span></span><br><span class="line">        in.position(<span class="number">0</span>);</span><br><span class="line">        annotationsDirectoryItemIn = in.duplicate().order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">        annotationSetItemIn = in.duplicate().order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">        annotationItemIn = in.duplicate().order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">        annotationSetRefListIn = in.duplicate().order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">        classDataIn = in.duplicate().order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">        codeItemIn = in.duplicate().order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">        stringDataIn = in.duplicate().order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">        encodedArrayItemIn = in.duplicate().order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">        typeListIn = in.duplicate().order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">        debugInfoIn = in.duplicate().order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面看了dexHeader的解析的核心部分，接下来我们看看转换实现to方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">to</span><span class="params">(Path file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Files.exists(file) &amp;&amp; Files.isDirectory(file)) &#123;</span><br><span class="line">            doTranslate(file);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> (FileSystem fs = createZip(file)) &#123;</span><br><span class="line">                doTranslate(fs.getPath(<span class="string">&quot;/&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>继续看看doTranslate方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doTranslate</span><span class="params">(<span class="keyword">final</span> Path dist)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                ...</span><br><span class="line">        DexFileNode fileNode = <span class="keyword">new</span> DexFileNode();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">//这里的reader就是我们前面看到的那个解析dexHeader的处理，这里就是完整解析dex转换成fileNode</span></span><br><span class="line">            reader.accept(fileNode, readerConfig | DexFileReader.IGNORE_READ_EXCEPTION);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            exceptionHandler.handleFileException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">                <span class="comment">//.convertDex(fileNode, cvf);        最后调用的这个函数是把前面转换好的fileNode给转换成.class文件。最后打包成jar</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们主要观察的是dex的结构和解析，所以就不详细看转换部分了，继续看解析部分的后续accept方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里遍历所有class_def，然后调用另一个重载</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(DexFileVisitor dv, <span class="keyword">int</span> config)</span> </span>&#123;</span><br><span class="line">        dv.visitDexFileVersion(<span class="keyword">this</span>.dex_version);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cid = <span class="number">0</span>; cid &lt; class_defs_size; cid++) &#123;</span><br><span class="line">            accept(dv, cid, config);</span><br><span class="line">        &#125;</span><br><span class="line">        dv.visitEnd();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(DexFileVisitor dv, <span class="keyword">int</span> classIdx, <span class="keyword">int</span> config)</span> </span>&#123;</span><br><span class="line">              <span class="comment">//根据classdef索引找到偏移位置</span></span><br><span class="line">        classDefIn.position(classIdx * <span class="number">32</span>);</span><br><span class="line">              <span class="comment">//解析出classdef的各项字段</span></span><br><span class="line">        <span class="keyword">int</span> class_idx = classDefIn.getInt();</span><br><span class="line">        <span class="keyword">int</span> access_flags = classDefIn.getInt();</span><br><span class="line">        <span class="keyword">int</span> superclass_idx = classDefIn.getInt();</span><br><span class="line">        <span class="keyword">int</span> interfaces_off = classDefIn.getInt();</span><br><span class="line">        <span class="keyword">int</span> source_file_idx = classDefIn.getInt();</span><br><span class="line">        <span class="keyword">int</span> annotations_off = classDefIn.getInt();</span><br><span class="line">        <span class="keyword">int</span> class_data_off = classDefIn.getInt();</span><br><span class="line">        <span class="keyword">int</span> static_values_off = classDefIn.getInt();</span><br><span class="line"></span><br><span class="line">        String className = getType(class_idx);</span><br><span class="line">              <span class="comment">//这里看到可以设置忽略的classname，他这里是空的，固定返回false</span></span><br><span class="line">        <span class="keyword">if</span>(ignoreClass(className)) <span class="keyword">return</span>;</span><br><span class="line">        String superClassName = getType(superclass_idx);</span><br><span class="line">        String[] interfaceNames = getTypeList(interfaces_off);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">//visit这个是一个保存的功能，把值保存在了那个fileNode的里面。</span></span><br><span class="line">            DexClassVisitor dcv = dv.visit(access_flags, className, superClassName, interfaceNames);</span><br><span class="line">            <span class="keyword">if</span> (dcv != <span class="keyword">null</span>)<span class="comment">// 不处理</span></span><br><span class="line">            &#123;</span><br><span class="line">                  <span class="comment">//拿到了classdef的相关数据的偏移位置，再根据这些数据对类进行详细解析</span></span><br><span class="line">                acceptClass(dcv, source_file_idx, annotations_off, class_data_off, static_values_off, config);</span><br><span class="line">                dcv.visitEnd();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            DexException dexException = <span class="keyword">new</span> DexException(ex, <span class="string">&quot;Error process class: [%d]%s&quot;</span>, class_idx, className);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> != (config &amp; IGNORE_READ_EXCEPTION)) &#123;</span><br><span class="line">                niceExceptionMessage(dexException, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> dexException;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里最关键的就是acceptClass来解析具体的类的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">acceptClass</span><span class="params">(DexClassVisitor dcv, <span class="keyword">int</span> source_file_idx, <span class="keyword">int</span> annotations_off, <span class="keyword">int</span> class_data_off,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> static_values_off, <span class="keyword">int</span> config)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((config &amp; SKIP_DEBUG) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取源文件</span></span><br><span class="line">            <span class="keyword">if</span> (source_file_idx != -<span class="number">1</span>) &#123;</span><br><span class="line">                dcv.visitSource(<span class="keyword">this</span>.getString(source_file_idx));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">                <span class="comment">//字段的注释</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; fieldAnnotationPositions;</span><br><span class="line">              <span class="comment">//方法的注释</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; methodAnnotationPositions;</span><br><span class="line">              <span class="comment">//参数的注释</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; paramAnnotationPositions;</span><br><span class="line">        <span class="keyword">if</span> ((config &amp; SKIP_ANNOTATION) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取注解</span></span><br><span class="line">            fieldAnnotationPositions = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">            methodAnnotationPositions = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">            paramAnnotationPositions = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">              <span class="comment">// 如果有注释的偏移，下面则解析出注释的数据，保存到上面的对应map中</span></span><br><span class="line">            <span class="keyword">if</span> (annotations_off != <span class="number">0</span>) &#123; <span class="comment">// annotations_directory_item</span></span><br><span class="line"></span><br><span class="line">                annotationsDirectoryItemIn.position(annotations_off);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> class_annotations_off = annotationsDirectoryItemIn.getInt();</span><br><span class="line">                <span class="keyword">int</span> field_annotation_size = annotationsDirectoryItemIn.getInt();</span><br><span class="line">                <span class="keyword">int</span> method_annotation_size = annotationsDirectoryItemIn.getInt();</span><br><span class="line">                <span class="keyword">int</span> parameter_annotation_size = annotationsDirectoryItemIn.getInt();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; field_annotation_size; i++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> field_idx = annotationsDirectoryItemIn.getInt();</span><br><span class="line">                    <span class="keyword">int</span> field_annotations_offset = annotationsDirectoryItemIn.getInt();</span><br><span class="line">                    fieldAnnotationPositions.put(field_idx, field_annotations_offset);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; method_annotation_size; i++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> method_idx = annotationsDirectoryItemIn.getInt();</span><br><span class="line">                    <span class="keyword">int</span> method_annotation_offset = annotationsDirectoryItemIn.getInt();</span><br><span class="line">                    methodAnnotationPositions.put(method_idx, method_annotation_offset);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameter_annotation_size; i++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> method_idx = annotationsDirectoryItemIn.getInt();</span><br><span class="line">                    <span class="keyword">int</span> parameter_annotation_offset = annotationsDirectoryItemIn.getInt();</span><br><span class="line">                    paramAnnotationPositions.put(method_idx, parameter_annotation_offset);</span><br><span class="line">                &#125;</span><br><span class="line">                                <span class="comment">// 如果有对类的注释偏移</span></span><br><span class="line">                <span class="keyword">if</span> (class_annotations_off != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        read_annotation_set_item(class_annotations_off, dcv);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> DexException(<span class="string">&quot;error on reading Annotation of class &quot;</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fieldAnnotationPositions = <span class="keyword">null</span>;</span><br><span class="line">            methodAnnotationPositions = <span class="keyword">null</span>;</span><br><span class="line">            paramAnnotationPositions = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">                <span class="comment">//类详细数据的解析</span></span><br><span class="line">        <span class="keyword">if</span> (class_data_off != <span class="number">0</span>) &#123;</span><br><span class="line">            ByteBuffer in = classDataIn;</span><br><span class="line">            in.position(class_data_off);</span><br><span class="line">                        <span class="comment">//静态字段</span></span><br><span class="line">            <span class="keyword">int</span> static_fields = (<span class="keyword">int</span>) readULeb128i(in);</span><br><span class="line">              <span class="comment">//实例字段</span></span><br><span class="line">            <span class="keyword">int</span> instance_fields = (<span class="keyword">int</span>) readULeb128i(in);</span><br><span class="line">              <span class="comment">//实例函数</span></span><br><span class="line">            <span class="keyword">int</span> direct_methods = (<span class="keyword">int</span>) readULeb128i(in);</span><br><span class="line">              <span class="comment">//虚函数</span></span><br><span class="line">            <span class="keyword">int</span> virtual_methods = (<span class="keyword">int</span>) readULeb128i(in);</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> lastIndex = <span class="number">0</span>;</span><br><span class="line">                &#123;</span><br><span class="line">                    Object[] constant = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> ((config &amp; SKIP_FIELD_CONSTANT) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (static_values_off != <span class="number">0</span>) &#123;</span><br><span class="line">                            constant = read_encoded_array_item(static_values_off);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; static_fields; i++) &#123;</span><br><span class="line">                        Object value = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">if</span> (constant != <span class="keyword">null</span> &amp;&amp; i &lt; constant.length) &#123;</span><br><span class="line">                            value = constant[i];</span><br><span class="line">                        &#125;</span><br><span class="line">                          <span class="comment">// 解析并填充字段</span></span><br><span class="line">                        lastIndex = acceptField(in, lastIndex, dcv, fieldAnnotationPositions, value, config);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                lastIndex = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; instance_fields; i++) &#123;</span><br><span class="line">                      <span class="comment">// 解析并填充字段</span></span><br><span class="line">                    lastIndex = acceptField(in, lastIndex, dcv, fieldAnnotationPositions, <span class="keyword">null</span>, config);</span><br><span class="line">                &#125;</span><br><span class="line">                lastIndex = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">boolean</span> firstMethod = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; direct_methods; i++) &#123;</span><br><span class="line">                      <span class="comment">// 解析并填充方法</span></span><br><span class="line">                    lastIndex = acceptMethod(in, lastIndex, dcv, methodAnnotationPositions, paramAnnotationPositions,</span><br><span class="line">                            config, firstMethod);</span><br><span class="line">                    firstMethod = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                lastIndex = <span class="number">0</span>;</span><br><span class="line">                firstMethod = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; virtual_methods; i++) &#123;</span><br><span class="line">                      <span class="comment">// 解析并填充方法</span></span><br><span class="line">                    lastIndex = acceptMethod(in, lastIndex, dcv, methodAnnotationPositions, paramAnnotationPositions,</span><br><span class="line">                            config, firstMethod);</span><br><span class="line">                    firstMethod = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对类数据进行详细解析后，接着是对字段和方法的解析填充。先看看字段的解析处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字段数据的解析获取</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Field <span class="title">getField</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        fieldIdIn.position(id * <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">int</span> owner_idx = <span class="number">0xFFFF</span> &amp; fieldIdIn.getShort();</span><br><span class="line">        <span class="keyword">int</span> type_idx = <span class="number">0xFFFF</span> &amp; fieldIdIn.getShort();</span><br><span class="line">        <span class="keyword">int</span> name_idx = fieldIdIn.getInt();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Field(getType(owner_idx), getString(name_idx), getType(type_idx));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">acceptField</span><span class="params">(ByteBuffer in, <span class="keyword">int</span> lastIndex, DexClassVisitor dcv,</span></span></span><br><span class="line"><span class="function"><span class="params">            Map&lt;Integer, Integer&gt; fieldAnnotationPositions, Object value, <span class="keyword">int</span> config)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> diff = (<span class="keyword">int</span>) readULeb128i(in);</span><br><span class="line">        <span class="keyword">int</span> field_access_flags = (<span class="keyword">int</span>) readULeb128i(in);</span><br><span class="line">        <span class="keyword">int</span> field_id = lastIndex + diff;</span><br><span class="line">              <span class="comment">// 取出字段的数据</span></span><br><span class="line">        Field field = getField(field_id);</span><br><span class="line">              <span class="comment">// 下面是直接填充字段内容</span></span><br><span class="line">        <span class="comment">// //////////////////////////////////////////////////////////////</span></span><br><span class="line">        DexFieldVisitor dfv = dcv.visitField(field_access_flags, field, value);</span><br><span class="line">        <span class="keyword">if</span> (dfv != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((config &amp; SKIP_ANNOTATION) == <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">//字段注释的相关处理</span></span><br><span class="line">                Integer annotation_offset = fieldAnnotationPositions.get(field_id);</span><br><span class="line">                <span class="keyword">if</span> (annotation_offset != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        read_annotation_set_item(annotation_offset, dfv);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> DexException(e, <span class="string">&quot;while accept annotation in field:%s.&quot;</span>, field.toString());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dfv.visitEnd();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// //////////////////////////////////////////////////////////////</span></span><br><span class="line">        <span class="keyword">return</span> field_id;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>字段填充完毕，然后看看方法是怎么解析填充的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法数据的解析获取</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Method <span class="title">getMethod</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        methoIdIn.position(id * <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">int</span> owner_idx = <span class="number">0xFFFF</span> &amp; methoIdIn.getShort();</span><br><span class="line">        <span class="keyword">int</span> proto_idx = <span class="number">0xFFFF</span> &amp; methoIdIn.getShort();</span><br><span class="line">        <span class="keyword">int</span> name_idx = methoIdIn.getInt();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Method(getType(owner_idx), getString(name_idx), getProto(proto_idx));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">acceptMethod</span><span class="params">(ByteBuffer in, <span class="keyword">int</span> lastIndex, DexClassVisitor cv, Map&lt;Integer, Integer&gt; methodAnnos,</span></span></span><br><span class="line"><span class="function"><span class="params">            Map&lt;Integer, Integer&gt; parameterAnnos, <span class="keyword">int</span> config, <span class="keyword">boolean</span> firstMethod)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> offset = in.position();</span><br><span class="line">        <span class="keyword">int</span> diff = (<span class="keyword">int</span>) readULeb128i(in);</span><br><span class="line">        <span class="keyword">int</span> method_access_flags = (<span class="keyword">int</span>) readULeb128i(in);</span><br><span class="line">        <span class="keyword">int</span> code_off = (<span class="keyword">int</span>) readULeb128i(in);</span><br><span class="line">        <span class="keyword">int</span> method_id = lastIndex + diff;</span><br><span class="line">        Method method = getMethod(method_id);</span><br><span class="line">                ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">//填充方法数据</span></span><br><span class="line">            DexMethodVisitor dmv = cv.visitMethod(method_access_flags, method);</span><br><span class="line">            <span class="keyword">if</span> (dmv != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((config &amp; SKIP_ANNOTATION) == <span class="number">0</span>) &#123;</span><br><span class="line">                      <span class="comment">//处理方法的注释</span></span><br><span class="line">                    Integer annotation_offset = methodAnnos.get(method_id);</span><br><span class="line">                    <span class="keyword">if</span> (annotation_offset != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            read_annotation_set_item(annotation_offset, dmv);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> DexException(e, <span class="string">&quot;while accept annotation in method:%s.&quot;</span>, method.toString());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                      <span class="comment">//处理参数的注释</span></span><br><span class="line">                    Integer parameter_annotation_offset = parameterAnnos.get(method_id);</span><br><span class="line">                    <span class="keyword">if</span> (parameter_annotation_offset != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            read_annotation_set_ref_list(parameter_annotation_offset, dmv);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> DexException(e, <span class="string">&quot;while accept parameter annotation in method:%s.&quot;</span>,</span><br><span class="line">                                    method.toString());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                  <span class="comment">//如果有code_item。还继续进行指令的解析</span></span><br><span class="line">                <span class="keyword">if</span> (code_off != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> keep = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">0</span> != (SKIP_CODE &amp; config)) &#123;</span><br><span class="line">                        keep = <span class="number">0</span> != (KEEP_CLINIT &amp; config) &amp;&amp; method.getName().equals(<span class="string">&quot;&lt;clinit&gt;&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(keep) &#123;</span><br><span class="line">                        DexCodeVisitor dcv = dmv.visitCode();</span><br><span class="line">                        <span class="keyword">if</span> (dcv != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                  <span class="comment">//解析并填充code_item的数据</span></span><br><span class="line">                                acceptCode(code_off, dcv, config, (method_access_flags &amp; DexConstants.ACC_STATIC) != <span class="number">0</span>,</span><br><span class="line">                                        method);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> DexException(e, <span class="string">&quot;while accept code in method:[%s] @%08x&quot;</span>, method.toString(),</span><br><span class="line">                                        code_off);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                dmv.visitEnd();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> DexException(e, <span class="string">&quot;while accept method:[%s]&quot;</span>, method.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> method_id;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>继续看code_item的解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* package */</span><span class="function"><span class="keyword">void</span> <span class="title">acceptCode</span><span class="params">(<span class="keyword">int</span> code_off, DexCodeVisitor dcv, <span class="keyword">int</span> config, <span class="keyword">boolean</span> isStatic, Method method)</span> </span>&#123;</span><br><span class="line">        ByteBuffer in = codeItemIn;</span><br><span class="line">        in.position(code_off);</span><br><span class="line">              <span class="comment">//取出code_item的字段数据</span></span><br><span class="line">        <span class="keyword">int</span> registers_size = <span class="number">0xFFFF</span> &amp; in.getShort();</span><br><span class="line">        in.getShort();<span class="comment">// ins_size ushort</span></span><br><span class="line">        in.getShort();<span class="comment">// outs_size ushort</span></span><br><span class="line">        <span class="keyword">int</span> tries_size = <span class="number">0xFFFF</span> &amp; in.getShort();</span><br><span class="line">        <span class="keyword">int</span> debug_info_off = in.getInt();</span><br><span class="line">              <span class="comment">//指令长度</span></span><br><span class="line">        <span class="keyword">int</span> insns = in.getInt();</span><br><span class="line">                <span class="comment">//这里是指令集，好像是因为指令是2个字节为一个单位的。所以要*2</span></span><br><span class="line">        <span class="keyword">byte</span>[] insnsArray = <span class="keyword">new</span> <span class="keyword">byte</span>[insns * <span class="number">2</span>];</span><br><span class="line">        in.get(insnsArray);</span><br><span class="line">        dcv.visitRegister(registers_size);</span><br><span class="line">        BitSet nextInsn = <span class="keyword">new</span> BitSet();</span><br><span class="line">        Map&lt;Integer, DexLabel&gt; labelsMap = <span class="keyword">new</span> TreeMap&lt;Integer, DexLabel&gt;();</span><br><span class="line">        Set&lt;Integer&gt; handlers = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// 处理异常处理</span></span><br><span class="line">        <span class="keyword">if</span> (tries_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((insns &amp; <span class="number">0x01</span>) != <span class="number">0</span>) &#123;<span class="comment">// skip padding</span></span><br><span class="line">                in.getShort();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == (config &amp; SKIP_EXCEPTION)) &#123;</span><br><span class="line">                findTryCatch(in, dcv, tries_size, insns, labelsMap, handlers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理debug信息</span></span><br><span class="line">        <span class="keyword">if</span> (debug_info_off != <span class="number">0</span> &amp;&amp; (<span class="number">0</span> == (config &amp; SKIP_DEBUG))) &#123;</span><br><span class="line">            DexDebugVisitor ddv = dcv.visitDebug();</span><br><span class="line">            <span class="keyword">if</span> (ddv != <span class="keyword">null</span>) &#123;</span><br><span class="line">                read_debug_info(debug_info_off, registers_size, isStatic, method, labelsMap, ddv);</span><br><span class="line">                ddv.visitEnd();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BitSet badOps = <span class="keyword">new</span> BitSet();</span><br><span class="line">        findLabels(insnsArray, nextInsn, badOps, labelsMap, handlers, method);</span><br><span class="line">              <span class="comment">//解析并填充指令集</span></span><br><span class="line">        acceptInsn(insnsArray, dcv, nextInsn, badOps, labelsMap);</span><br><span class="line">        dcv.visitEnd();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后的acceptInsn指令集的解析方法太大了，我就不放上来了。整个解析填充的流程就完成了。后面就使用解析好的数据进行转换的操作。</p><p>可以看到两个案例的解析的方式差不多，总体都是根据结构体的大小偏移来取得想要的数据。最后一层一层的处理。</p><p>为了方便使用和测试，我将fart的解析整理了一下，改到了python3运行的。然后整合到了我的整合怪里面。感兴趣的可以看看。刚跑通，不知道有没啥问题，后面我再慢慢修复把。</p><p>github：<a href="https://github.com/dqzg12300/fridaUiTools">fridaUiTools</a></p><p>贴上效果图</p><p><img src="/2021/07/08/android4/image-20210714214202106.png" alt="image-20210714214202106"></p><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>fart的修复方案仅仅是打印出了保存的指令数据。如果我们是想要直接转成.class文件或者是jar文件。是否可行呢。</p><p>我设想了两种方案来做，但是最后都被自己给否定了。</p><p>1、bin文件中的指令数据直接插入到dex文件的对应数据中，最后保存为一个新的文件。但是这样中间插一段数据，会有大量的偏移数据要修改。</p><p>2、和dex2jar的模式一样。构造好一个fileNode对象，里面就不存在偏移的问题了。最后把里面的类数据导出成.class文件。</p>]]></content>
      
      
      
        <tags>
            
            <tag> android基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android基础篇三（笔记）</title>
      <link href="/2021/07/01/android3/"/>
      <url>/2021/07/01/android3/</url>
      
        <content type="html"><![CDATA[<p>这里主要是看书的笔记。从基础开始。不断记录。直到啃完这本书（android软件安全权威指南：丰生强）</p><h2 id="常见的android文件格式-2"><a href="#常见的android文件格式-2" class="headerlink" title="常见的android文件格式(2)"></a>常见的android文件格式(2)</h2><h3 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h3><p>存放了apk的大量配置信息，包括软件名称、图标、主题、包名、组件配置。</p><p>所有配置都属于manifest标签，与程序配置相关的属于android标签。</p><a id="more"></a><p><code>android:allowBackup=true</code>允许系统在进行备份操作时，备份程序的应用数据，比如在终端执行adb backup命令。对安全敏感的情况要设置为false</p><p><code>android:supportsRtl=true</code>让apk支持rtl（right-to-left）视图。targetSdkVersion必须在17及以上。</p><h3 id="AXML文件格式"><a href="#AXML文件格式" class="headerlink" title="AXML文件格式"></a>AXML文件格式</h3><p>AndroidManifest.xml在编译成apk前是明文的。编译成apk的时候，会把这个文件编译成二进制格式的文件。解压了再打开这个文件，就是乱码的。这个文件就是AXML格式。</p><h3 id="AXML文件修改"><a href="#AXML文件修改" class="headerlink" title="AXML文件修改"></a>AXML文件修改</h3><p>有些加固厂商利用android系统解析AXML的漏洞，在编译APK时构造畸形的AXML。导致apktool之类的工具不能正常工作，就需要修改AXML。有些现成的工具修复这种情况。AmBinaryEditor、AndroidManifestFix</p><h3 id="resources-arsc"><a href="#resources-arsc" class="headerlink" title="resources.arsc"></a>resources.arsc</h3><p>包含不同语言环境中res目录下所有资源的类型、名称与id所对应的信息。和AXML差不多，这是一个ARSC文件格式</p><h3 id="ARSC文件的修改"><a href="#ARSC文件的修改" class="headerlink" title="ARSC文件的修改"></a>ARSC文件的修改</h3><p>和AXML一样，也是有些特殊的ARSC可以正常被系统加载，又能组织apktool之类的反编译。也有一些修改是为了汉化软件。</p><h3 id="META-INF目录"><a href="#META-INF目录" class="headerlink" title="META-INF目录"></a>META-INF目录</h3><p>存储apk签名有关的信息。</p><h3 id="META-INF-CERT-RSA"><a href="#META-INF-CERT-RSA" class="headerlink" title="META-INF/CERT.RSA"></a>META-INF/CERT.RSA</h3><p>存放了apk的开发者证书与签名信息。通过这个文件识别开发者身份以及判断apk是否被修改。可以使用openssl来解码查看证书内容。</p><p><code>openssl pkcs7 -inform DER -in CERT.RSA -noout -print_certs -text</code></p><p>输出结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Certificate:</span><br><span class="line">    Data:</span><br><span class="line">        Version: 1 (0x0)</span><br><span class="line">        Serial Number: 1 (0x1)</span><br><span class="line">    Signature Algorithm: sha1WithRSAEncryption</span><br><span class="line">        Issuer: CN&#x3D;Android Debug, O&#x3D;Android, C&#x3D;US</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Aug 12 14:05:31 2020 GMT</span><br><span class="line">            Not After : Aug  5 14:05:31 2050 GMT</span><br><span class="line">        Subject: CN&#x3D;Android Debug, O&#x3D;Android, C&#x3D;US</span><br><span class="line">        Subject Public Key Info:</span><br><span class="line">            Public Key Algorithm: rsaEncryption</span><br><span class="line">                Public-Key: (2048 bit)</span><br><span class="line">                Modulus:</span><br><span class="line">                    00:9d:11:0b:8d:94:5f:28:34:1f:84:9a:1b:6a:1f:</span><br><span class="line">                    4b:1d:c6:19:59:94:6d:1d:33:b3:3d:9f:16:7d:73:</span><br><span class="line">                    ca:40:62:89:d7:39:75:15:67:c8:07:54:63:d0:42:</span><br><span class="line">                    fb:a4:c6:a2:b4:41:b5:19:6f:7c:76:eb:ec:51:3b:</span><br><span class="line">                    d1:fc:0c:f3:eb:db:4d:d8:ec:3c:6a:eb:46:3c:d2:</span><br><span class="line">                    e6:47:fe:8f:f3:8a:07:67:5c:09:9f:de:00:97:60:</span><br><span class="line">                    a7:7b:2b:f0:10:17:81:ec:e0:f7:a7:5a:55:79:89:</span><br><span class="line">                    ed:6b:ba:ea:f8:0d:d6:c2:fe:6c:fc:67:f5:36:97:</span><br><span class="line">                    8e:24:cd:97:41:7b:df:16:0d:63:b8:d6:ab:2b:fe:</span><br><span class="line">                    6a:1e:94:bc:41:44:f4:de:26:c3:44:d0:c2:6e:79:</span><br><span class="line">                    37:a1:3f:a6:a1:57:42:4f:5c:3e:e3:4b:ca:0b:eb:</span><br><span class="line">                    ea:19:dd:6d:fe:c3:34:57:3d:a1:b7:38:44:5b:ca:</span><br><span class="line">                    09:d9:da:70:3a:54:fb:4b:8d:c8:73:73:f7:38:0f:</span><br><span class="line">                    6f:5d:5b:45:f9:0d:88:2d:2d:6e:2b:a5:c9:2a:29:</span><br><span class="line">                    4a:8c:d0:87:74:47:4e:69:18:f8:93:0a:6d:a7:9b:</span><br><span class="line">                    22:3d:0f:38:fb:8c:02:e9:1b:73:97:80:6d:06:31:</span><br><span class="line">                    4f:82:75:dc:0a:76:30:aa:bb:cd:40:3d:3b:56:a6:</span><br><span class="line">                    0d:77</span><br><span class="line">                Exponent: 65537 (0x10001)</span><br><span class="line">    Signature Algorithm: sha1WithRSAEncryption</span><br><span class="line">         90:52:91:03:0b:de:9b:69:da:47:7a:5d:c8:3f:31:e1:3e:6d:</span><br><span class="line">         55:54:e6:29:25:2a:14:25:00:27:21:d1:0d:70:56:ac:3a:bf:</span><br><span class="line">         17:95:c9:bd:a4:83:2a:ee:5e:c9:a6:ef:4c:f0:60:35:86:b3:</span><br><span class="line">         ee:86:9e:9a:94:7b:74:1f:99:86:65:23:a3:13:50:7f:41:ed:</span><br><span class="line">         53:72:7f:83:8b:6d:40:ca:54:c8:25:44:75:b3:49:c0:61:cd:</span><br><span class="line">         4f:11:28:dc:cb:65:76:ce:03:fa:c3:d9:1b:f6:67:af:34:9f:</span><br><span class="line">         25:ab:2f:94:d3:24:ae:be:50:97:76:af:d1:e5:8a:5d:25:4f:</span><br><span class="line">         8a:17:75:de:0f:8d:71:53:38:ed:90:e1:0d:25:20:07:6b:2d:</span><br><span class="line">         2d:37:18:a0:82:e1:54:71:63:7f:97:03:2a:2e:54:1e:d0:53:</span><br><span class="line">         55:85:83:f0:e8:14:46:9c:7f:50:6a:a8:ad:73:17:94:ac:4e:</span><br><span class="line">         8c:8b:56:c0:95:41:47:50:23:36:65:d1:c4:8c:53:85:8f:15:</span><br><span class="line">         8f:fe:94:13:b5:71:74:7e:55:30:78:20:42:50:f7:44:10:77:</span><br><span class="line">         87:92:2a:2a:2d:c8:f1:e8:24:1e:7f:4a:3c:55:f2:87:89:29:</span><br><span class="line">         98:c8:b8:79:37:41:c8:7c:35:c5:8f:1d:5c:15:e3:36:2e:83:</span><br><span class="line">         59:49:db:69</span><br></pre></td></tr></table></figure><p>里面很多项都是用来鉴别apk是否被修改了。</p><h3 id="META-INF-MANIFEST-MF"><a href="#META-INF-MANIFEST-MF" class="headerlink" title="META-INF/MANIFEST.MF"></a>META-INF/MANIFEST.MF</h3><p>签名的清单文件，是个文本文件。大致的内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Built-By: Generated-by-ADT</span><br><span class="line">Created-By: Android Gradle 3.5.2</span><br><span class="line"></span><br><span class="line">Name: AndroidManifest.xml</span><br><span class="line">SHA-256-Digest: tQz8omUBWakxQm32m7lgSSAFdbP68612Iq4enf&#x2F;gmxw&#x3D;</span><br><span class="line"></span><br><span class="line">Name: META-INF&#x2F;androidx.appcompat_appcompat.version</span><br><span class="line">SHA-256-Digest: n9KGQtOsoZHlx&#x2F;wjg8&#x2F;W+rsqrIdD8Cnau4mJrFhOMbw&#x3D;</span><br><span class="line"></span><br><span class="line">Name: META-INF&#x2F;androidx.arch.core_core-runtime.version</span><br><span class="line">SHA-256-Digest: wo&#x2F;MpTY3vIjhJK8XJd8Ty5jGne3v1i+zzb4c22t2BiQ&#x3D;</span><br><span class="line"></span><br><span class="line">Name: META-INF&#x2F;androidx.asynclayoutinflater_asynclayoutinflater.version</span><br><span class="line">SHA-256-Digest: WYVJhIUxBN9cNT4vaBoV&#x2F;HkkdC+aLkaMKa8kjc5FzgM&#x3D;</span><br></pre></td></tr></table></figure><p>例如我们校验一下AndroidManifest.xml的值</p><p><code>openssl sha256 AndroidManifest.xml</code> 输出结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHA256(AndroidManifest.xml)&#x3D; b50cfca2650159a931426df69bb96049200575b3faf3ad7622ae1e9dffe09b1c</span><br></pre></td></tr></table></figure><p>然后我们把这个结果base64编码一下，输出结果如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tQz8omUBWakxQm32m7lgSSAFdbP68612Iq4enf&#x2F;gmxw&#x3D;</span><br></pre></td></tr></table></figure><p>发现和清单里面记录的一样。如果我们修改了这个文件，和清单里面的结果就不一样了。这里保证进行apk签名验证时所有文件均未被修改</p><h3 id="META-INF-CERT-SF"><a href="#META-INF-CERT-SF" class="headerlink" title="META-INF/CERT.SF"></a>META-INF/CERT.SF</h3><p>签名信息文件，也是文本文件。内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Signature-Version: 1.0</span><br><span class="line">Created-By: 1.0 (Android)</span><br><span class="line">SHA-256-Digest-Manifest: CsbfwGGBNUMOUJt4R7LYm+LGmb72vPx3Knonej3SUY0&#x3D;</span><br><span class="line">X-Android-APK-Signed: 2</span><br><span class="line"></span><br><span class="line">Name: AndroidManifest.xml</span><br><span class="line">SHA-256-Digest: gx84XauTSsCx8N18oEcdgiOHMpjhObi7ywdIEy3OaZU&#x3D;</span><br><span class="line"></span><br><span class="line">Name: META-INF&#x2F;androidx.appcompat_appcompat.version</span><br><span class="line">SHA-256-Digest: ABbgKP0s08CVeuJ5ZMlIZx&#x2F;AvJtb1QhNA0ffeXfCaHk&#x3D;</span><br><span class="line"></span><br><span class="line">Name: META-INF&#x2F;androidx.arch.core_core-runtime.version</span><br><span class="line">SHA-256-Digest: PjygIQMN5T6nIKT&#x2F;hi5PFaxVcEB+W20fr4f0g2n7jrg&#x3D;</span><br></pre></td></tr></table></figure><p>和上面的文件非常类似，但是多了两个属性</p><p>SHA-256-Digest-Manifest：这个对应的就是对MANIFEST.MF这个文件的校验。</p><p>X-Android-APK-Signed：使用签名的版本，值为2时表示使用新版APK Signature Scheme v2进行签名。android studio在新版本的sdk构建工具中增加了签名工具apksigner，同时支持旧版的v1签名和android7.0引入的v2签名。</p><p>继续看这个文件的AndroidManifest.xml的值，发现和上面清单的值不一样的。因为这里实际是对上面清单每一项的验证。</p><p><code>Name: AndroidManifest.xml\r\nSHA-256-Digest: tQz8omUBWakxQm32m7lgSSAFdbP68612Iq4enf/gmxw=\r\n\r\n</code> 对这个串进行sha256计算。</p><p><code>831f385dab934ac0b1f0dd7ca0471d8223873298e139b8bbcb0748132dce6995</code> 上面的值sha256的结果。然后继续进行base64编码</p><p><code>gx84XauTSsCx8N18oEcdgiOHMpjhObi7ywdIEy3OaZU=</code> 现在得到的值就和文件中的一致了。</p><h3 id="ODEX"><a href="#ODEX" class="headerlink" title="ODEX"></a>ODEX</h3><p>在android5.0之前主要使用dalvik虚拟机。为了提高dex文件的执行效率，会对dex文件进行一定程度的优化，具体做法就是解析并生成一个odex，然后保存在/data/dalvik-cache目录。以后运行的时候不会读取apk中的dex。而是直接加载优化过的odex。这样节省了运行程序在优化上耗费的时间。</p><h3 id="OAT"><a href="#OAT" class="headerlink" title="OAT"></a>OAT</h3><p>OAT是优化过的，用于art虚拟机执行的dex文件。类似dalvik的odex</p><h3 id="ART虚拟机"><a href="#ART虚拟机" class="headerlink" title="ART虚拟机"></a>ART虚拟机</h3><p>ART使用AOT编译技术，在apk第一次安装或者系统升级，重启时，通过dex2oat将apk中的dex文件静态编译成oat文件存放到设备的/data/dalvik-cache或者/data/app/package目录。我测试安卓10是在dalvik-cache的里面。</p><p>dex2oat更像是编译器，把dalvik字节码编译成native机器码。这样就提高了程序启动的速度。art虚拟机直接执行的oat文件，而不是dex。但是aot有个确定，就是静态编译操作影响apk的安装效率。但是android7.0中增加了jit编译。提高了安装的效率。</p><h3 id="生成OAT文件"><a href="#生成OAT文件" class="headerlink" title="生成OAT文件"></a>生成OAT文件</h3><p>除了安装时会自动生成OAT文件。也可以手动的生成，使用dex2oat命令。–dex-file传入dex路径，–oat-file指定oat文件路径。连接到设备，执行下面的命令。</p><p><code>dex2oat --dex-file=./classes.dex --oat-file=./classes.oat</code> 生成出了oat文件。然后把oat文件pull到电脑上。</p><p><code>file classes.oat</code> 看一下文件的格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classes.oat: ELF 32-bit LSB shared object, ARM, EABI5 version 1 (GNU&#x2F;Linux), dynamically linked, stripped</span><br></pre></td></tr></table></figure><p>oat文件格式在设计之初就考虑到最终执行的程序是elf格式的，最终将oat文件格式直接融入android所特有的elf格式。</p><p>既然是一个ELF文件，那么可以看一下符号表。可以使用ndk中的readelf查看。我直接用ida打开查看的符号表。图如下</p><p><img src="/2021/07/01/android3/image-20210701220459221.png" alt="image-20210701220459221"></p><p>一个oat文件必须包含oatdata、oatexec、oatlastword三个符号。</p><p>oatdata：指向的地址是oat所在elf的.rodata段。这里存放的是oat文件头OATHeader、oat的dex文件头，OATDexFile、原始dex文件DexFile、oat的dex类OatClass等信息。</p><p>oatexec：指向的地址是oat所在elf的.text段，这里存放的是编译生成的native指令代码。</p><p>oatlastword：指向的地址是oat文件结束处在elf中的文件偏移，通过它可以知道oat文件的内容在哪里结束。</p><p>OatHeader的结构，书中记录的位置并没有找到对应的struct，但是有个类似的class</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">class <span class="title">PACKED</span><span class="params">(<span class="number">4</span>)</span> OatHeader </span>&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">uint8_t</span> kOatMagic[] = &#123; <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;\n&#x27;</span> &#125;;</span><br><span class="line">  <span class="comment">// Last oat version changed reason: Math.pow() intrinsic.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">uint8_t</span> kOatVersion[] = &#123; <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span>* kImageLocationKey = <span class="string">&quot;image-location&quot;</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span>* kDex2OatCmdLineKey = <span class="string">&quot;dex2oat-cmdline&quot;</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span>* kDex2OatHostKey = <span class="string">&quot;dex2oat-host&quot;</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span>* kPicKey = <span class="string">&quot;pic&quot;</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span>* kDebuggableKey = <span class="string">&quot;debuggable&quot;</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span>* kNativeDebuggableKey = <span class="string">&quot;native-debuggable&quot;</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span>* kCompilerFilter = <span class="string">&quot;compiler-filter&quot;</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span>* kClassPathKey = <span class="string">&quot;classpath&quot;</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span>* kBootClassPathKey = <span class="string">&quot;bootclasspath&quot;</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span>* kConcurrentCopying = <span class="string">&quot;concurrent-copying&quot;</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span>* kCompilationReasonKey = <span class="string">&quot;compilation-reason&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span> kTrueValue[] = <span class="string">&quot;true&quot;</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span> kFalseValue[] = <span class="string">&quot;false&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> OatHeader* <span class="title">Create</span><span class="params">(InstructionSet instruction_set,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> InstructionSetFeatures* instruction_set_features,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">uint32_t</span> dex_file_count,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> SafeMap&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;* variable_data)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">IsValid</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">GetValidationErrorMessage</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">GetMagic</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">uint32_t</span> <span class="title">GetChecksum</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">uint8_t</span> magic_[<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">uint8_t</span> version_[<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">uint32_t</span> adler32_checksum_;</span><br><span class="line"></span><br><span class="line">  InstructionSet instruction_set_;</span><br><span class="line">  <span class="keyword">uint32_t</span> instruction_set_features_bitmap_;</span><br><span class="line">  <span class="keyword">uint32_t</span> dex_file_count_;</span><br><span class="line">  <span class="keyword">uint32_t</span> oat_dex_files_offset_;</span><br><span class="line">  <span class="keyword">uint32_t</span> executable_offset_;</span><br><span class="line">  <span class="keyword">uint32_t</span> interpreter_to_interpreter_bridge_offset_;</span><br><span class="line">  <span class="keyword">uint32_t</span> interpreter_to_compiled_code_bridge_offset_;</span><br><span class="line">  <span class="keyword">uint32_t</span> jni_dlsym_lookup_offset_;</span><br><span class="line">  <span class="keyword">uint32_t</span> quick_generic_jni_trampoline_offset_;</span><br><span class="line">  <span class="keyword">uint32_t</span> quick_imt_conflict_trampoline_offset_;</span><br><span class="line">  <span class="keyword">uint32_t</span> quick_resolution_trampoline_offset_;</span><br><span class="line">  <span class="keyword">uint32_t</span> quick_to_interpreter_bridge_offset_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The amount that the image this oat is associated with has been patched.</span></span><br><span class="line">  <span class="keyword">int32_t</span> image_patch_delta_;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint32_t</span> image_file_location_oat_checksum_;</span><br><span class="line">  <span class="keyword">uint32_t</span> image_file_location_oat_data_begin_;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint32_t</span> key_value_store_size_;</span><br><span class="line">  <span class="keyword">uint8_t</span> key_value_store_[<span class="number">0</span>];  <span class="comment">// note variable width data at end</span></span><br><span class="line"></span><br><span class="line">  DISALLOW_COPY_AND_ASSIGN(OatHeader);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从代码可以直接看到，有些值是固定的。</p><p>magic：文件的标识,固定是“oat\n”。表示oat的头部</p><p>version：oat的文件格式版本</p><p>Adler32_checksum：oat的adler32校验和</p><p>insetruction_set：oat文件使用的指令集。结构如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">InstructionSet</span> &#123;</span></span><br><span class="line">  kNone,</span><br><span class="line">  kArm,</span><br><span class="line">  kArm64,</span><br><span class="line">  kThumb2,</span><br><span class="line">  kX86,</span><br><span class="line">  kX86_64,</span><br><span class="line">  kMips,</span><br><span class="line">  kMips64,</span><br><span class="line">  kLast = kMips64</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>dex_file_count：oat文件中包含的dex文件的个数。通常普通app都是1</p><p>executable_offset：oatexec符号所在段的开始位置与oatdata符号所在段的开始位置的偏移。该值通常等于oatdata符号所在段.rodata的大小</p><p>jni_dlsym_lookup_offset：执行过程，如果类方法要调用另外一个方法是jni函数，就需要通过这个字段指向一段代码来调用</p><p>OatHeader下面是OatDexFile结构。数量和dex_file_count这个字段一致。</p><p>然后这里发现OatDexFile的结构和书中的不大一致</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OatDexFile</span> <span class="title">FINAL</span> &#123;</span></span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  OatDexFile(<span class="keyword">const</span> OatFile* oat_file,</span><br><span class="line">             <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dex_file_location,</span><br><span class="line">             <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; canonical_dex_file_location,</span><br><span class="line">             <span class="keyword">uint32_t</span> dex_file_checksum,</span><br><span class="line">             <span class="keyword">const</span> <span class="keyword">uint8_t</span>* dex_file_pointer,</span><br><span class="line">             <span class="keyword">const</span> <span class="keyword">uint8_t</span>* lookup_table_data,</span><br><span class="line">             <span class="keyword">const</span> IndexBssMapping* method_bss_mapping,</span><br><span class="line">             <span class="keyword">const</span> IndexBssMapping* type_bss_mapping,</span><br><span class="line">             <span class="keyword">const</span> IndexBssMapping* string_bss_mapping,</span><br><span class="line">             <span class="keyword">const</span> <span class="keyword">uint32_t</span>* oat_class_offsets_pointer,</span><br><span class="line">             <span class="keyword">const</span> DexLayoutSections* dex_layout_sections);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AssertAotCompiler</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> OatFile* <span class="keyword">const</span> oat_file_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> dex_file_location_;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> canonical_dex_file_location_;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> dex_file_location_checksum_ = <span class="number">0u</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint8_t</span>* <span class="keyword">const</span> dex_file_pointer_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint8_t</span>* <span class="keyword">const</span> lookup_table_data_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">const</span> IndexBssMapping* <span class="keyword">const</span> method_bss_mapping_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">const</span> IndexBssMapping* <span class="keyword">const</span> type_bss_mapping_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">const</span> IndexBssMapping* <span class="keyword">const</span> string_bss_mapping_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span>* <span class="keyword">const</span> oat_class_offsets_pointer_ = <span class="number">0u</span>;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;TypeLookupTable&gt; lookup_table_;</span><br><span class="line">  <span class="keyword">const</span> DexLayoutSections* <span class="keyword">const</span> dex_layout_sections_ = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">OatFile</span>;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">OatFileBase</span>;</span></span><br><span class="line">  DISALLOW_COPY_AND_ASSIGN(OatDexFile);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>OatDexFile数组的下面是DexFile结构体。里面存放的是一个个完整的dex。</p><p>OAT的格式图如下</p><p><img src="/2021/07/01/android3/image-20210701232116020.png" alt="image-20210701232116020"></p><h3 id="OAT文件转换成dex文件"><a href="#OAT文件转换成dex文件" class="headerlink" title="OAT文件转换成dex文件"></a>OAT文件转换成dex文件</h3><p>上面看到OAT文件中包含完整的dex文件。所以只要定位到OAT文件中的DexFile结构体，完整导出即可。</p><p>android系统提供了oatdump来导出所有的dex到指定目录</p><p><code>oatdump --export-dex-to=/data/local/tmp --oat-file=./classes.oat </code>命令执行完毕后得到文件<code>classes.dex_export.dex</code></p><p>或者是自己写工具，来解析OAT文件格式，取出dex。也有一种简单的方式，直接搜索文件头”dex\n035”。文件头的0x20字节处保存了大小。有了偏移和大小。直接搜索即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> android基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android基础篇二（笔记）</title>
      <link href="/2021/06/28/android2/"/>
      <url>/2021/06/28/android2/</url>
      
        <content type="html"><![CDATA[<p>这里主要是看书的笔记。从基础开始。不断记录。直到啃完这本书（android软件安全权威指南：丰生强）</p><h2 id="常见的android文件格式"><a href="#常见的android文件格式" class="headerlink" title="常见的android文件格式"></a>常见的android文件格式</h2><h3 id="1、jar包"><a href="#1、jar包" class="headerlink" title="1、jar包"></a>1、jar包</h3><p>就是一个zip格式的压缩包，里面是编译后的java字节码class文件集合。所以jar文件常叫作jar包。有些安全较高的jar包会对包含的class文件进行签名。并且把签名信息保存在META-INF目录。静态分析可以使用jd-gui。动态分析可以使用AspectJ。</p><a id="more"></a><h3 id="2、aar包"><a href="#2、aar包" class="headerlink" title="2、aar包"></a>2、aar包</h3><p>aar是android studio的全新的库文件格式，除了可以包含代码，还可以包含任何开发中使用的资源数据。实际上也是一个zip包格式。目录结构和apk文件类似。</p><h3 id="3、apk文件结构"><a href="#3、apk文件结构" class="headerlink" title="3、apk文件结构"></a>3、apk文件结构</h3><p>AndroidManifest.xml：编译好的AXML二进制格式文件。</p><p>META-INF：apk的签名信息</p><p>classes.dex：程序的可执行代码。开区MutiDex会有多个dex</p><p>res：程序中使用的资源文件</p><p>resources.arsc：编译好的二进制格式的资源信息</p><p>assets：如果使用asset系统来存放raw资源。所有资源都将保存在这里</p><h3 id="3-1、apk文件的生成流程"><a href="#3-1、apk文件的生成流程" class="headerlink" title="3.1、apk文件的生成流程"></a>3.1、apk文件的生成流程</h3><p>adt时代的生成流程：</p><p>aapt打包程序资源，处理AndroidManifest.xml和xml布局文件生成R.java文件。然后使用aidl解析AIDL接口，定义并生成相应的java文件。然后调用java编译器生成class文件。再使用dx将所有class文件与jar包打包生成dex文件。调用apkbuilder将上面的资源和class文件合并成apk。最后对apk进行对齐处理和签名。</p><p><img src="/2021/06/28/android2/ec574038051854668fcd6161a941bcbb.png" alt="ec574038051854668fcd6161a941bcbb.png"></p><p>android studio时代的生成流程：</p><p>使用gradle作为构建工具。</p><p><img src="/2021/06/28/android2/image-20210628213708543.png" alt="image-20210628213708543"></p><p>可以通过系统程序安装apk（开机时安装）</p><p>开机启动时由PackageManagerService服务完成。会安装/system/app的所有程序</p><h3 id="4、classes-dex"><a href="#4、classes-dex" class="headerlink" title="4、classes.dex"></a>4、classes.dex</h3><p>包含apk的可执行代码。可以先看下android源码中的dalvik/libdex/DexFile.h的定义ß</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexFile</span> &#123;</span></span><br><span class="line">    <span class="comment">/* odex的头 */</span></span><br><span class="line">    <span class="keyword">const</span> DexOptHeader* pOptHeader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* dex文件头，指定了dex文件的一些数据，记录了其他数据结构在dex文件中的物理偏移 */</span></span><br><span class="line">    <span class="keyword">const</span> DexHeader*    pHeader;</span><br><span class="line">      <span class="comment">/* 索引结构区 */</span></span><br><span class="line">    <span class="keyword">const</span> DexStringId*  pStringIds;</span><br><span class="line">    <span class="keyword">const</span> DexTypeId*    pTypeIds;</span><br><span class="line">    <span class="keyword">const</span> DexFieldId*   pFieldIds;</span><br><span class="line">    <span class="keyword">const</span> DexMethodId*  pMethodIds;</span><br><span class="line">    <span class="keyword">const</span> DexProtoId*   pProtoIds;</span><br><span class="line">      <span class="comment">/* 真实的数据存放 */</span></span><br><span class="line">    <span class="keyword">const</span> DexClassDef*  pClassDefs;</span><br><span class="line">      <span class="comment">/* 静态链接数据区 */</span></span><br><span class="line">    <span class="keyword">const</span> DexLink*      pLinkData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * These are mapped out of the &quot;auxillary&quot; section, and may not be</span></span><br><span class="line"><span class="comment">     * included in the file.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> DexClassLookup* pClassLookup;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span>*         pRegisterMapPool;       <span class="comment">// RegisterMapClassPool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* points to start of DEX file data */</span></span><br><span class="line">    <span class="keyword">const</span> u1*           baseAddr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* track memory overhead for auxillary structures */</span></span><br><span class="line">    <span class="keyword">int</span>                 overhead;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* additional app-specific data structures associated with the DEX */</span></span><br><span class="line">    <span class="comment">//void*               auxData;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后一些数据类型的定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint8_t</span>             u1;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span>            u2;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span>            u4;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint64_t</span>            u8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int8_t</span>              s1;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int16_t</span>             s2;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int32_t</span>             s4;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int64_t</span>             s8;</span><br></pre></td></tr></table></figure><p>然后看看dex文件头的结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexHeader</span> &#123;</span></span><br><span class="line">    u1  magic[<span class="number">8</span>];           <span class="comment">/* 表示是一个有效的dex文件。值一般固定为64 65 78 0A 30 33 35 00（dex.035） */</span></span><br><span class="line">    u4  checksum;           <span class="comment">/* adler32 checksum dex文件的校验和，用来判断文件是否已经损坏或者篡改 */</span></span><br><span class="line">    u1  signature[kSHA1DigestLen]; <span class="comment">/* SHA-1 hash 用来识别未经dexopt优化的dex文件*/</span></span><br><span class="line">    u4  fileSize;           <span class="comment">/* length of entire file 记录了包括dexHeader在内的整个dex文件的大小*/</span></span><br><span class="line">    u4  headerSize;         <span class="comment">/* offset to start of next section  dexHeader占用的字节数，一般都是0x70*/</span></span><br><span class="line">    u4  endianTag;                    <span class="comment">/* 指定dex运行环境的cpu字节序。预设是ENDIAN_CONSTANT等于0x12345678，也就是默认小端字节序 */</span></span><br><span class="line">    u4  linkSize;                        <span class="comment">/* 链接段的大小 */</span></span><br><span class="line">    u4  linkOff;                        <span class="comment">/* 文件偏移 */</span></span><br><span class="line">    u4  mapOff;                            <span class="comment">/* DexMapList结构的文件偏移 */</span></span><br><span class="line">    u4  stringIdsSize;            <span class="comment">/* 下面都是数据段的大小和文件偏移 */</span></span><br><span class="line">    u4  stringIdsOff;</span><br><span class="line">    u4  typeIdsSize;</span><br><span class="line">    u4  typeIdsOff;</span><br><span class="line">    u4  protoIdsSize;</span><br><span class="line">    u4  protoIdsOff;</span><br><span class="line">    u4  fieldIdsSize;</span><br><span class="line">    u4  fieldIdsOff;</span><br><span class="line">    u4  methodIdsSize;</span><br><span class="line">    u4  methodIdsOff;</span><br><span class="line">    u4  classDefsSize;</span><br><span class="line">    u4  classDefsOff;</span><br><span class="line">    u4  dataSize;</span><br><span class="line">    u4  dataOff;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是用010查看dex实际例子的详细数据</p><p><img src="/2021/06/28/android2/image-20210628221317029.png" alt="image-20210628221317029"></p><p>dalvik虚拟机解析dex文件内容，最终将其映射成DexMapList数据结构，mapoff字段指明DexMapList结构在dex文件中的偏移量。结构如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexMapItem</span> &#123;</span></span><br><span class="line">    u2 type;              <span class="comment">/* kDexType开头的类型 */</span></span><br><span class="line">    u2 unused;                        <span class="comment">/* 未使用，用于字节对齐 */</span></span><br><span class="line">    u4 <span class="built_in">size</span>;              <span class="comment">/* 数据的大小 */</span></span><br><span class="line">    u4 offset;            <span class="comment">/* 指定类型数据的文件偏移 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Direct-mapped &quot;map_list&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexMapList</span> &#123;</span></span><br><span class="line">    u4  <span class="built_in">size</span>;               <span class="comment">/* 有多少个DexMapItem */</span></span><br><span class="line">    DexMapItem <span class="built_in">list</span>[<span class="number">1</span>];     <span class="comment">/* entries */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    kDexTypeHeaderItem               = <span class="number">0x0000</span>,</span><br><span class="line">    kDexTypeStringIdItem             = <span class="number">0x0001</span>,</span><br><span class="line">    kDexTypeTypeIdItem               = <span class="number">0x0002</span>,</span><br><span class="line">    kDexTypeProtoIdItem              = <span class="number">0x0003</span>,</span><br><span class="line">    kDexTypeFieldIdItem              = <span class="number">0x0004</span>,</span><br><span class="line">    kDexTypeMethodIdItem             = <span class="number">0x0005</span>,</span><br><span class="line">    kDexTypeClassDefItem             = <span class="number">0x0006</span>,</span><br><span class="line">    kDexTypeCallSiteIdItem           = <span class="number">0x0007</span>,</span><br><span class="line">    kDexTypeMethodHandleItem         = <span class="number">0x0008</span>,</span><br><span class="line">    kDexTypeMapList                  = <span class="number">0x1000</span>,</span><br><span class="line">    kDexTypeTypeList                 = <span class="number">0x1001</span>,</span><br><span class="line">    kDexTypeAnnotationSetRefList     = <span class="number">0x1002</span>,</span><br><span class="line">    kDexTypeAnnotationSetItem        = <span class="number">0x1003</span>,</span><br><span class="line">    kDexTypeClassDataItem            = <span class="number">0x2000</span>,</span><br><span class="line">    kDexTypeCodeItem                 = <span class="number">0x2001</span>,</span><br><span class="line">    kDexTypeStringDataItem           = <span class="number">0x2002</span>,</span><br><span class="line">    kDexTypeDebugInfoItem            = <span class="number">0x2003</span>,</span><br><span class="line">    kDexTypeAnnotationItem           = <span class="number">0x2004</span>,</span><br><span class="line">    kDexTypeEncodedArrayItem         = <span class="number">0x2005</span>,</span><br><span class="line">    kDexTypeAnnotationsDirectoryItem = <span class="number">0x2006</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是dex真实的数据例子。这些数据和DexHeader中的偏移和大小对应。描述了整个DexHeader结构</p><p><img src="/2021/06/28/android2/image-20210628223619795.png" alt="image-20210628223619795"></p><p>stringDataOff指向的字符串并不是普通的ascii字符串，而是MUTF-8编码的。这个是一个经过修改的UTF-8编码。和传统的UTF-8相似。下面是结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexStringId</span> &#123;</span></span><br><span class="line">    u4 stringDataOff;      <span class="comment">/* 字符串数据偏移 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是真实dex的数据贴图</p><p><img src="/2021/06/28/android2/image-20210628224254285.png" alt="image-20210628224254285"></p><p>DexTypeId结构体如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexTypeId</span> &#123;</span></span><br><span class="line">    u4  descriptorIdx;      <span class="comment">/* index into stringIds list for type descriptor */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>真实数据如下</p><p><img src="/2021/06/28/android2/image-20210628224518205.png" alt="image-20210628224518205"></p><p>然后是DexProtoId方法声明结构体。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexProtoId</span> &#123;</span></span><br><span class="line">    u4  shortyIdx;          <span class="comment">/* DexStringId列表的索引*/</span></span><br><span class="line">    u4  returnTypeIdx;      <span class="comment">/* DexTypeId的索引 */</span></span><br><span class="line">    u4  parametersOff;      <span class="comment">/* 指向DexTypeList的偏移 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>真实数据如下</p><p><img src="/2021/06/28/android2/image-20210628225103521.png" alt="image-20210628225103521"></p><p>接着看上面DexTypeList的结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexTypeList</span> &#123;</span></span><br><span class="line">    u4  <span class="built_in">size</span>;               <span class="comment">/* dexTypeItem的个数 */</span></span><br><span class="line">    DexTypeItem <span class="built_in">list</span>[<span class="number">1</span>];    <span class="comment">/* entries */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexTypeItem</span> &#123;</span></span><br><span class="line">    u2  typeIdx;            <span class="comment">/* DexTypeId的索引 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>到这里就知道了。方法声明由返回类型和参数列表组成。</p><p>继续看DexFieldId。结构体如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexFieldId</span> &#123;</span></span><br><span class="line">    u2  classIdx;           <span class="comment">/* 类的类型，指向DexTypeId的索引 */</span></span><br><span class="line">    u2  typeIdx;            <span class="comment">/* 字段类型，指向DexTypeId的索引 */</span></span><br><span class="line">    u4  nameIdx;            <span class="comment">/* 字段名，指向DexStringId的索引 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>真实数据如下</p><p><img src="/2021/06/28/android2/image-20210628225926424.png" alt="image-20210628225926424"></p><p>接下来是DexMethodId，结构如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexMethodId</span> &#123;</span></span><br><span class="line">    u2  classIdx;           <span class="comment">/* 类的类型，指向DexTypeId的索引 */</span></span><br><span class="line">    u2  protoIdx;           <span class="comment">/* 声明类型，指向DexProtoId的索引 */</span></span><br><span class="line">    u4  nameIdx;            <span class="comment">/* 方法名，指向DexStringId索引 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>真实数据如下</p><p><img src="/2021/06/28/android2/image-20210628230238458.png" alt="image-20210628230238458"></p><p>最后是DexClassDef，结构如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexClassDef</span> &#123;</span></span><br><span class="line">    u4  classIdx;           <span class="comment">/* 类的类型，指向DexTypeId的索引 */</span></span><br><span class="line">    u4  accessFlags;                <span class="comment">/* 访问标志 */</span></span><br><span class="line">    u4  superclassIdx;      <span class="comment">/* 父类的类型，指向DexTypeId的索引 */</span></span><br><span class="line">    u4  interfacesOff;      <span class="comment">/* 接口，指向DexTypeList的偏移，如果没有接口的声明和实现，值为0 */</span></span><br><span class="line">    u4  sourceFileIdx;      <span class="comment">/* 类所在的源文件名，指向DexStringId的索引 */</span></span><br><span class="line">    u4  annotationsOff;     <span class="comment">/* 注释，根据类型不同会有注解类，注解字段，注解方法，注解参数，没有注解值就是0，指向DexAnnotationsDirectoryItem的结构体 */</span></span><br><span class="line">    u4  classDataOff;       <span class="comment">/* 类的数据部分，指向DexClassData结构的偏移 */</span></span><br><span class="line">    u4  staticValuesOff;    <span class="comment">/* 类中的静态数据，指向DexEncodeArray结构的偏移 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>真实数据如下</p><p><img src="/2021/06/28/android2/image-20210629205721474.png" alt="image-20210629205721474"></p><p>接着是DexClassData的结构体如下。这几个不在DexFile.h中定义，而是在DexClass.h中定义的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* expanded form of a class_data_item header */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexClassDataHeader</span> &#123;</span></span><br><span class="line">    u4 staticFieldsSize;                <span class="comment">/* 静态字段的个数 */</span></span><br><span class="line">    u4 instanceFieldsSize;            <span class="comment">/* 实例字段的个数 */</span></span><br><span class="line">    u4 directMethodsSize;                <span class="comment">/* 直接方法的个数 */</span></span><br><span class="line">    u4 virtualMethodsSize;            <span class="comment">/* 虚方法的个数 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* expanded form of encoded_field */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexField</span> &#123;</span></span><br><span class="line">    u4 fieldIdx;    <span class="comment">/* 指向DexFieldId的索引 */</span></span><br><span class="line">    u4 accessFlags;    <span class="comment">/* 访问标志 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* expanded form of encoded_method */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexMethod</span> &#123;</span></span><br><span class="line">    u4 methodIdx;    <span class="comment">/* 指向DexMethodId的索引 */</span></span><br><span class="line">    u4 accessFlags;     <span class="comment">/* 访问标志 */</span></span><br><span class="line">    u4 codeOff;      <span class="comment">/* 指向DexCode结构的偏移 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexClassData</span> &#123;</span></span><br><span class="line">    DexClassDataHeader header;                            <span class="comment">/* 指定字段和方法的个数 */</span></span><br><span class="line">    DexField*          staticFields;                <span class="comment">/* 静态字段 */</span></span><br><span class="line">    DexField*          instanceFields;            <span class="comment">/* 实例字段 */</span></span><br><span class="line">    DexMethod*         directMethods;                <span class="comment">/* 直接方法 */</span></span><br><span class="line">    DexMethod*         virtualMethods;            <span class="comment">/* 虚方法 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后看看DexClassData的真实数据</p><p><img src="/2021/06/28/android2/image-20210629215356769.png" alt="image-20210629215356769"></p><p>这里相当于把DexClassDataHeader直接展示了。前面4个字段就是。下面是DexMethod的真实数据展示</p><p><img src="/2021/06/28/android2/image-20210629220004765.png" alt="image-20210629220004765"></p><p>继续看这里面的DexCode结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexCode</span> &#123;</span></span><br><span class="line">    u2  registersSize;            <span class="comment">/* 使用寄存器的个数 */</span></span><br><span class="line">    u2  insSize;                        <span class="comment">/* 参数的个数 */</span></span><br><span class="line">    u2  outsSize;                        <span class="comment">/* 调用其他方法时使用的寄存器个数 */</span></span><br><span class="line">    u2  triesSize;                    <span class="comment">/* try/catch语句的个数 */</span></span><br><span class="line">    u4  debugInfoOff;       <span class="comment">/* 指向调试信息的偏移 */</span></span><br><span class="line">    u4  insnsSize;          <span class="comment">/* 指令集的个数，以2字节为单位 */</span></span><br><span class="line">    u2  insns[<span class="number">1</span>];                        <span class="comment">/* 指令集 */</span></span><br><span class="line">    <span class="comment">/* 2字节空间用于对齐 */</span></span><br><span class="line">    <span class="comment">/* followed by try_item[triesSize] DexTry结构体 */</span></span><br><span class="line">    <span class="comment">/* followed by uleb128 handlersSize */</span></span><br><span class="line">    <span class="comment">/* followed by catch_handler_item[handlersSize] DexCatchHandler结构体 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的registersSize的值其实就是smali语法里面的.register指令后面的值。insSize对应了smali语法的.paramter。outSize是在方法内部调用外部方法使用到的寄存器个数。例如a方法使用5个寄存器，a方法内调用了b方法，然后b方法使用了20个寄存器。则outSize值是20。下面看真实数据展示</p><p><img src="/2021/06/28/android2/image-20210629222029571.png" alt="image-20210629222029571"></p><h3 id="5、dex文件的验证和优化"><a href="#5、dex文件的验证和优化" class="headerlink" title="5、dex文件的验证和优化"></a>5、dex文件的验证和优化</h3><p>了解了验证和优化的过程，就知道了DexHeader中的checksum和signature字段的计算过程。就可以在修改dex文件后对这两个字段修正。</p><p>dexopt是android专门用来提供验证和优化操作的。dalvik虚拟机在加载dex文件时，通过指定的验证与优化选项来调用dexopt进行优化操作。</p><p>dexopt的主程序入口在OptMain.cpp。不过看了android9.0的代码中没有这个cpp了。4.4.4版本中还有。</p><p>处理apk、jar、zip中的classes.dex文件的函数是extractAndProcessZip()。同样在9.0的代码中找不到这个函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">extractAndProcessZip</span><span class="params">(<span class="keyword">int</span> zipFd, <span class="keyword">int</span> cacheFd,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span>* debugFileName, <span class="keyword">bool</span> isBootstrap, <span class="keyword">const</span> <span class="keyword">char</span>* bootClassPath,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span>* dexoptFlagStr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    <span class="comment">//查找目标文件中是否有classes.dex。没有就直接返回</span></span><br><span class="line">    zipEntry = dexZipFindEntry(&amp;zippy, kClassesDex);</span><br><span class="line">    <span class="keyword">if</span> (zipEntry == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">&quot;DexOptZ: zip archive &#x27;%s&#x27; does not include %s&quot;</span>,</span><br><span class="line">            debugFileName, kClassesDex);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 读取classes.dex的时间戳和crc校验值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (dexZipGetEntryInfo(&amp;zippy, zipEntry, <span class="literal">NULL</span>, &amp;uncompLen, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">            &amp;modWhen, &amp;crc32) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ALOGW(<span class="string">&quot;DexOptZ: zip archive GetEntryInfo failed on %s&quot;</span>, debugFileName);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uncompLen = uncompLen;</span><br><span class="line">    modWhen = modWhen;</span><br><span class="line">    crc32 = crc32;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 释放classes.dex到缓存文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (dexZipExtractEntryToFile(&amp;zippy, zipEntry, cacheFd) != <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">&quot;DexOptZ: extraction of %s from %s failed&quot;</span>,</span><br><span class="line">            kClassesDex, debugFileName);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解析传递过来的优化和验证的选项参数 */</span></span><br><span class="line">    <span class="keyword">if</span> (dexoptFlagStr[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* opc;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* val;</span><br><span class="line"></span><br><span class="line">        opc = <span class="built_in">strstr</span>(dexoptFlagStr, <span class="string">&quot;v=&quot;</span>);      <span class="comment">/* 验证选项 */</span></span><br><span class="line">        <span class="keyword">if</span> (opc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (*(opc+<span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:   verifyMode = VERIFY_MODE_NONE;          <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:   verifyMode = VERIFY_MODE_REMOTE;        <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:   verifyMode = VERIFY_MODE_ALL;           <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:                                            <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        opc = <span class="built_in">strstr</span>(dexoptFlagStr, <span class="string">&quot;o=&quot;</span>);      <span class="comment">/* 优化选项 */</span></span><br><span class="line">        <span class="keyword">if</span> (opc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (*(opc+<span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:   dexOptMode = OPTIMIZE_MODE_NONE;        <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:   dexOptMode = OPTIMIZE_MODE_VERIFIED;    <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:   dexOptMode = OPTIMIZE_MODE_ALL;         <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:   dexOptMode = OPTIMIZE_MODE_FULL;        <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:                                            <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        opc = <span class="built_in">strstr</span>(dexoptFlagStr, <span class="string">&quot;m=y&quot;</span>);     <span class="comment">/* register map */</span></span><br><span class="line">        <span class="keyword">if</span> (opc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            dexoptFlags |= DEXOPT_GEN_REGISTER_MAPS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        opc = <span class="built_in">strstr</span>(dexoptFlagStr, <span class="string">&quot;u=&quot;</span>);      <span class="comment">/* uniprocessor target */</span></span><br><span class="line">        <span class="keyword">if</span> (opc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (*(opc+<span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;y&#x27;</span>:   dexoptFlags |= DEXOPT_UNIPROCESSOR;     <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:   dexoptFlags |= DEXOPT_SMP;              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:                                            <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 根据优化选项和验证选项启动一个虚拟机进程，这两个选项数据会存储到全局DvmGlobals的dexOptMode和classVerifyMode中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (dvmPrepForDexOpt(bootClassPath, dexOptMode, verifyMode,</span><br><span class="line">            dexoptFlags) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;DexOptZ: VM init failed&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//vmStarted = 1;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 开始优化和验证的处理 */</span></span><br><span class="line">    <span class="keyword">if</span> (!dvmContinueOptimization(cacheFd, dexOffset, uncompLen, debugFileName,</span><br><span class="line">            modWhen, crc32, isBootstrap))</span><br><span class="line">    &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Optimization failed&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we don&#x27;t shut the VM down -- process is about to exit */</span></span><br><span class="line"></span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">bail:</span><br><span class="line">    dexZipCloseArchive(&amp;zippy);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>验证和优化的代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dvmContinueOptimization</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> dexOffset, <span class="keyword">long</span> dexLength,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span>* fileName, u4 modWhen, u4 crc, <span class="keyword">bool</span> isBootstrap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* 简答的检查下文件是否合法 */</span></span><br><span class="line">    <span class="keyword">if</span> (dexLength &lt; (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(DexHeader)) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;too small to be DEX&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dexOffset &lt; (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(DexOptHeader)) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;not enough room for opt header&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Drop this into a global so we don&#x27;t have to pass it around.  We could</span></span><br><span class="line"><span class="comment">     * also add a field to DexFile, but since it only pertains to DEX</span></span><br><span class="line"><span class="comment">     * creation that probably doesn&#x27;t make sense.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    gDvm.optimizingBootstrapClass = isBootstrap;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 将整个dex文件映射到内存中 */</span></span><br><span class="line">        <span class="keyword">bool</span> success;</span><br><span class="line">        <span class="keyword">void</span>* mapAddr;</span><br><span class="line">        mapAddr = mmap(<span class="literal">NULL</span>, dexOffset + dexLength, PROT_READ|PROT_WRITE,</span><br><span class="line">                    MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (mapAddr == MAP_FAILED) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;unable to mmap DEX cache: %s&quot;</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">goto</span> bail;</span><br><span class="line">        &#125;</span><br><span class="line">                <span class="comment">/* 根据验证和优化的选项设置doVerify和doOpt */</span></span><br><span class="line">        <span class="keyword">bool</span> doVerify, doOpt;</span><br><span class="line">        <span class="keyword">if</span> (gDvm.classVerifyMode == VERIFY_MODE_NONE) &#123;</span><br><span class="line">            doVerify = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (gDvm.classVerifyMode == VERIFY_MODE_REMOTE) &#123;</span><br><span class="line">            doVerify = !gDvm.optimizingBootstrapClass;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">/*if (gDvm.classVerifyMode == VERIFY_MODE_ALL)*/</span> &#123;</span><br><span class="line">            doVerify = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (gDvm.dexOptMode == OPTIMIZE_MODE_NONE) &#123;</span><br><span class="line">            doOpt = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (gDvm.dexOptMode == OPTIMIZE_MODE_VERIFIED ||</span><br><span class="line">                   gDvm.dexOptMode == OPTIMIZE_MODE_FULL) &#123;</span><br><span class="line">            doOpt = doVerify;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">/*if (gDvm.dexOptMode == OPTIMIZE_MODE_ALL)*/</span> &#123;</span><br><span class="line">            doOpt = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         重写文件。字节重新排序，结构重新对齐，类验证信息及辅助数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        success = rewriteDex(((u1*) mapAddr) + dexOffset, dexLength,</span><br><span class="line">                    doVerify, doOpt, &amp;pClassLookup, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            DvmDex* pDvmDex = <span class="literal">NULL</span>;</span><br><span class="line">            u1* dexAddr = ((u1*) mapAddr) + dexOffset;</span><br><span class="line">                        <span class="comment">/* 验证odex文件 */</span></span><br><span class="line">            <span class="keyword">if</span> (dvmDexFileOpenPartial(dexAddr, dexLength, &amp;pDvmDex) != <span class="number">0</span>) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;Unable to create DexFile&quot;</span>);</span><br><span class="line">                success = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * If configured to do so, generate register map output</span></span><br><span class="line"><span class="comment">                 * for all verified classes.  The register maps were</span></span><br><span class="line"><span class="comment">                 * generated during verification, and will now be serialized.</span></span><br><span class="line"><span class="comment">                 * 填充辅助数据区的结构</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (gDvm.generateRegisterMaps) &#123;</span><br><span class="line">                    pRegMapBuilder = dvmGenerateRegisterMaps(pDvmDex);</span><br><span class="line">                    <span class="keyword">if</span> (pRegMapBuilder == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        ALOGE(<span class="string">&quot;Failed generating register maps&quot;</span>);</span><br><span class="line">                        success = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                DexHeader* pHeader = (DexHeader*)pDvmDex-&gt;pHeader;</span><br><span class="line">                  <span class="comment">/* 重写dex的checksum值 */</span></span><br><span class="line">                updateChecksum(dexAddr, dexLength, pHeader);</span><br><span class="line"></span><br><span class="line">                dvmDexFileFree(pDvmDex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">                ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着看看重写文件的rewriteDex函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">rewriteDex</span><span class="params">(u1* addr, <span class="keyword">int</span> len, <span class="keyword">bool</span> doVerify, <span class="keyword">bool</span> doOpt,</span></span></span><br><span class="line"><span class="function"><span class="params">    DexClassLookup** ppClassLookup, DvmDex** ppDvmDex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DexClassLookup* pClassLookup = <span class="literal">NULL</span>;</span><br><span class="line">    u8 prepWhen, loadWhen, verifyOptWhen;</span><br><span class="line">    DvmDex* pDvmDex = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* msgStr = <span class="string">&quot;???&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 字节排序 */</span></span><br><span class="line">    <span class="keyword">if</span> (dexSwapAndVerify(addr, len) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 创建dexfile结构</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (dvmDexFileOpenPartial(addr, len, &amp;pDvmDex) != <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Unable to create DexFile&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Create the class lookup table.  This will eventually be appended</span></span><br><span class="line"><span class="comment">     * to the end of the .odex.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * We create a temporary link from the DexFile for the benefit of</span></span><br><span class="line"><span class="comment">     * class loading, below.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    pClassLookup = dexCreateClassLookup(pDvmDex-&gt;pDexFile);</span><br><span class="line">    <span class="keyword">if</span> (pClassLookup == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    pDvmDex-&gt;pDexFile-&gt;pClassLookup = pClassLookup;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If we&#x27;re not going to attempt to verify or optimize the classes,</span></span><br><span class="line"><span class="comment">     * there&#x27;s no value in loading them, so bail out early.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!doVerify &amp;&amp; !doOpt) &#123;</span><br><span class="line">        result = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prepWhen = dvmGetRelativeTimeUsec();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Load all classes found in this DEX file.  If they fail to load for</span></span><br><span class="line"><span class="comment">     * some reason, they won&#x27;t get verified (which is as it should be).</span></span><br><span class="line"><span class="comment">     * 加载dex中的所有类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!loadAllClasses(pDvmDex))</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    loadWhen = dvmGetRelativeTimeUsec();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Create a data structure for use by the bytecode optimizer.</span></span><br><span class="line"><span class="comment">     * We need to look up methods in a few classes, so this may cause</span></span><br><span class="line"><span class="comment">     * a bit of class loading.  We usually do this during VM init, but</span></span><br><span class="line"><span class="comment">     * for dexopt on core.jar the order of operations gets a bit tricky,</span></span><br><span class="line"><span class="comment">     * so we defer it to here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!dvmCreateInlineSubsTable())</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Verify and optimize all classes in the DEX file (command-line</span></span><br><span class="line"><span class="comment">     * options permitting).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This is best-effort, so there&#x27;s really no way for dexopt to</span></span><br><span class="line"><span class="comment">     * fail at this point.</span></span><br><span class="line"><span class="comment">     * 真正处理验证工作的函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    verifyAndOptimizeClasses(pDvmDex-&gt;pDexFile, doVerify, doOpt);</span><br><span class="line">    verifyOptWhen = dvmGetRelativeTimeUsec();</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先继续看看创建DexFile结构的函数dvmDexFileOpenPartial实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dvmDexFileOpenPartial</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* addr, <span class="keyword">int</span> len, DvmDex** ppDvmDex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    <span class="comment">/* 解析Dex文件 */</span></span><br><span class="line">    pDexFile = dexFileParse((u1*)addr, len, parseFlags);</span><br><span class="line">    <span class="keyword">if</span> (pDexFile == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;DEX parse failed&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">/* 设置与dexfile结构辅助数据相关的字段 */</span></span><br><span class="line">    pDvmDex = allocateAuxStructures(pDexFile);</span><br><span class="line">    <span class="keyword">if</span> (pDvmDex == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        dexFileFree(pDexFile);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pDvmDex-&gt;isMappedReadOnly = <span class="literal">false</span>;</span><br><span class="line">    *ppDvmDex = pDvmDex;</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">bail:</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看解析dex文件的函数dexFileParse</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DexFile* <span class="title">dexFileParse</span><span class="params">(<span class="keyword">const</span> u1* data, <span class="keyword">size_t</span> length, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; kDexParseVerifyChecksum) &#123;</span><br><span class="line">          <span class="comment">/* 验证dex文件中的checksum字段 */</span></span><br><span class="line">        u4 adler = dexComputeChecksum(pHeader);</span><br><span class="line">        <span class="keyword">if</span> (adler != pHeader-&gt;checksum) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;ERROR: bad checksum (%08x vs %08x)&quot;</span>,</span><br><span class="line">                adler, pHeader-&gt;checksum);</span><br><span class="line">            <span class="keyword">if</span> (!(flags &amp; kDexParseContinueOnError))</span><br><span class="line">                <span class="keyword">goto</span> bail;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGV(<span class="string">&quot;+++ adler32 checksum (%08x) verified&quot;</span>, adler);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> DexOptHeader* pOptHeader = pDexFile-&gt;pOptHeader;</span><br><span class="line">        <span class="keyword">if</span> (pOptHeader != <span class="literal">NULL</span>) &#123;</span><br><span class="line">              <span class="comment">/* 验证odex文件中的checksum */</span></span><br><span class="line">            adler = dexComputeOptChecksum(pOptHeader);</span><br><span class="line">            <span class="keyword">if</span> (adler != pOptHeader-&gt;checksum) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;ERROR: bad opt checksum (%08x vs %08x)&quot;</span>,</span><br><span class="line">                    adler, pOptHeader-&gt;checksum);</span><br><span class="line">                <span class="keyword">if</span> (!(flags &amp; kDexParseContinueOnError))</span><br><span class="line">                    <span class="keyword">goto</span> bail;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGV(<span class="string">&quot;+++ adler32 opt checksum (%08x) verified&quot;</span>, adler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Verify the SHA-1 digest.  (Normally we don&#x27;t want to do this --</span></span><br><span class="line"><span class="comment">     * the digest is used to uniquely identify the original DEX file, and</span></span><br><span class="line"><span class="comment">     * can&#x27;t be computed for verification after the DEX is byte-swapped</span></span><br><span class="line"><span class="comment">     * and optimized.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (kVerifySignature) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> sha1Digest[kSHA1DigestLen];</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> nonSum = <span class="keyword">sizeof</span>(pHeader-&gt;magic) + <span class="keyword">sizeof</span>(pHeader-&gt;checksum) +</span><br><span class="line">                            kSHA1DigestLen;</span><br><span class="line">                <span class="comment">//signature的验证</span></span><br><span class="line">        dexComputeSHA1Digest(data + nonSum, length - nonSum, sha1Digest);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">memcmp</span>(sha1Digest, pHeader-&gt;signature, kSHA1DigestLen) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> tmpBuf1[kSHA1DigestOutputLen];</span><br><span class="line">            <span class="keyword">char</span> tmpBuf2[kSHA1DigestOutputLen];</span><br><span class="line">            ALOGE(<span class="string">&quot;ERROR: bad SHA1 digest (%s vs %s)&quot;</span>,</span><br><span class="line">                dexSHA1DigestToStr(sha1Digest, tmpBuf1),</span><br><span class="line">                dexSHA1DigestToStr(pHeader-&gt;signature, tmpBuf2));</span><br><span class="line">            <span class="keyword">if</span> (!(flags &amp; kDexParseContinueOnError))</span><br><span class="line">                <span class="keyword">goto</span> bail;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGV(<span class="string">&quot;+++ sha1 digest verified&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后看看是怎么验证checksum的，看函数dexComputeChecksum</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">u4 <span class="title">dexComputeChecksum</span><span class="params">(<span class="keyword">const</span> DexHeader* pHeader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> u1* start = (<span class="keyword">const</span> u1*) pHeader;</span><br><span class="line"></span><br><span class="line">    uLong adler = adler32(<span class="number">0L</span>, Z_NULL, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> nonSum = <span class="keyword">sizeof</span>(pHeader-&gt;magic) + <span class="keyword">sizeof</span>(pHeader-&gt;checksum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (u4) adler32(adler, start + nonSum, pHeader-&gt;fileSize - nonSum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里看到最终是调用的adler32来进行计算。然后计算的逻辑是start是header的地址偏移。header的地址+magic的大小+checksum的大小。就是直接跳过这两个字段。指向第三个字段的位置。数据长度再用整个文件的大小-这两个字段的大小。</p><p>另外再看odex的checksum校验函数dexComputeOptChecksum</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">u4 <span class="title">dexComputeOptChecksum</span><span class="params">(<span class="keyword">const</span> DexOptHeader* pOptHeader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> u1* start = (<span class="keyword">const</span> u1*) pOptHeader + pOptHeader-&gt;depsOffset;</span><br><span class="line">    <span class="keyword">const</span> u1* <span class="built_in">end</span> = (<span class="keyword">const</span> u1*) pOptHeader +</span><br><span class="line">        pOptHeader-&gt;optOffset + pOptHeader-&gt;optLength;</span><br><span class="line"></span><br><span class="line">    uLong adler = adler32(<span class="number">0L</span>, Z_NULL, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (u4) adler32(adler, start, <span class="built_in">end</span> - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑和上面的基本一致，只是取值范围不一样。范围是depsOffset到optOffset+optLength的数据进行adler32。</p><p>然后继续看signature的验证函数。发现直接就是sha1计算。然后传入的参数是dex跳过magic、checksum、signature字段。sha1的结果再和signature对比，不相同就是验证失败</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dexComputeSHA1Digest</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* data, <span class="keyword">size_t</span> length,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">unsigned</span> <span class="keyword">char</span> digest[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SHA1_CTX context;</span><br><span class="line">    SHA1Init(&amp;context);</span><br><span class="line">    SHA1Update(&amp;context, data, length);</span><br><span class="line">    SHA1Final(digest, &amp;context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里再回头去看rewriteDex里面调用的verifyAndOptimizeClasses这个函数，这个是真正执行验证和优化的函数，里面调用了verifyAndOptimizeClass处理单个类的优化和验证</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">verifyAndOptimizeClasses</span><span class="params">(DexFile* pDexFile, <span class="keyword">bool</span> doVerify,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">bool</span> doOpt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u4 count = pDexFile-&gt;pHeader-&gt;classDefsSize;</span><br><span class="line">    u4 idx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; count; idx++) &#123;</span><br><span class="line">        <span class="keyword">const</span> DexClassDef* pClassDef;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* classDescriptor;</span><br><span class="line">        ClassObject* clazz;</span><br><span class="line"></span><br><span class="line">        pClassDef = dexGetClassDef(pDexFile, idx);</span><br><span class="line">        classDescriptor = dexStringByTypeIdx(pDexFile, pClassDef-&gt;classIdx);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* all classes are loaded into the bootstrap class loader */</span></span><br><span class="line">        clazz = dvmLookupClass(classDescriptor, <span class="literal">NULL</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="literal">NULL</span>) &#123;</span><br><span class="line">              <span class="comment">//处理单个类的验证和优化</span></span><br><span class="line">            verifyAndOptimizeClass(pDexFile, clazz, pClassDef, doVerify, doOpt);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> log when in verbose mode</span></span><br><span class="line">            ALOGV(<span class="string">&quot;DexOpt: not optimizing unavailable class &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">                classDescriptor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看verifyAndOptimizeClass单个类的处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">verifyAndOptimizeClass</span><span class="params">(DexFile* pDexFile, ClassObject* clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> DexClassDef* pClassDef, <span class="keyword">bool</span> doVerify, <span class="keyword">bool</span> doOpt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    classDescriptor = dexStringByTypeIdx(pDexFile, pClassDef-&gt;classIdx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 验证</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (doVerify) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dvmVerifyClass(clazz)) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Set the &quot;is preverified&quot; flag in the DexClassDef.  We</span></span><br><span class="line"><span class="comment">             * do it here, rather than in the ClassObject structure,</span></span><br><span class="line"><span class="comment">             * because the DexClassDef is part of the odex file.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            assert((clazz-&gt;accessFlags &amp; JAVA_FLAGS_MASK) ==</span><br><span class="line">                pClassDef-&gt;accessFlags);</span><br><span class="line">            ((DexClassDef*)pClassDef)-&gt;accessFlags |= CLASS_ISPREVERIFIED;</span><br><span class="line">            verified = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> log when in verbose mode</span></span><br><span class="line">            ALOGV(<span class="string">&quot;DexOpt: &#x27;%s&#x27; failed verification&quot;</span>, classDescriptor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">/* 优化 */</span></span><br><span class="line">    <span class="keyword">if</span> (doOpt) &#123;</span><br><span class="line">        <span class="keyword">bool</span> needVerify = (gDvm.dexOptMode == OPTIMIZE_MODE_VERIFIED ||</span><br><span class="line">                           gDvm.dexOptMode == OPTIMIZE_MODE_FULL);</span><br><span class="line">        <span class="keyword">if</span> (!verified &amp;&amp; needVerify) &#123;</span><br><span class="line">            ALOGV(<span class="string">&quot;DexOpt: not optimizing &#x27;%s&#x27;: not verified&quot;</span>,</span><br><span class="line">                classDescriptor);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dvmOptimizeClass(clazz, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* set the flag whether or not we actually changed anything */</span></span><br><span class="line">            ((DexClassDef*)pClassDef)-&gt;accessFlags |= CLASS_ISOPTIMIZED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看处理验证的函数dvmVerifyClass</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dvmVerifyClass</span><span class="params">(ClassObject* clazz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dvmIsClassVerified(clazz)) &#123;</span><br><span class="line">        ALOGD(<span class="string">&quot;Ignoring duplicate verify attempt on %s&quot;</span>, clazz-&gt;descriptor);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//遍历所有直接方法进行验证</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; clazz-&gt;directMethodCount; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!verifyMethod(&amp;clazz-&gt;directMethods[i])) &#123;</span><br><span class="line">            LOG_VFY(<span class="string">&quot;Verifier rejected class %s&quot;</span>, clazz-&gt;descriptor);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">//遍历所有虚方法进行验证</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; clazz-&gt;virtualMethodCount; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!verifyMethod(&amp;clazz-&gt;virtualMethods[i])) &#123;</span><br><span class="line">            LOG_VFY(<span class="string">&quot;Verifier rejected class %s&quot;</span>, clazz-&gt;descriptor);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看验证的函数verifyMethod</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">verifyMethod</span><span class="params">(Method* meth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Verifier state blob.  Various values will be cached here so we</span></span><br><span class="line"><span class="comment">     * can avoid expensive lookups and pass fewer arguments around.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    VerifierData vdata;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1   <span class="comment">// ndef NDEBUG</span></span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;vdata, <span class="number">0x99</span>, <span class="keyword">sizeof</span>(vdata));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    vdata.method = meth;</span><br><span class="line">    vdata.insnsSize = dvmGetMethodInsnsSize(meth);</span><br><span class="line">    vdata.insnRegCount = meth-&gt;registersSize;</span><br><span class="line">    vdata.insnFlags = <span class="literal">NULL</span>;</span><br><span class="line">    vdata.uninitMap = <span class="literal">NULL</span>;</span><br><span class="line">    vdata.basicBlocks = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If there aren&#x27;t any instructions, make sure that&#x27;s expected, then</span></span><br><span class="line"><span class="comment">     * exit successfully.  Note: for native methods, meth-&gt;insns gets set</span></span><br><span class="line"><span class="comment">     * to a native function pointer on first call, so don&#x27;t use that as</span></span><br><span class="line"><span class="comment">     * an indicator.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (vdata.insnsSize == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dvmIsNativeMethod(meth) &amp;&amp; !dvmIsAbstractMethod(meth)) &#123;</span><br><span class="line">            LOG_VFY_METH(meth,</span><br><span class="line">                <span class="string">&quot;VFY: zero-length code in concrete non-native method&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> bail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">goto</span> success;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Sanity-check the register counts.  ins + locals = registers, so make</span></span><br><span class="line"><span class="comment">     * sure that ins &lt;= registers.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (meth-&gt;insSize &gt; meth-&gt;registersSize) &#123;</span><br><span class="line">        LOG_VFY_METH(meth, <span class="string">&quot;VFY: bad register counts (ins=%d regs=%d)&quot;</span>,</span><br><span class="line">            meth-&gt;insSize, meth-&gt;registersSize);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Allocate and populate an array to hold instruction data.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">TODO:</span> Consider keeping a reusable pre-allocated array sitting</span></span><br><span class="line"><span class="comment">     * around for smaller methods.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    vdata.insnFlags = (InsnFlags*) <span class="built_in">calloc</span>(vdata.insnsSize, <span class="keyword">sizeof</span>(InsnFlags));</span><br><span class="line">    <span class="keyword">if</span> (vdata.insnFlags == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Compute the width of each instruction and store the result in insnFlags.</span></span><br><span class="line"><span class="comment">     * Count up the #of occurrences of certain opcodes while we&#x27;re at it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!computeWidthsAndCountOps(&amp;vdata))</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Allocate a map to hold the classes of uninitialized instances.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    vdata.uninitMap = dvmCreateUninitInstanceMap(meth, vdata.insnFlags,</span><br><span class="line">        vdata.newInstanceCount);</span><br><span class="line">    <span class="keyword">if</span> (vdata.uninitMap == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Set the &quot;in try&quot; flags for all instructions guarded by a &quot;try&quot; block.</span></span><br><span class="line"><span class="comment">     * Also sets the &quot;branch target&quot; flag on exception handlers.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!scanTryCatchBlocks(meth, vdata.insnFlags))</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Perform static instruction verification.  Also sets the &quot;branch</span></span><br><span class="line"><span class="comment">     * target&quot; flags.</span></span><br><span class="line"><span class="comment">     * 验证方法中指令的数量以及正确性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!verifyInstructions(&amp;vdata))</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Do code-flow analysis.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * We could probably skip this for a method with no registers, but</span></span><br><span class="line"><span class="comment">     * that&#x27;s so rare that there&#x27;s little point in checking.</span></span><br><span class="line"><span class="comment">     * 验证代码流的正确性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!dvmVerifyCodeFlow(&amp;vdata)) &#123;</span><br><span class="line">        <span class="comment">//ALOGD(&quot;+++ %s failed code flow&quot;, meth-&gt;name);</span></span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">success:</span><br><span class="line">    result = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">bail:</span><br><span class="line">    dvmFreeVfyBasicBlocks(&amp;vdata);</span><br><span class="line">    dvmFreeUninitInstanceMap(vdata.uninitMap);</span><br><span class="line">    <span class="built_in">free</span>(vdata.insnFlags);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完验证的流程再看看优化的处理函数dvmOptimizeClass</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dvmOptimizeClass</span><span class="params">(ClassObject* clazz, <span class="keyword">bool</span> essentialOnly)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; clazz-&gt;directMethodCount; i++) &#123;</span><br><span class="line">        optimizeMethod(&amp;clazz-&gt;directMethods[i], essentialOnly);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; clazz-&gt;virtualMethodCount; i++) &#123;</span><br><span class="line">        optimizeMethod(&amp;clazz-&gt;virtualMethods[i], essentialOnly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用optimizeMethod函数优化所有直接函数和虚函数。代码实现如下。主要是进行指令的替换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">optimizeMethod</span><span class="params">(Method* method, <span class="keyword">bool</span> essentialOnly)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> needRetBar, forSmp;</span><br><span class="line">    u4 insnsSize;</span><br><span class="line">    u2* insns;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dvmIsNativeMethod(method) || dvmIsAbstractMethod(method))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    forSmp = gDvm.dexOptForSmp;</span><br><span class="line">    needRetBar = needsReturnBarrier(method);</span><br><span class="line"></span><br><span class="line">    insns = (u2*) method-&gt;insns;</span><br><span class="line">    assert(insns != <span class="literal">NULL</span>);</span><br><span class="line">    insnsSize = dvmGetMethodInsnsSize(method);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (insnsSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Opcode opc, quickOpc, volatileOpc;</span><br><span class="line">        <span class="keyword">size_t</span> <span class="built_in">width</span>;</span><br><span class="line">        <span class="keyword">bool</span> matched = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        opc = dexOpcodeFromCodeUnit(*insns);</span><br><span class="line">        <span class="built_in">width</span> = dexGetWidthFromInstruction(insns);</span><br><span class="line">        volatileOpc = OP_NOP;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Each instruction may have:</span></span><br><span class="line"><span class="comment">         * - &quot;volatile&quot; replacement</span></span><br><span class="line"><span class="comment">         *   - may be essential or essential-on-SMP</span></span><br><span class="line"><span class="comment">         * - correctness replacement</span></span><br><span class="line"><span class="comment">         *   - may be essential or essential-on-SMP</span></span><br><span class="line"><span class="comment">         * - performance replacement</span></span><br><span class="line"><span class="comment">         *   - always non-essential</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Replacements are considered in the order shown, and the first</span></span><br><span class="line"><span class="comment">         * match is applied.  For example, iget-wide will convert to</span></span><br><span class="line"><span class="comment">         * iget-wide-volatile rather than iget-wide-quick if the target</span></span><br><span class="line"><span class="comment">         * field is volatile.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * essential substitutions:</span></span><br><span class="line"><span class="comment">         *  &#123;iget,iput,sget,sput&#125;-wide --&gt; &#123;op&#125;-wide-volatile</span></span><br><span class="line"><span class="comment">         *  invoke-direct[/range] --&gt; invoke-object-init/range</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * essential-on-SMP substitutions:</span></span><br><span class="line"><span class="comment">         *  &#123;iget,iput,sget,sput&#125;-* --&gt; &#123;op&#125;-volatile</span></span><br><span class="line"><span class="comment">         *  return-void --&gt; return-void-barrier</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * non-essential substitutions:</span></span><br><span class="line"><span class="comment">         *  &#123;iget,iput&#125;-* --&gt; &#123;op&#125;-quick</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">TODO:</span> might be time to merge this with the other two switches</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">switch</span> (opc) &#123;</span><br><span class="line">        <span class="keyword">case</span> OP_IGET:</span><br><span class="line">        <span class="keyword">case</span> OP_IGET_BOOLEAN:</span><br><span class="line">        <span class="keyword">case</span> OP_IGET_BYTE:</span><br><span class="line">        <span class="keyword">case</span> OP_IGET_CHAR:</span><br><span class="line">        <span class="keyword">case</span> OP_IGET_SHORT:</span><br><span class="line">            quickOpc = OP_IGET_QUICK;</span><br><span class="line">            <span class="keyword">if</span> (forSmp)</span><br><span class="line">                volatileOpc = OP_IGET_VOLATILE;</span><br><span class="line">            <span class="keyword">goto</span> rewrite_inst_field;</span><br><span class="line">        <span class="keyword">case</span> OP_IGET_WIDE:</span><br><span class="line">            quickOpc = OP_IGET_WIDE_QUICK;</span><br><span class="line">            volatileOpc = OP_IGET_WIDE_VOLATILE;</span><br><span class="line">            <span class="keyword">goto</span> rewrite_inst_field;</span><br><span class="line">        <span class="keyword">case</span> OP_IGET_OBJECT:</span><br><span class="line">            quickOpc = OP_IGET_OBJECT_QUICK;</span><br><span class="line">            <span class="keyword">if</span> (forSmp)</span><br><span class="line">                volatileOpc = OP_IGET_OBJECT_VOLATILE;</span><br><span class="line">            <span class="keyword">goto</span> rewrite_inst_field;</span><br><span class="line">        <span class="keyword">case</span> OP_IPUT:</span><br><span class="line">        <span class="keyword">case</span> OP_IPUT_BOOLEAN:</span><br><span class="line">        <span class="keyword">case</span> OP_IPUT_BYTE:</span><br><span class="line">        <span class="keyword">case</span> OP_IPUT_CHAR:</span><br><span class="line">        <span class="keyword">case</span> OP_IPUT_SHORT:</span><br><span class="line">            quickOpc = OP_IPUT_QUICK;</span><br><span class="line">            <span class="keyword">if</span> (forSmp)</span><br><span class="line">                volatileOpc = OP_IPUT_VOLATILE;</span><br><span class="line">            <span class="keyword">goto</span> rewrite_inst_field;</span><br><span class="line">        <span class="keyword">case</span> OP_IPUT_WIDE:</span><br><span class="line">            quickOpc = OP_IPUT_WIDE_QUICK;</span><br><span class="line">            volatileOpc = OP_IPUT_WIDE_VOLATILE;</span><br><span class="line">            <span class="keyword">goto</span> rewrite_inst_field;</span><br><span class="line">        <span class="keyword">case</span> OP_IPUT_OBJECT:</span><br><span class="line">            quickOpc = OP_IPUT_OBJECT_QUICK;</span><br><span class="line">            <span class="keyword">if</span> (forSmp)</span><br><span class="line">                volatileOpc = OP_IPUT_OBJECT_VOLATILE;</span><br><span class="line">            <span class="comment">/* fall through */</span></span><br><span class="line">rewrite_inst_field:</span><br><span class="line">            <span class="keyword">if</span> (essentialOnly)</span><br><span class="line">                quickOpc = OP_NOP;      <span class="comment">/* if essential-only, no &quot;-quick&quot; sub */</span></span><br><span class="line">            <span class="keyword">if</span> (quickOpc != OP_NOP || volatileOpc != OP_NOP)</span><br><span class="line">                rewriteInstField(method, insns, quickOpc, volatileOpc);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OP_SGET:</span><br><span class="line">        <span class="keyword">case</span> OP_SGET_BOOLEAN:</span><br><span class="line">        <span class="keyword">case</span> OP_SGET_BYTE:</span><br><span class="line">        <span class="keyword">case</span> OP_SGET_CHAR:</span><br><span class="line">        <span class="keyword">case</span> OP_SGET_SHORT:</span><br><span class="line">            <span class="keyword">if</span> (forSmp)</span><br><span class="line">                volatileOpc = OP_SGET_VOLATILE;</span><br><span class="line">            <span class="keyword">goto</span> rewrite_static_field;</span><br><span class="line">        <span class="keyword">case</span> OP_SGET_WIDE:</span><br><span class="line">            volatileOpc = OP_SGET_WIDE_VOLATILE;</span><br><span class="line">            <span class="keyword">goto</span> rewrite_static_field;</span><br><span class="line">        <span class="keyword">case</span> OP_SGET_OBJECT:</span><br><span class="line">            <span class="keyword">if</span> (forSmp)</span><br><span class="line">                volatileOpc = OP_SGET_OBJECT_VOLATILE;</span><br><span class="line">            <span class="keyword">goto</span> rewrite_static_field;</span><br><span class="line">        <span class="keyword">case</span> OP_SPUT:</span><br><span class="line">        <span class="keyword">case</span> OP_SPUT_BOOLEAN:</span><br><span class="line">        <span class="keyword">case</span> OP_SPUT_BYTE:</span><br><span class="line">        <span class="keyword">case</span> OP_SPUT_CHAR:</span><br><span class="line">        <span class="keyword">case</span> OP_SPUT_SHORT:</span><br><span class="line">            <span class="keyword">if</span> (forSmp)</span><br><span class="line">                volatileOpc = OP_SPUT_VOLATILE;</span><br><span class="line">            <span class="keyword">goto</span> rewrite_static_field;</span><br><span class="line">        <span class="keyword">case</span> OP_SPUT_WIDE:</span><br><span class="line">            volatileOpc = OP_SPUT_WIDE_VOLATILE;</span><br><span class="line">            <span class="keyword">goto</span> rewrite_static_field;</span><br><span class="line">        <span class="keyword">case</span> OP_SPUT_OBJECT:</span><br><span class="line">            <span class="keyword">if</span> (forSmp)</span><br><span class="line">                volatileOpc = OP_SPUT_OBJECT_VOLATILE;</span><br><span class="line">            <span class="comment">/* fall through */</span></span><br><span class="line">rewrite_static_field:</span><br><span class="line">            <span class="keyword">if</span> (volatileOpc != OP_NOP)</span><br><span class="line">                rewriteStaticField(method, insns, volatileOpc);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OP_INVOKE_DIRECT:</span><br><span class="line">        <span class="keyword">case</span> OP_INVOKE_DIRECT_RANGE:</span><br><span class="line">            <span class="keyword">if</span> (!rewriteInvokeObjectInit(method, insns)) &#123;</span><br><span class="line">                <span class="comment">/* may want to try execute-inline, below */</span></span><br><span class="line">                matched = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_RETURN_VOID:</span><br><span class="line">            <span class="keyword">if</span> (needRetBar)</span><br><span class="line">                rewriteReturnVoid(method, insns);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            matched = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * non-essential substitutions:</span></span><br><span class="line"><span class="comment">         *  invoke-&#123;virtual,direct,static&#125;[/range] --&gt; execute-inline</span></span><br><span class="line"><span class="comment">         *  invoke-&#123;virtual,super&#125;[/range] --&gt; invoke-*-quick</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!matched &amp;&amp; !essentialOnly) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (opc) &#123;</span><br><span class="line">            <span class="keyword">case</span> OP_INVOKE_VIRTUAL:</span><br><span class="line">                <span class="keyword">if</span> (!rewriteExecuteInline(method, insns, METHOD_VIRTUAL)) &#123;</span><br><span class="line">                    rewriteVirtualInvoke(method, insns,</span><br><span class="line">                        OP_INVOKE_VIRTUAL_QUICK);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_INVOKE_VIRTUAL_RANGE:</span><br><span class="line">                <span class="keyword">if</span> (!rewriteExecuteInlineRange(method, insns, METHOD_VIRTUAL)) &#123;</span><br><span class="line">                    rewriteVirtualInvoke(method, insns,</span><br><span class="line">                        OP_INVOKE_VIRTUAL_QUICK_RANGE);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_INVOKE_SUPER:</span><br><span class="line">                rewriteVirtualInvoke(method, insns, OP_INVOKE_SUPER_QUICK);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_INVOKE_SUPER_RANGE:</span><br><span class="line">                rewriteVirtualInvoke(method, insns, OP_INVOKE_SUPER_QUICK_RANGE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_INVOKE_DIRECT:</span><br><span class="line">                rewriteExecuteInline(method, insns, METHOD_DIRECT);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_INVOKE_DIRECT_RANGE:</span><br><span class="line">                rewriteExecuteInlineRange(method, insns, METHOD_DIRECT);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_INVOKE_STATIC:</span><br><span class="line">                rewriteExecuteInline(method, insns, METHOD_STATIC);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_INVOKE_STATIC_RANGE:</span><br><span class="line">                rewriteExecuteInlineRange(method, insns, METHOD_STATIC);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">/* nothing to do for this instruction */</span></span><br><span class="line">                ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        assert(<span class="built_in">width</span> &gt; <span class="number">0</span>);</span><br><span class="line">        assert(<span class="built_in">width</span> &lt;= insnsSize);</span><br><span class="line">        assert(<span class="built_in">width</span> == dexGetWidthFromInstruction(insns));</span><br><span class="line"></span><br><span class="line">        insns += <span class="built_in">width</span>;</span><br><span class="line">        insnsSize -= <span class="built_in">width</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(insnsSize == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解完整个dex的验证流程后，我们就可以修改dex后，自己制作工具修复dex的checksum和signature了。当然也有现成的工具帮我们修复这个dex的验证的。d2j-dex-recompute-checksum</p><p><code>./d2j-dex-recompute-checksum.sh -f ./Hello.dex</code></p><p>然后生成出Hello-rechecksum.dex文件。替换原来的dex即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> android基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>菜鸟学飞之frida整合怪</title>
      <link href="/2021/06/24/fridatools/"/>
      <url>/2021/06/24/fridatools/</url>
      
        <content type="html"><![CDATA[<p>入行两年了，从刚开始的丝毫不懂。到现在的蹒跚学步，可谓是一步一个脚印走过来的。当然现在依然还是菜鸟一只。但是比起两年前茫然不知学习方向来说，现在有了明确前进的目标，只要不停下脚本，终有一天能飞上枝头成为合格的老鸟。下面整理了一些我的学习方式。希望能够帮到和曾经的我一样茫然的萌新。</p><h3 id="1、阅读书籍"><a href="#1、阅读书籍" class="headerlink" title="1、阅读书籍"></a>1、阅读书籍</h3><p>最核心的基础大多是在书中有详细的介绍。看书一般不是只读一遍。我个人的方式是先大致的过一遍，每页都粗略的翻一遍，过完一遍就能大概知道哪些内容以自己目前的知识量，很难看明白，哪些是自己熟悉但是却理解不深的。然后第二遍才开始细翻，暂时跳过很难读懂的，先做个标记，以后知识面广了。再回过头来看。简单推荐几本《android软件安全权威指南》、《android应用安全防护和逆向分析》、《深入理解android java虚拟机ART》、《深入理解计算机系统》</p><a id="more"></a><h3 id="2、论坛"><a href="#2、论坛" class="headerlink" title="2、论坛"></a>2、论坛</h3><p>很多大佬都会发些实战的帖子。还有一些工具的使用。还有各种经验之谈。看书相当于是闭门造车，单靠自己的摸索的路是非常艰难的。站在巨人的肩膀上才能前进的更快。我最早先啥也不懂。就是看着大佬们的帖子渐渐入门。然后慢慢的才能看的懂书籍。</p><h3 id="3、培训"><a href="#3、培训" class="headerlink" title="3、培训"></a>3、培训</h3><p>我经历过很多次培训，2011年培训前我本职是修电脑的。在北京培训了asp.net然后入行做网站。2016年我在广州培训c++然后转行做游戏。2018年自学后转行做安全，然后发现基础特烂，有些问题稍微变一点就很难自己解决。2020年又报了看雪的2w和3w班。关于培训很多人有各种说法，只能说是智者见智，仁者见仁。不能以一概全。至少我觉得物有所值，如果你缺乏自制力，或者自学很久也不见成效。可以找合适的线上课程试试。</p><h3 id="4、开源项目"><a href="#4、开源项目" class="headerlink" title="4、开源项目"></a>4、开源项目</h3><p>github说它是公认最大的学习网站，应该不过分把？很多时候，伟大的前人，早就踩过了数不清的弯路，然后他们为我们铺平了道路。感谢开源精神，让知识遍地开花结果。当使用一些优秀的工具时，我们可以阅读源码，看看是如何实现的，熟悉代码后，完全根据自己的使用场景来修改bug，或者做一些优化。如果对底层非常熟悉，甚至可以看穿作者的核心思路，知道核心实现的原理。</p><h3 id="5、个人博客"><a href="#5、个人博客" class="headerlink" title="5、个人博客"></a>5、个人博客</h3><p>学习这么久，最吃亏的就是好多看过的东西，久久不用，基本都忘干净了。但是如果在当时，有详细的记录整个思路的话，翻一翻还是可以捡的回来。个人博客的存在我觉得其实很像是一个线上的笔记簿。可以随时在任意地方翻看。而且现在markdown的风格也很漂亮，我是用hexo搭建的个人博客，空间是github的免费空间。写笔记的时候记住一个要点，这个记录的第一目标客户是未来的自己。为了确保自己肯定看的懂，要尽量的详细。</p><h3 id="6、练手和实战"><a href="#6、练手和实战" class="headerlink" title="6、练手和实战"></a>6、练手和实战</h3><p>学习了新的知识点后，一般会自己做个正向的apk练手。或者是拿别人的crashMe之类的来练手。当我们前置知识准备的差不多了，就可以拿一些自己常用的软件来进行练手。比如说某色流app。或者是某小说软件去广告。不论最后能否成功达到目的，主要是在实战逆向中的一些见识，总结碰到的问题，最后如何解决的。如果解决不了，那又是因为什么因素。结果不重要，重要的是过程中的收获。</p><h2 id="fridaUiTools整合怪"><a href="#fridaUiTools整合怪" class="headerlink" title="fridaUiTools整合怪"></a>fridaUiTools整合怪</h2><hr><blockquote><p> 整合工具开发，我觉得是一种比较高效的学习方式。将别人优秀的项目魔改，并且进行一定的拼合，整理成一个成套的工具。在整理的过程中，必然要熟悉对方的代码，并且对部分代码进行调整。在这个过程中，就能快速汲取到他人的经验。这种行为。就是所谓的整合怪/缝合怪了。</p></blockquote><p>fridaUiTools主要是把一些常用的frida的hook脚本简单统一输出方式后，整合进来。并且将自己觉得常用的功能做成界面调用的。并且在附加进程成功时获取一些信息默认的直接展示。后续会根据自己实战的经验。不断完善这个工具。</p><p>一直想做一个frida的脚本整理工具，有很多化腐朽为神奇的脚本由于常年不使用，自己都忘记了，觉得应该有一个工具把这些东西统一起来调用，因为常年使用win系统。导致我倾向于界面化的工具。我个人感觉。界面化的至少不用再记命令。操作也方便。然后我直接参考ZenTracer，在他的原理上，重新对整体的流程以及界面和功能做的更加完善一些。</p><p>我对这个工具整体功能划分为三块。</p><h3 id="1、js脚本的hook和管理（对批量多个脚本同时hook，可以自定义脚本进行管理，可以保存加载。必须是在附加前进行操作）"><a href="#1、js脚本的hook和管理（对批量多个脚本同时hook，可以自定义脚本进行管理，可以保存加载。必须是在附加前进行操作）" class="headerlink" title="1、js脚本的hook和管理（对批量多个脚本同时hook，可以自定义脚本进行管理，可以保存加载。必须是在附加前进行操作）"></a>1、js脚本的hook和管理（对批量多个脚本同时hook，可以自定义脚本进行管理，可以保存加载。必须是在附加前进行操作）</h3><blockquote><ul><li>整合r0capture</li><li>整合jnitrace</li><li>整合ZenTracer</li><li>java层的加解密相关自吐</li><li>ssl证书导出</li><li>ssl pining（整合DroidSSLUnpinning）</li><li>模糊匹配函数进行批量hook（整合ZenTracer）</li><li>模糊匹配so函数批量hook（参数统一方式打印。所以输出只能做参考）</li><li>native的sub函数批量hook（参数统一方式打印。所以输出只能做参考）</li><li>stalker的trace</li><li>脱壳相关（整合frida_dump、FRIDA-DEXDump、fart）</li><li>自定义脚本添加 （todo 待开发）</li><li>patch汇编代码 （todo 待开发）</li></ul></blockquote><h3 id="2、常用功能的调用（常见的内存漫游操作进行功能化，以后再根据实战需求增加新功能。必须是在附加后进行操作）"><a href="#2、常用功能的调用（常见的内存漫游操作进行功能化，以后再根据实战需求增加新功能。必须是在附加后进行操作）" class="headerlink" title="2、常用功能的调用（常见的内存漫游操作进行功能化，以后再根据实战需求增加新功能。必须是在附加后进行操作）"></a>2、常用功能的调用（常见的内存漫游操作进行功能化，以后再根据实战需求增加新功能。必须是在附加后进行操作）</h3><blockquote><ul><li>fart主动调用</li><li>DUMPDex主动调用</li><li>dump打印指定地址</li><li>dump指定模块</li><li>wallBreak整合</li></ul></blockquote><h3 id="3、初始化信息"><a href="#3、初始化信息" class="headerlink" title="3、初始化信息"></a>3、初始化信息</h3><blockquote><ul><li>附加进程成功后，将一些常用的信息在界面展示，目前只处理了module列表和class列表。以后再根据需求增加新的信息</li></ul></blockquote><h3 id="github："><a href="#github：" class="headerlink" title="github："></a>github：</h3><blockquote><p><a href="https://github.com/dqzg12300/fridaUiTools">fridaUiTools</a></p></blockquote><p><em><strong>重点并不是开发整合工具的流程，而是学习并利用别人的项目的过程，所以下面主要是分析我整合用到的项目。</strong></em></p><h2 id="ZenTracer"><a href="#ZenTracer" class="headerlink" title="ZenTracer"></a>ZenTracer</h2><hr><h3 id="github：-1"><a href="#github：-1" class="headerlink" title="github："></a>github：</h3><blockquote><p><strong><a href="https://github.com/hluwa/ZenTracer">ZenTracer</a></strong></p></blockquote><h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h3><blockquote><p>界面化的批量hook多个类，可以通过拉黑过滤掉一些调用率特别高的类</p></blockquote><h3 id="实现原理："><a href="#实现原理：" class="headerlink" title="实现原理："></a>实现原理：</h3><blockquote><p>在js脚本中使用占位符{MATCHREGEX}和{BLACKREGEX}在后续替换，来传递参数需要批量trace的类名以及黑名单。遍历所有类匹配出符合要求的类名。并且不在黑名单中。则进行批量hook。批量hook时会将函数所有重载都hook上。最后是三种输出方式，正常的log输出、函数进入时的参数输出、函数结束时的返回值输出。</p></blockquote><h3 id="核心代码（简略）："><a href="#核心代码（简略）：" class="headerlink" title="核心代码（简略）："></a>核心代码（简略）：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量hook</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traceClass</span>(<span class="params">clsname</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> target = Java.use(clsname);</span><br><span class="line">          <span class="comment">//获取本类所有函数（注意getMethods这个是获取本类和父类中的函数。）</span></span><br><span class="line">        <span class="keyword">var</span> methods = target.class.getDeclaredMethods();</span><br><span class="line">        methods.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> methodName = method.getName();</span><br><span class="line">              <span class="comment">//获取所有重载</span></span><br><span class="line">            <span class="keyword">var</span> overloads = target[methodName].overloads;</span><br><span class="line">            overloads.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">overload</span>) </span>&#123;</span><br><span class="line">                  <span class="comment">//参数的类型</span></span><br><span class="line">                <span class="keyword">var</span> proto = <span class="string">&quot;(&quot;</span>;</span><br><span class="line">                overload.argumentTypes.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">                    proto += type.className + <span class="string">&quot;, &quot;</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">if</span> (proto.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    proto = proto.substr(<span class="number">0</span>, proto.length - <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                proto += <span class="string">&quot;)&quot;</span>;</span><br><span class="line">                log(<span class="string">&quot;hooking: &quot;</span> + clsname + <span class="string">&quot;.&quot;</span> + methodName + proto);</span><br><span class="line">                  <span class="comment">//hook 函数</span></span><br><span class="line">                overload.implementation = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">var</span> args = [];</span><br><span class="line">                    <span class="keyword">var</span> tid = getTid();</span><br><span class="line">                    <span class="keyword">var</span> tName = getTName();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="built_in">arguments</span>.length; j++) &#123;</span><br><span class="line">                        args[j] = <span class="built_in">arguments</span>[j] + <span class="string">&quot;&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                      <span class="comment">//函数进入时的参数啥的在里面通过send传给py</span></span><br><span class="line">                    enter(tid, tName, clsname, methodName + proto, args);</span><br><span class="line">                    <span class="keyword">var</span> retval = <span class="built_in">this</span>[methodName].apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">                      <span class="comment">//函数结束时的返回值在里面通过send传给py</span></span><br><span class="line">                    exit(tid, <span class="string">&quot;&quot;</span> + retval);</span><br><span class="line">                    <span class="keyword">return</span> retval;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        log(<span class="string">&quot;&#x27;&quot;</span> + clsname + <span class="string">&quot;&#x27; hook fail: &quot;</span> + e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//匹配符合要求的类。并且不在黑名单中的</span></span><br><span class="line"><span class="keyword">if</span> (Java.available) &#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        log(<span class="string">&#x27;ZenTracer Start...&#x27;</span>);</span><br><span class="line">          <span class="comment">//在js被读取时，会替换这里的数据</span></span><br><span class="line">        <span class="keyword">var</span> matchRegEx = &#123;MATCHREGEX&#125;;</span><br><span class="line">        <span class="keyword">var</span> blackRegEx = &#123;BLACKREGEX&#125;;</span><br><span class="line">        Java.enumerateLoadedClasses(&#123;</span><br><span class="line">            onMatch: <span class="function"><span class="keyword">function</span> (<span class="params">aClass</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> matchRegEx) &#123;</span><br><span class="line">                    <span class="comment">// console.log(matchRegEx[index]);</span></span><br><span class="line">                    <span class="keyword">if</span> (match(matchRegEx[index], aClass)) &#123;</span><br><span class="line">                        <span class="keyword">var</span> is_black = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> blackRegEx) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (match(blackRegEx[i], aClass)) &#123;</span><br><span class="line">                                is_black = <span class="literal">true</span>;</span><br><span class="line">                                log(aClass + <span class="string">&quot;&#x27; black by &#x27;&quot;</span> + blackRegEx[i] + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (is_black) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        log(aClass + <span class="string">&quot;&#x27; match by &#x27;&quot;</span> + matchRegEx[index] + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                        traceClass(aClass);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            onComplete: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                log(<span class="string">&quot;Complete.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="改造并整合："><a href="#改造并整合：" class="headerlink" title="改造并整合："></a>改造并整合：</h3><blockquote><p>优化界面显示，优化类名的输入环节。每次附加进程后。都将所有类名都保存下来。这里就可以选择之前缓存下来的所有类数据。然后根据输入智能过滤。可以快捷方便的找到自己想要hook的类。快捷添加操作。将经常要hook的类放在里面。就可以迅速的hook了。</p></blockquote><h3 id="相关贴图："><a href="#相关贴图：" class="headerlink" title="相关贴图："></a>相关贴图：</h3><p><img src="/2021/06/24/fridatools/image-20210619205558276.png" alt="image-20210619205558276"></p><h2 id="r0capture"><a href="#r0capture" class="headerlink" title="r0capture"></a>r0capture</h2><hr><h3 id="github：-2"><a href="#github：-2" class="headerlink" title="github："></a>github：</h3><blockquote><p><a href="https://github.com/r0ysue/r0capture">r0capture</a></p></blockquote><h3 id="功能：-1"><a href="#功能：-1" class="headerlink" title="功能："></a>功能：</h3><blockquote><p>安卓应用抓包的通杀脚本。并且可以过证书校验解绑定ssl pining。可以导出客户端ssl证书。可以导出pcap文件</p></blockquote><h3 id="实现原理：-1"><a href="#实现原理：-1" class="headerlink" title="实现原理："></a>实现原理：</h3><blockquote><p>通过分析http https tcp udp ssl的系统框架或者第三方框架的调用流程。找到底层调用的地方进行hook。就可以在一定程度上通杀了。关于调用流程的分析的详细过程可以看看我之前整理的另一篇文章<a href="https://bbs.pediy.com/thread-267940.htm">android抓包学习的整理和归纳</a>。</p><p>证书的导出是选择一个证书会调用的时机，函数getPrivateKey和函数getCertificateChain。hook后。取出私钥和证书内容。重新设置密码导出新的证书。</p><p>定位sslpinning证书绑定的位置，是通过hook类型File的构造函数，并且打印出调用堆栈。然后在里面匹配证书绑定函数是否在调用链。这是一种技巧。在其他场合同样可以使用类似的技巧来找到关键代码的位置。</p><p>可以将抓包结果保存为pcap数据。便捷于一些擅长使用网卡抓包工具的人导入分析（例如wireshark）。这个关键是需要熟悉网络数据包的组成结构，然后按照格式写入文件。可以参考他的这个顺便学习一下数据包的组成。</p></blockquote><h3 id="核心代码（简略，网络抓包相关的就不贴了，太多了）："><a href="#核心代码（简略，网络抓包相关的就不贴了，太多了）：" class="headerlink" title="核心代码（简略，网络抓包相关的就不贴了，太多了）："></a>核心代码（简略，网络抓包相关的就不贴了，太多了）：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导出证书到指定路径,并使用新密码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">storeP12</span>(<span class="params">pri, p7, p12Path, p12Password</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> X509Certificate = Java.use(<span class="string">&quot;java.security.cert.X509Certificate&quot;</span>)</span><br><span class="line">      <span class="keyword">var</span> p7X509 = Java.cast(p7, X509Certificate);</span><br><span class="line">      <span class="keyword">var</span> chain = Java.array(<span class="string">&quot;java.security.cert.X509Certificate&quot;</span>, [p7X509])</span><br><span class="line">      <span class="keyword">var</span> ks = Java.use(<span class="string">&quot;java.security.KeyStore&quot;</span>).getInstance(<span class="string">&quot;PKCS12&quot;</span>, <span class="string">&quot;BC&quot;</span>);</span><br><span class="line">      ks.load(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">      ks.setKeyEntry(<span class="string">&quot;client&quot;</span>, pri, Java.use(<span class="string">&#x27;java.lang.String&#x27;</span>).$new(p12Password).toCharArray(), chain);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> out = Java.use(<span class="string">&quot;java.io.FileOutputStream&quot;</span>).$new(p12Path);</span><br><span class="line">        ks.store(out, Java.use(<span class="string">&#x27;java.lang.String&#x27;</span>).$new(p12Password).toCharArray())</span><br><span class="line">      &#125; <span class="keyword">catch</span> (exp) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(exp)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在服务器校验客户端的情形下，帮助dump客户端证书，并保存为p12的格式，证书密码为r0ysue</span></span><br><span class="line">    Java.use(<span class="string">&quot;java.security.KeyStore$PrivateKeyEntry&quot;</span>).getPrivateKey.implementation = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> result = <span class="built_in">this</span>.getPrivateKey()</span><br><span class="line">      <span class="keyword">var</span> packageName = Java.use(<span class="string">&quot;android.app.ActivityThread&quot;</span>).currentApplication().getApplicationContext().getPackageName();</span><br><span class="line">      storeP12(<span class="built_in">this</span>.getPrivateKey(), <span class="built_in">this</span>.getCertificate(), <span class="string">&#x27;/sdcard/Download/&#x27;</span> + packageName + uuid(<span class="number">10</span>, <span class="number">16</span>) + <span class="string">&#x27;.p12&#x27;</span>, <span class="string">&#x27;r0ysue&#x27;</span>);</span><br><span class="line">      <span class="keyword">var</span> message = &#123;&#125;;</span><br><span class="line">      message[<span class="string">&quot;function&quot;</span>] = <span class="string">&quot;dumpClinetCertificate=&gt;&quot;</span> + <span class="string">&#x27;/sdcard/Download/&#x27;</span> + packageName + uuid(<span class="number">10</span>, <span class="number">16</span>) + <span class="string">&#x27;.p12&#x27;</span> + <span class="string">&#x27;   pwd: r0ysue&#x27;</span>;</span><br><span class="line">      message[<span class="string">&quot;stack&quot;</span>] = Java.use(<span class="string">&quot;android.util.Log&quot;</span>).getStackTraceString(Java.use(<span class="string">&quot;java.lang.Throwable&quot;</span>).$new());</span><br><span class="line">      <span class="keyword">var</span> data = Memory.alloc(<span class="number">1</span>);</span><br><span class="line">      send(message, Memory.readByteArray(data, <span class="number">1</span>))</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SSLpinning helper 帮助定位证书绑定的关键代码</span></span><br><span class="line">    Java.use(<span class="string">&quot;java.io.File&quot;</span>).$init.overload(<span class="string">&#x27;java.io.File&#x27;</span>, <span class="string">&#x27;java.lang.String&#x27;</span>).implementation = <span class="function"><span class="keyword">function</span> (<span class="params">file, cert</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> result = <span class="built_in">this</span>.$init(file, cert)</span><br><span class="line">      <span class="comment">//打印堆栈</span></span><br><span class="line">      <span class="keyword">var</span> stack = Java.use(<span class="string">&quot;android.util.Log&quot;</span>).getStackTraceString(Java.use(<span class="string">&quot;java.lang.Throwable&quot;</span>).$new());</span><br><span class="line">      <span class="comment">//匹配证书绑定的函数是否在调用链中</span></span><br><span class="line">      <span class="keyword">if</span> (file.getPath().indexOf(<span class="string">&quot;cacert&quot;</span>) &gt;= <span class="number">0</span> &amp;&amp; stack.indexOf(<span class="string">&quot;X509TrustManagerExtensions.checkServerTrusted&quot;</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> message = &#123;&#125;;</span><br><span class="line">        message[<span class="string">&quot;function&quot;</span>] = <span class="string">&quot;SSLpinning position locator =&gt; &quot;</span> + file.getPath() + <span class="string">&quot; &quot;</span> + cert;</span><br><span class="line">        message[<span class="string">&quot;stack&quot;</span>] = stack;</span><br><span class="line">        <span class="keyword">var</span> data = Memory.alloc(<span class="number">1</span>);</span><br><span class="line">        send(message, Memory.readByteArray(data, <span class="number">1</span>))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面是保存到pcap的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_pcap</span>(<span class="params">pcap_file, ssl_session_id, function, src_addr, src_port,</span></span></span><br><span class="line"><span class="function"><span class="params">             dst_addr, dst_port, data</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Writes the captured data to a pcap file.</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">      pcap_file: The opened pcap file.</span></span><br><span class="line"><span class="string">      ssl_session_id: The SSL session ID for the communication.</span></span><br><span class="line"><span class="string">      function: The function that was intercepted (&quot;SSL_read&quot; or &quot;SSL_write&quot;).</span></span><br><span class="line"><span class="string">      src_addr: The source address of the logged packet.</span></span><br><span class="line"><span class="string">      src_port: The source port of the logged packet.</span></span><br><span class="line"><span class="string">      dst_addr: The destination address of the logged packet.</span></span><br><span class="line"><span class="string">      dst_port: The destination port of the logged packet.</span></span><br><span class="line"><span class="string">      data: The decrypted packet data.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    t = time.time()</span><br><span class="line">    <span class="keyword">if</span> ssl_session_id <span class="keyword">not</span> <span class="keyword">in</span> ssl_sessions:</span><br><span class="line">        ssl_sessions[ssl_session_id] = (random.randint(<span class="number">0</span>, <span class="number">0xFFFFFFFF</span>),</span><br><span class="line">                                        random.randint(<span class="number">0</span>, <span class="number">0xFFFFFFFF</span>))</span><br><span class="line">    client_sent, server_sent = ssl_sessions[ssl_session_id]</span><br><span class="line">    <span class="keyword">if</span> function == <span class="string">&quot;SSL_read&quot;</span>:</span><br><span class="line">        seq, ack = (server_sent, client_sent)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        seq, ack = (client_sent, server_sent)</span><br><span class="line">    <span class="keyword">for</span> writes <span class="keyword">in</span> (</span><br><span class="line">            <span class="comment"># PCAP record (packet) header</span></span><br><span class="line">            (<span class="string">&quot;=I&quot;</span>, int(t)),  <span class="comment"># Timestamp seconds</span></span><br><span class="line">            (<span class="string">&quot;=I&quot;</span>, int((t * <span class="number">1000000</span>) % <span class="number">1000000</span>)),  <span class="comment"># Timestamp microseconds</span></span><br><span class="line">            (<span class="string">&quot;=I&quot;</span>, <span class="number">40</span> + len(data)),  <span class="comment"># Number of octets saved</span></span><br><span class="line">            (<span class="string">&quot;=i&quot;</span>, <span class="number">40</span> + len(data)),  <span class="comment"># Actual length of packet</span></span><br><span class="line">            <span class="comment"># IPv4 header</span></span><br><span class="line">            (<span class="string">&quot;&gt;B&quot;</span>, <span class="number">0x45</span>),  <span class="comment"># Version and Header Length</span></span><br><span class="line">            (<span class="string">&quot;&gt;B&quot;</span>, <span class="number">0</span>),  <span class="comment"># Type of Service</span></span><br><span class="line">            (<span class="string">&quot;&gt;H&quot;</span>, <span class="number">40</span> + len(data)),  <span class="comment"># Total Length</span></span><br><span class="line">            (<span class="string">&quot;&gt;H&quot;</span>, <span class="number">0</span>),  <span class="comment"># Identification</span></span><br><span class="line">            (<span class="string">&quot;&gt;H&quot;</span>, <span class="number">0x4000</span>),  <span class="comment"># Flags and Fragment Offset</span></span><br><span class="line">            (<span class="string">&quot;&gt;B&quot;</span>, <span class="number">0xFF</span>),  <span class="comment"># Time to Live</span></span><br><span class="line">            (<span class="string">&quot;&gt;B&quot;</span>, <span class="number">6</span>),  <span class="comment"># Protocol</span></span><br><span class="line">            (<span class="string">&quot;&gt;H&quot;</span>, <span class="number">0</span>),  <span class="comment"># Header Checksum</span></span><br><span class="line">            (<span class="string">&quot;&gt;I&quot;</span>, src_addr),  <span class="comment"># Source Address</span></span><br><span class="line">            (<span class="string">&quot;&gt;I&quot;</span>, dst_addr),  <span class="comment"># Destination Address</span></span><br><span class="line">            <span class="comment"># TCP header</span></span><br><span class="line">            (<span class="string">&quot;&gt;H&quot;</span>, src_port),  <span class="comment"># Source Port</span></span><br><span class="line">            (<span class="string">&quot;&gt;H&quot;</span>, dst_port),  <span class="comment"># Destination Port</span></span><br><span class="line">            (<span class="string">&quot;&gt;I&quot;</span>, seq),  <span class="comment"># Sequence Number</span></span><br><span class="line">            (<span class="string">&quot;&gt;I&quot;</span>, ack),  <span class="comment"># Acknowledgment Number</span></span><br><span class="line">            (<span class="string">&quot;&gt;H&quot;</span>, <span class="number">0x5018</span>),  <span class="comment"># Header Length and Flags</span></span><br><span class="line">            (<span class="string">&quot;&gt;H&quot;</span>, <span class="number">0xFFFF</span>),  <span class="comment"># Window Size</span></span><br><span class="line">            (<span class="string">&quot;&gt;H&quot;</span>, <span class="number">0</span>),  <span class="comment"># Checksum</span></span><br><span class="line">            (<span class="string">&quot;&gt;H&quot;</span>, <span class="number">0</span>)):  <span class="comment"># Urgent Pointer</span></span><br><span class="line">        pcap_file.write(struct.pack(writes[<span class="number">0</span>], writes[<span class="number">1</span>]))</span><br><span class="line">    pcap_file.write(data)</span><br><span class="line">    <span class="keyword">if</span> function == <span class="string">&quot;SSL_read&quot;</span>:</span><br><span class="line">        server_sent += len(data)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        client_sent += len(data)</span><br><span class="line">    ssl_sessions[ssl_session_id] = (client_sent, server_sent)</span><br></pre></td></tr></table></figure><h3 id="改造并整合：-1"><a href="#改造并整合：-1" class="headerlink" title="改造并整合："></a>改造并整合：</h3><blockquote><p>我去掉了pcap的保存，直接调用脚本。把输出方式统一起来（去掉所有js的console.log打印。统一格式send到py进行输出）。其他功能都保持原有的。</p></blockquote><h2 id="jnitrace-JNI-Frida-Hook"><a href="#jnitrace-JNI-Frida-Hook" class="headerlink" title="jnitrace/JNI-Frida-Hook"></a>jnitrace/JNI-Frida-Hook</h2><hr><h3 id="github：-3"><a href="#github：-3" class="headerlink" title="github："></a>github：</h3><blockquote><p><a href="https://github.com/chame1eon/jnitrace">jnitrace</a>/<a href="https://github.com/Areizen/JNI-Frida-Hook">JNI-Frida-Hook</a></p></blockquote><h3 id="功能：-2"><a href="#功能：-2" class="headerlink" title="功能："></a>功能：</h3><blockquote><p>对所有jni的函数进行hook。比如vmp中大量使用到了jni的函数来模拟java的实现。对所有的jni进行hook就可以获得一些线索。</p><p>这里我列了两个项目，是因为这两个我都分析了一下。jnitrace的使用和输出都非常的方便，可以打印jni函数的结构，以及所有参数和返回值，并且代码结构优美，全部用ts实现的，可以说是非常完美的hook脚本开发模式，虽然很香，但是想要整合进来并不容易。我需要的是逻辑清晰易读的js文件来方便的嵌入，并且可以简单的修改。太过复杂庞大的js不利于我整合进来，所以最终选择了简单的JNI-Frida-Hook，这个项目只是简单的hook了jni函数，打印了一下函数名，并没有详细的参数和返回值。我们可以后续再进行优化</p></blockquote><h3 id="实现原理：-2"><a href="#实现原理：-2" class="headerlink" title="实现原理："></a>实现原理：</h3><blockquote><p>hook的js开发比较麻烦的问题是多文件的调用会很难处理。所以jnitrace使用了ts写脚本再生成js来解决。</p><p>而JNI-Frida-Hook直接使用的<code>require(&quot;./utils/jni_struct.js&quot;)</code>。然后再通过<code>frida-compile agent.js -o _agent.js</code>来将多个文件合并。</p><p>这里我就只讲JNI-Frida-Hook的实现了。首先需要设置hook的目标模块library_name以及要监控的目标函数function_name。</p><p>这里他对android_dlopen_ext进行hook。判断目标模块加载完成了，再进行目标函数的hook。如果不这样做，在spwan的附加的时候，就会找不到模块，因为模块还未加载。</p><p>遍历所有export符号，如果有找到设定的目标函数，就进行hook所有jni函数，并且在函数结束时，关掉所有jni函数的hook。</p><p>所有jni函数的hook实现就是准备所有jni函数的名称列表，然后遍历所有，然后hook的时候将jnienv的指针传进来，再根据jni函数名和jnienv的指针进行偏移，找到对应的函数地址。直接hook即可。最后FindClass可能比较特殊，就单独hook了。</p><p>这个项目的关键就是计算偏移，这里只要熟悉类对象结构的存储，再看看jnienv这个类的结构，就看的很明白了，贴一篇我以前写的笔记博文：<a href="http://missking.cc/2020/08/12/ClassStructure/">类对象的内存布局</a></p></blockquote><h3 id="核心代码（简略）：-1"><a href="#核心代码（简略）：-1" class="headerlink" title="核心代码（简略）："></a>核心代码（简略）：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在要hook的模块加载完后，才调用hook代码</span></span><br><span class="line">Interceptor.attach(Module.findExportByName(<span class="literal">null</span>, <span class="string">&#x27;android_dlopen_ext&#x27;</span>),&#123;</span><br><span class="line">    onEnter: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// first arg is the path to the library loaded</span></span><br><span class="line">        <span class="keyword">var</span> library_path = Memory.readCString(args[<span class="number">0</span>])</span><br><span class="line">                <span class="comment">//判断当前加载的模块是否是目标模块</span></span><br><span class="line">        <span class="keyword">if</span>( library_path.includes(library_name))&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;[...] Loading library : &quot;</span> + library_path)</span><br><span class="line">            library_loaded = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    onLeave: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if it&#x27;s the library we want to hook, hooking it</span></span><br><span class="line">        <span class="keyword">if</span>(library_loaded ==  <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;[+] Loaded&quot;</span>)</span><br><span class="line">              <span class="comment">//hook目标函数</span></span><br><span class="line">            hook_jni(library_name, function_name)</span><br><span class="line">            library_loaded = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Calculate the given funcName address from the JNIEnv pointer  //计算出jni函数的地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJNIFunctionAdress</span>(<span class="params">jnienv_addr,func_name</span>)</span>&#123;</span><br><span class="line">      <span class="comment">//最关键的起始就是这里，根据jnienv的地址和函数名,计算出偏移，其实就是拿函数的当前索引。这个了解类对象的结构就很清楚了。</span></span><br><span class="line">    <span class="keyword">var</span> offset = jni_struct_array.indexOf(func_name) * Process.pointerSize</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// console.log(&quot;offset : 0x&quot; + offset.toString(16))</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Memory.readPointer(jnienv_addr.add(offset))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hook all function to have an overview of the function called     //hook全部jni函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_all</span>(<span class="params">jnienv_addr</span>)</span>&#123;</span><br><span class="line">    jni_struct_array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func_name</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// Calculating the address of the function</span></span><br><span class="line">        <span class="keyword">if</span>(!func_name.includes(<span class="string">&quot;reserved&quot;</span>))</span><br><span class="line">       &#123;</span><br><span class="line">            <span class="keyword">var</span> func_addr = getJNIFunctionAdress(jnienv_addr,func_name)</span><br><span class="line">            Interceptor.attach(func_addr,&#123;</span><br><span class="line">                onEnter: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&quot;[+] Entered : &quot;</span> + func_name)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="改造并整合：-2"><a href="#改造并整合：-2" class="headerlink" title="改造并整合："></a>改造并整合：</h3><blockquote><p>他只针对了spawn的附加情况进行hook。我调整了下，判断是哪种附加，再进行不同方式的调用。最后统一下输出的方式。</p></blockquote><h2 id="DroidSSLUnpinning"><a href="#DroidSSLUnpinning" class="headerlink" title="DroidSSLUnpinning"></a>DroidSSLUnpinning</h2><hr><h3 id="github：-4"><a href="#github：-4" class="headerlink" title="github："></a>github：</h3><blockquote><p><a href="https://github.com/WooyunDota/DroidSSLUnpinning">DroidSSLUnpinning</a></p></blockquote><h3 id="功能：-3"><a href="#功能：-3" class="headerlink" title="功能："></a>功能：</h3><blockquote><p>主要是处理防抓包的双向验证的，客户端验证服务端的证书。这个项目可以解掉证书绑定，让中间人抓包正常运行。效果和JustTrustMe差不多。他厉害的地方在于支持各种库的解绑定。市面上大多数的绑定方式他都有处理到。下面列一下大佬的支持的库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.SSLcontext</span><br><span class="line">2.okhttp</span><br><span class="line">3.webview</span><br><span class="line">4.XUtils</span><br><span class="line">5.httpclientandroidlib</span><br><span class="line">6.JSSE</span><br><span class="line">7.network\_security\_config (android 7.0+)</span><br><span class="line">8.Apache Http client (support partly)</span><br><span class="line">9.OpenSSLSocketImpl</span><br><span class="line">10.TrustKit</span><br><span class="line">11.Cronet</span><br></pre></td></tr></table></figure></blockquote><h3 id="实现原理：-3"><a href="#实现原理：-3" class="headerlink" title="实现原理："></a>实现原理：</h3><blockquote><p>其实实现不难。但是关键是你要熟悉各种库的正向解绑定，知道是哪个函数来绑定的，然后将绑定函数给替换掉，直接改成空函数。所以像他这种支持这么多的，就比较厉害了。</p></blockquote><h3 id="核心代码（简略）：-2"><a href="#核心代码（简略）：-2" class="headerlink" title="核心代码（简略）："></a>核心代码（简略）：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//代码太长。这里只简单放两种解绑定的例子</span></span><br><span class="line">    <span class="comment">//WebView的解绑定</span></span><br><span class="line">    <span class="keyword">var</span> WebViewClient = Java.use(<span class="string">&quot;android.webkit.WebViewClient&quot;</span>);</span><br><span class="line">    WebViewClient.onReceivedSslError.implementation = <span class="function"><span class="keyword">function</span>(<span class="params">webView, sslErrorHandler, sslError</span>) </span>&#123;</span><br><span class="line">        quiet_send(<span class="string">&quot;WebViewClient onReceivedSslError invoke&quot;</span>);</span><br><span class="line">        <span class="comment">//执行proceed方法</span></span><br><span class="line">        sslErrorHandler.proceed();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    WebViewClient.onReceivedError.overload(<span class="string">&#x27;android.webkit.WebView&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;java.lang.String&#x27;</span>).implementation = <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c, d</span>) </span>&#123;</span><br><span class="line">        quiet_send(<span class="string">&quot;WebViewClient onReceivedError invoked&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    WebViewClient.onReceivedError.overload(<span class="string">&#x27;android.webkit.WebView&#x27;</span>, <span class="string">&#x27;android.webkit.WebResourceRequest&#x27;</span>, <span class="string">&#x27;android.webkit.WebResourceError&#x27;</span>).implementation = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        quiet_send(<span class="string">&quot;WebViewClient onReceivedError invoked&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">//okhttp的解绑定</span></span><br><span class="line"><span class="keyword">var</span> OkHttpClient = Java.use(<span class="string">&quot;com.squareup.okhttp.OkHttpClient&quot;</span>);</span><br><span class="line">OkHttpClient.setCertificatePinner.implementation = <span class="function"><span class="keyword">function</span>(<span class="params">certificatePinner</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do nothing</span></span><br><span class="line">  quiet_send(<span class="string">&quot;OkHttpClient.setCertificatePinner Called!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invalidate the certificate pinnet checks (if &quot;setCertificatePinner&quot; was called before the previous invalidation)</span></span><br><span class="line"><span class="keyword">var</span> CertificatePinner = Java.use(<span class="string">&quot;com.squareup.okhttp.CertificatePinner&quot;</span>);</span><br><span class="line">CertificatePinner.check.overload(<span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;[Ljava.security.cert.Certificate;&#x27;</span>).implementation = <span class="function"><span class="keyword">function</span>(<span class="params">p0, p1</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do nothing</span></span><br><span class="line">  quiet_send(<span class="string">&quot;okhttp Called! [Certificate]&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line">CertificatePinner.check.overload(<span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;java.util.List&#x27;</span>).implementation = <span class="function"><span class="keyword">function</span>(<span class="params">p0, p1</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do nothing</span></span><br><span class="line">  quiet_send(<span class="string">&quot;okhttp Called! [List]&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="stalker"><a href="#stalker" class="headerlink" title="stalker"></a>stalker</h2><hr><h3 id="github：-5"><a href="#github：-5" class="headerlink" title="github："></a>github：</h3><blockquote><p><a href="https://github.com/bmax121/sktrace">sktrace</a></p></blockquote><h3 id="功能：-4"><a href="#功能：-4" class="headerlink" title="功能："></a>功能：</h3><blockquote><p>这个项目主要是用stalker来实现trace汇编代码，打印每一句汇编指令执行后寄存器的变化。一般用于辅助分析算法还原。但是由于frida的stalker本身对arm32的支持不太好。所以这个项目目前还不支持arm32。目前还未支持spawn附加。对于c的打印方式还未完善，没有打印出寄存器的具体数值</p></blockquote><h3 id="实现原理：-4"><a href="#实现原理：-4" class="headerlink" title="实现原理："></a>实现原理：</h3><blockquote><p>首先CModule声明了一段c的代码。然后transform设置使用c的函数。我想，他可能是为了方便打印数据。工作流程比较简单，就是设置了目标模块，设置了符号或地址（一般是函数开始的地址，会一直执行到这个函数完，所以不用设置终止位置），他设置了两种打印方式stalkerTraceRangeC和stalkerTraceRange。用c的打印方式结果展示的比较好。但是缺少寄存器数值变化。另一种则是直接发送到py。让py部分来处理结果。但是我看他py部分也是没有解析输出。自己动手改良了一下。</p></blockquote><h3 id="核心代码（简略）：-3"><a href="#核心代码（简略）：-3" class="headerlink" title="核心代码（简略）："></a>核心代码（简略）：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traceAddr</span>(<span class="params">addr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> moduleMap = <span class="keyword">new</span> ModuleMap();    </span><br><span class="line">    <span class="keyword">let</span> targetModule = moduleMap.find(addr);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(targetModule))</span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">exports</span> = targetModule.enumerateExports();</span><br><span class="line">    <span class="keyword">let</span> symbols = targetModule.enumerateSymbols();</span><br><span class="line">      <span class="comment">//先是hook要trace的位置</span></span><br><span class="line">    Interceptor.attach(addr, &#123;</span><br><span class="line">        onEnter: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.tid = Process.getCurrentThreadId()</span><br><span class="line">              <span class="comment">//这个trace方式是c打印的，下面那个是发送详细数据给py打印的。</span></span><br><span class="line">            <span class="comment">//stalkerTraceRangeC(this.tid, targetModule.base, targetModule.size)</span></span><br><span class="line">            stalkerTraceRange(<span class="built_in">this</span>.tid, targetModule.base, targetModule.size)</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave: <span class="function"><span class="keyword">function</span>(<span class="params">ret</span>) </span>&#123;</span><br><span class="line">            Stalker.unfollow(<span class="built_in">this</span>.tid);</span><br><span class="line">            Stalker.garbageCollect()</span><br><span class="line">            send(&#123;</span><br><span class="line">                type: <span class="string">&quot;fin&quot;</span>,</span><br><span class="line">                tid: <span class="built_in">this</span>.tid</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我准备使用发送到py详细数据的打印方式，不是很喜欢混c的语言来处理。感觉会容易出错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stalkerTraceRange</span>(<span class="params">tid, base, size</span>) </span>&#123;</span><br><span class="line">    Stalker.follow(tid, &#123;</span><br><span class="line">        transform: <span class="function">(<span class="params">iterator</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> instruction = iterator.next();</span><br><span class="line">            <span class="keyword">const</span> startAddress = instruction.address;</span><br><span class="line">            <span class="keyword">const</span> isModuleCode = startAddress.compare(base) &gt;= <span class="number">0</span> &amp;&amp; </span><br><span class="line">                startAddress.compare(base.add(size)) &lt; <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// const isModuleCode = true;</span></span><br><span class="line">              <span class="comment">//transform是每个block触发。这里每个block触发的时候遍历出所有指令。</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                iterator.keep();</span><br><span class="line">                <span class="keyword">if</span> (isModuleCode) &#123;</span><br><span class="line">                      <span class="comment">//这里可以看到数据如果是inst就是一个指令，我们就需要解析打印</span></span><br><span class="line">                      <span class="comment">//输出样本如下</span></span><br><span class="line">                      <span class="comment">//&#x27;payload&#x27;: &#123;&#x27;type&#x27;: &#x27;inst&#x27;, &#x27;tid&#x27;: 19019, &#x27;block&#x27;: &#x27;0x74fd8d4ff4&#x27;, &#x27;val&#x27;: &#x27;&#123;&quot;address&quot;:&quot;0x74fd8d4ffc&quot;,&quot;next&quot;:&quot;0x4&quot;,&quot;size&quot;:4,&quot;mnemonic&quot;:&quot;add&quot;,&quot;opStr&quot;:&quot;sp, sp, #0x70&quot;,&quot;operands&quot;:[&#123;&quot;type&quot;:&quot;reg&quot;,&quot;value&quot;:&quot;sp&quot;&#125;,&#123;&quot;type&quot;:&quot;reg&quot;,&quot;value&quot;:&quot;sp&quot;&#125;,&#123;&quot;type&quot;:&quot;imm&quot;,&quot;value&quot;:&quot;112&quot;&#125;],&quot;regsRead&quot;:[],&quot;regsWritten&quot;:[],&quot;groups&quot;:[]&#125;&#x27;&#125;&#125;</span></span><br><span class="line">                      <span class="comment">//py解析打印格式&quot;add sp, sp, #0x70  //sp=112&quot;        这里的处理应该还要更复杂。暂时先简单处理</span></span><br><span class="line">                      </span><br><span class="line">                    send(&#123;</span><br><span class="line">                        type: <span class="string">&#x27;inst&#x27;</span>,</span><br><span class="line">                        tid: tid,</span><br><span class="line">                        block: startAddress,</span><br><span class="line">                        val: <span class="built_in">JSON</span>.stringify(instruction)</span><br><span class="line">                    &#125;)</span><br><span class="line">                         <span class="comment">//这里是打印所有寄存器</span></span><br><span class="line">                      <span class="comment">//输出样本如下</span></span><br><span class="line">                      <span class="comment">//&#123;&#x27;type&#x27;: &#x27;ctx&#x27;, &#x27;tid&#x27;: 19019, &#x27;val&#x27;: &#x27;&#123;&quot;pc&quot;:&quot;0x74fd8d4fe8&quot;,&quot;sp&quot;:&quot;0x7fc28609d0&quot;,&quot;x0&quot;:&quot;0x0&quot;,&quot;x1&quot;:&quot;0x7fc2860908&quot;,&quot;x2&quot;:&quot;0x0&quot;,&quot;x3&quot;:&quot;0x756aec1349&quot;,&quot;x4&quot;:&quot;0x7fc28608f0&quot;,&quot;x5&quot;:&quot;0x14059dbe&quot;,&quot;x6&quot;:&quot;0x7266206f6c6c6548&quot;,&quot;x7&quot;:&quot;0x2b2b43206d6f7266&quot;,&quot;x8&quot;:&quot;0x0&quot;,&quot;x9&quot;:&quot;0x65af2e18847fd289&quot;,&quot;x10&quot;:&quot;0x1&quot;,&quot;x11&quot;:&quot;0x7fc2860a20&quot;,&quot;x12&quot;:&quot;0xe&quot;,&quot;x13&quot;:&quot;0x7fc2860a20&quot;,&quot;x14&quot;:&quot;0xffffff0000000000&quot;,&quot;x15&quot;:&quot;0x756aeed1b5&quot;,&quot;x16&quot;:&quot;0x74fd8fadc8&quot;,&quot;x17&quot;:&quot;0x74fd8d50d8&quot;,&quot;x18&quot;:&quot;0x75f0bda000&quot;,&quot;x19&quot;:&quot;0x75f02f9c00&quot;,&quot;x20&quot;:&quot;0x756af59490&quot;,&quot;x21&quot;:&quot;0x75f02f9c00&quot;,&quot;x22&quot;:&quot;0x7fc2860c90&quot;,&quot;x23&quot;:&quot;0x74ffcee337&quot;,&quot;x24&quot;:&quot;0x4&quot;,&quot;x25&quot;:&quot;0x75f04b4020&quot;,&quot;x26&quot;:&quot;0x75f02f9cb0&quot;,&quot;x27&quot;:&quot;0x1&quot;,&quot;x28&quot;:&quot;0x756b3f2000&quot;,&quot;fp&quot;:&quot;0x7fc2860a30&quot;,&quot;lr&quot;:&quot;0x74fd8d4fdc&quot;&#125;&#x27;&#125;&#125;</span></span><br><span class="line">                      <span class="comment">//这里是寄存器变化时调用</span></span><br><span class="line">                    iterator.putCallout(<span class="function">(<span class="params">context</span>) =&gt;</span> &#123;</span><br><span class="line">                            send(&#123;</span><br><span class="line">                                type: <span class="string">&#x27;ctx&#x27;</span>,</span><br><span class="line">                                tid: tid,</span><br><span class="line">                                val: <span class="built_in">JSON</span>.stringify(context)</span><br><span class="line">                            &#125;)</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (iterator.next() !== <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="改造并整合：-3"><a href="#改造并整合：-3" class="headerlink" title="改造并整合："></a>改造并整合：</h3><blockquote><p>优化py结果打印，增加spawn支持。</p></blockquote><h2 id="frida-hook-libart"><a href="#frida-hook-libart" class="headerlink" title="frida_hook_libart"></a>frida_hook_libart</h2><hr><h3 id="github：-6"><a href="#github：-6" class="headerlink" title="github："></a>github：</h3><blockquote><p><a href="https://github.com/lasting-yang/frida_hook_libart">frida_hook_libart</a></p></blockquote><h3 id="功能：-5"><a href="#功能：-5" class="headerlink" title="功能："></a>功能：</h3><blockquote><p>（ps：yang大神的三件套。向大佬学习。给大佬递茶。）</p><p>hook_RegisterNatives.js，hook打印动态注册的函数，分析so时静态注册的函数我们一般直接搜索Java开头的符号名就基本都是了，但是动态注册的我们静态分析没法找到对应的native函数。</p><p>hook_artmethod.js，java的函数打印最终都是调用的ArtMethod的Invoke。对这里进行hook。就可以打印所有java函数的调用了。</p><p>hook_art.js，hook art中的jni函数并且有打印参数和返回值，在aosp10上面测试了一下。一个都没hook成功。发现是判断_ZN3art3JNIILb0的问题。用ida打开libart.so。然后搜索一个里面想要hook的函数GetStringUTFChars。找到他的符号名是<code>_ZN3art3JNI12NewStringUTFEP7_JNIEnvPKc</code>。所以修改下过滤的判断。改成<code>_ZN3art3JNI</code>。然后正常输出结果。不过这个打印数据相当之多。另外这个也将上面的hook_RegisterNative.js的部分给包含了。</p><p>另外在测试的时候发现。hook_artmethod.js和hook_art.js里面用到的class StdString好像在frida12的版本会出错。升到frida14就正常了。</p></blockquote><h3 id="实现原理：-5"><a href="#实现原理：-5" class="headerlink" title="实现原理："></a>实现原理：</h3><blockquote><p>hook_RegisterNatives.js 遍历libart.so的所有符号，找到RegisterNative函数的地址。然后hook打印</p><p>hook_artmethod.js 遍历libart.so的所有符号，找到_ZN3art9ArtMethod6InvokeEPNS_6ThreadEPjjPNS_6JValueEPKc符号的地址，也就是ArtMethod的Invoke，然后hook了打印堆栈和函数名</p><p>hook_art.js 遍历libart.so的所有符号，找到一些常用的jni函数，取出函数地址。然后hook函数，用对应的方式打印</p></blockquote><h3 id="核心代码（简略）：-4"><a href="#核心代码（简略）：-4" class="headerlink" title="核心代码（简略）："></a>核心代码（简略）：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hook_RegisterNative.js的部分，就是这段。找RegisterNative函数的地址。</span></span><br><span class="line"><span class="keyword">var</span> symbols = Module.enumerateSymbolsSync(<span class="string">&quot;libart.so&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> addrRegisterNatives = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; symbols.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> symbol = symbols[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//_ZN3art3JNI15RegisterNativesEP7_JNIEnvP7_jclassPK15JNINativeMethodi</span></span><br><span class="line">        <span class="keyword">if</span> (symbol.name.indexOf(<span class="string">&quot;art&quot;</span>) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">                symbol.name.indexOf(<span class="string">&quot;JNI&quot;</span>) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">                symbol.name.indexOf(<span class="string">&quot;RegisterNatives&quot;</span>) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">                symbol.name.indexOf(<span class="string">&quot;CheckJNI&quot;</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            addrRegisterNatives = symbol.address;</span><br><span class="line">            log(<span class="string">&quot;RegisterNatives is at &quot;</span>+symbol.address+<span class="string">&quot; &quot;</span>+symbol.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hook_artmethod.js的部分</span></span><br><span class="line"><span class="comment">//这里是遍历所有符号，匹配出ArtMethod的Invoke</span></span><br><span class="line"><span class="keyword">var</span> module_libart = Process.findModuleByName(<span class="string">&quot;libart.so&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> symbols = module_libart.enumerateSymbols();</span><br><span class="line">    <span class="keyword">var</span> ArtMethod_Invoke = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; symbols.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> symbol = symbols[i];</span><br><span class="line">        <span class="keyword">var</span> address = symbol.address;</span><br><span class="line">        <span class="keyword">var</span> name = symbol.name;</span><br><span class="line">        <span class="keyword">var</span> indexArtMethod = name.indexOf(<span class="string">&quot;ArtMethod&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> indexInvoke = name.indexOf(<span class="string">&quot;Invoke&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> indexThread = name.indexOf(<span class="string">&quot;Thread&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (indexArtMethod &gt;= <span class="number">0</span></span><br><span class="line">            &amp;&amp; indexInvoke &gt;= <span class="number">0</span></span><br><span class="line">            &amp;&amp; indexThread &gt;= <span class="number">0</span></span><br><span class="line">            &amp;&amp; indexArtMethod &lt; indexInvoke</span><br><span class="line">            &amp;&amp; indexInvoke &lt; indexThread) &#123;</span><br><span class="line">              <span class="comment">//将后面的hook代码去掉。可以看到这里最终匹配到的结果是_ZN3art9ArtMethod6InvokeEPNS_6ThreadEPjjPNS_6JValueEPKc</span></span><br><span class="line">              <span class="comment">//转换下格式之后的结果是art::ArtMethod::Invoke(art::Thread*, unsigned int*, unsigned int, art::JValue*, char const*)</span></span><br><span class="line">            <span class="built_in">console</span>.log(name);</span><br><span class="line">            ArtMethod_Invoke = address;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//如果上面匹配到了Invoke函数后。就hook打印。</span></span><br><span class="line">    <span class="keyword">if</span> (ArtMethod_Invoke) &#123;</span><br><span class="line">        Interceptor.attach(ArtMethod_Invoke, &#123;</span><br><span class="line">            onEnter: <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> method_name = prettyMethod(args[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (!(method_name.indexOf(<span class="string">&quot;java.&quot;</span>) == <span class="number">0</span> || method_name.indexOf(<span class="string">&quot;android.&quot;</span>) == <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&quot;ArtMethod Invoke:&quot;</span> + method_name + <span class="string">&#x27;  called from:\n&#x27;</span> +</span><br><span class="line">                        Thread.backtrace(<span class="built_in">this</span>.context, Backtracer.ACCURATE)</span><br><span class="line">                            .map(DebugSymbol.fromAddress).join(<span class="string">&#x27;\n&#x27;</span>) + <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//这里也是个重点。打印当前函数名的方式。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prettyMethod</span>(<span class="params">method_id, withSignature</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">new</span> StdString();</span><br><span class="line">    Java.api[<span class="string">&#x27;art::ArtMethod::PrettyMethod&#x27;</span>](result, method_id, withSignature ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result.disposeToString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hook_art.js的重点部分</span></span><br><span class="line"><span class="comment">//这个就不放了。一整块有点大。简单说下，就是遍历libart.so所有符号列表找到一些常用的jni函数地址。然后打印输出</span></span><br></pre></td></tr></table></figure><h3 id="改造并整合：-4"><a href="#改造并整合：-4" class="headerlink" title="改造并整合："></a>改造并整合：</h3><blockquote><p>没啥好改的。调整下日志打印方式。直接淦就完了。</p><p>（ps：另外说一下。虽然这个hook_art.js也是对jni的hook。但是和我之前封装的Jni-Frida-Hook是有一定区别的。这个是直接hook系统底层的。所有触发都会调用。而那个是指定某个函数触发时，hook所有jni函数。然后函数结束后，清掉所有hook。用哪种就看自己的需求拉。）</p></blockquote><h2 id="frida-dump"><a href="#frida-dump" class="headerlink" title="frida_dump"></a>frida_dump</h2><hr><h3 id="github：-7"><a href="#github：-7" class="headerlink" title="github："></a>github：</h3><blockquote><p><a href="https://github.com/lasting-yang/frida_dump">frida_dump</a></p></blockquote><h3 id="功能：-6"><a href="#功能：-6" class="headerlink" title="功能："></a>功能：</h3><blockquote><p>dump_module.js 从内存中dump so模块保存到文件（以前叫dump_so.js）。有时候用unicorn模拟执行片段指令的时候，直接使用apk中的so是不行的。因为缺少上下文数据，如果有对外部数据的使用，就无法正常执行。但是从内存中dump出来的so是在执行过程中的，所以自带了上下文数据。</p><p>dump_dex.js 就是脱壳，在DefineClass函数调用的时机进行dump dex保存到文件</p><p>dump_dex_class.js 和上面的差不多，多了个步骤load_all_class，这个函数主要是用来遍历所有classloader。加载所有类的。</p></blockquote><h3 id="实现原理：-6"><a href="#实现原理：-6" class="headerlink" title="实现原理："></a>实现原理：</h3><blockquote><p>前面两个比较简单，就只说dump_dex_class.js了。</p><p>首先是找到DefineClass的函数地址。然后从参数中取出dexFile。根据dexFile的结构，偏移指针的距离得到begin的值和大小。那么就可以把这个dexfile保存出来了。可以先把所有classloader里面的所有dexfile的class全部都加载了一遍，最后在保存的。下面是遍历loadClass的流程</p><p>遍历所有classloader。然后转换成BaseDexClassLoader，获取到DexPathList，获取到dexElements，再遍历所有的dexfile，最后通过<em>entries</em>枚举所有类名，最后loader.loadClass来加载这个类。可能是有的壳loadClass之后才会生成解密的dex。所以就先全部loadClass一遍，然后再进行dump</p></blockquote><h3 id="核心代码："><a href="#核心代码：" class="headerlink" title="核心代码："></a>核心代码：</h3><blockquote><p>（不贴了，文章太长了。感兴趣的大家自己翻翻看吧）</p></blockquote><h3 id="改造并整合：-5"><a href="#改造并整合：-5" class="headerlink" title="改造并整合："></a>改造并整合：</h3><blockquote><p>测试了下libart.so不需要spawn判断。都可以获取到。所以去掉spawn判断部分。然后在dex保存的时候，碰到了权限问题。不知道是不是和安卓10有关。总之修改成py来负责创建目录，赋值权限。增加功能从手机直接把脱壳好的文件下载到项目内。dump_dex_class的dump_dex抽成功能单独调用</p></blockquote><h3 id="FRIDA-DEXDump"><a href="#FRIDA-DEXDump" class="headerlink" title="FRIDA-DEXDump"></a>FRIDA-DEXDump</h3><hr><h3 id="github：-8"><a href="#github：-8" class="headerlink" title="github："></a>github：</h3><blockquote><p><a href="https://github.com/hluwa/FRIDA-DEXDump"> FRIDA-DEXDump</a></p></blockquote><h3 id="功能：-7"><a href="#功能：-7" class="headerlink" title="功能："></a>功能：</h3><blockquote><p>也是脱壳，不过和上面的方式不一样，是在内存中检索dex的特征的，再dump出来进行脱壳。同时支持objection</p></blockquote><h3 id="实现原理：-7"><a href="#实现原理：-7" class="headerlink" title="实现原理："></a>实现原理：</h3><blockquote><p>首先是设置了三个rpc功能。然后py根据这三个功能去根据dex特征检索内存，找到后验证数据，然后读取这段数据出来，再保存到文件。</p><p>1、scandex：枚举内存中所有只读的数据，检索只读数据中所有出现<code>64 65 78 0a 30 ?? ?? 00</code>数据的段。这个是dex的二进制数据的头部特征。如下图。版本有的是035，有的是037.所以他把版本部分没有匹配。匹配到结果后，就开始验证这段数据是不是一个正常的dex。验证通过后就返回这段数据的地址和大小。</p><p><img src="/2021/06/24/fridatools/image-20210624230938895.png" alt="image-20210624230938895"></p><p>2、memorydump：用来读取指定地址，指定大小的数据，并返回。代码很简单。</p><p>3、switchmode：设置是否深度搜索。这里是有一个比较模糊的特征<code>70 00 00 00</code>来进行搜索。上面的图也有一个正常dex中的该特征。</p></blockquote><h3 id="核心代码：-1"><a href="#核心代码：-1" class="headerlink" title="核心代码："></a>核心代码：</h3><blockquote><p>（不贴了，文章太长了。感兴趣的大家自己翻翻看吧）</p></blockquote><h3 id="改造并整合：-6"><a href="#改造并整合：-6" class="headerlink" title="改造并整合："></a>改造并整合：</h3><blockquote><p>统一下日志输出</p></blockquote><h2 id="fart"><a href="#fart" class="headerlink" title="fart"></a>fart</h2><hr><h3 id="github：-9"><a href="#github：-9" class="headerlink" title="github："></a>github：</h3><blockquote><p><a href="https://github.com/hanbinglengyue/FART">FART</a></p></blockquote><h3 id="功能：-8"><a href="#功能：-8" class="headerlink" title="功能："></a>功能：</h3><blockquote><p>也是脱壳用的。基于主动调用的脱壳，可以过掉大多数函数抽取壳。这是fart的frida版本。免去了编译rom。</p></blockquote><h3 id="实现原理：-8"><a href="#实现原理：-8" class="headerlink" title="实现原理："></a>实现原理：</h3><blockquote><p>fart的原理比较长，详细的可以直接看作者的详细文章</p><p>1、<a href="https://bbs.pediy.com/thread-252630.htm">FART：ART环境下基于主动调用的自动化脱壳方案</a></p><p>2、<a href="https://bbs.pediy.com/thread-254028.htm">FART正餐前甜点：ART下几个通用简单高效的dump内存中dex方法</a></p><p>3、<a href="https://bbs.pediy.com/thread-254555.htm">拨云见日：安卓APP脱壳的本质以及如何快速发现ART下的脱壳点</a></p><p>另外有我以前自己整理的一片文章</p><p><a href="https://bbs.pediy.com/thread-263401.htm">fart的理解和分析过程</a></p></blockquote><h3 id="改造并整理："><a href="#改造并整理：" class="headerlink" title="改造并整理："></a>改造并整理：</h3><blockquote><p>将fart主动调用和dumpclass主动调用设置到rpc中。在功能里面来调用触发。另外测试发现LoadMethod地址的获取处，增加将libart.so快捷push到手机并chmod权限的功能，在安卓10无法获取到函数地址。修改成支持安卓10的。代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> versionData=<span class="string">&quot;ClassDataItemIterator&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(Java.androidVersion==<span class="string">&quot;10&quot;</span>)&#123;</span><br><span class="line">  versionData=<span class="string">&quot;ClassAccessor&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> symbols = Module.enumerateSymbolsSync(<span class="string">&quot;libart.so&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; symbols.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> symbol = symbols[i];</span><br><span class="line"> <span class="comment">//_ZN3art11ClassLinker10LoadMethodERKNS_7DexFileERKNS_21ClassDataItemIteratorENS_6HandleINS_6mirror5ClassEEEPNS_9ArtMethodE</span></span><br><span class="line">  <span class="keyword">if</span> (symbol.name.indexOf(<span class="string">&quot;ClassLinker&quot;</span>) &gt;= <span class="number">0</span></span><br><span class="line">      &amp;&amp; symbol.name.indexOf(<span class="string">&quot;LoadMethod&quot;</span>) &gt;= <span class="number">0</span></span><br><span class="line">      &amp;&amp; symbol.name.indexOf(<span class="string">&quot;DexFile&quot;</span>) &gt;= <span class="number">0</span></span><br><span class="line">      &amp;&amp; symbol.name.indexOf(versionData) &gt;= <span class="number">0</span></span><br><span class="line">      &amp;&amp; symbol.name.indexOf(<span class="string">&quot;ArtMethod&quot;</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    addrLoadMethod = symbol.address;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="Wallbreaker"><a href="#Wallbreaker" class="headerlink" title="Wallbreaker"></a>Wallbreaker</h2><hr><h3 id="github：-10"><a href="#github：-10" class="headerlink" title="github："></a>github：</h3><blockquote><p><a href="https://github.com/hluwa/Wallbreaker">Wallbreaker</a></p></blockquote><h3 id="功能：-9"><a href="#功能：-9" class="headerlink" title="功能："></a>功能：</h3><blockquote><p>主要是内存漫游，搜索内存中的java类和对象，并且可以打印类的结构体，以及对象的数据。</p></blockquote><h3 id="实现原理：-9"><a href="#实现原理：-9" class="headerlink" title="实现原理："></a>实现原理：</h3><blockquote><p>首先找到几个关键的文件如下。</p><p><code>Wallbreaker/__init__.py </code>功能调用的入口，四个功能classsearch、classdump、objectsearch、objectdump</p><p><code>Wallbreaker/wallbreaker/agent/command/__init__.py</code>功能实现的关键代码，这里使用rpc调用js的函数来获取相关数据出来加工处理。</p><p><code>Wallbreaker/agent/_agent.js</code>核心的js。这里提供了一系列查询内存的rpc接口。searchHandles、getRealClassNameByHandle、getObjectFieldValue、instanceOf、mapDump、collectionDump。</p><p>这个项目主要是使用rpc交互达到py调用js访问frida函数并封装各种便利功能。从这个项目延伸的话，我们用这个模式可以打造各种强大的frida交互工具。</p></blockquote><h3 id="改造并整理：-1"><a href="#改造并整理：-1" class="headerlink" title="改造并整理："></a>改造并整理：</h3><blockquote><p>结果输出方式调整。rpc.exports修改初始化方式，以免覆盖到其他js的rpc函数。将需要使用的所有脚本添加后，最后默认追加这个脚本。由于我默认做了类列表和过滤功能，所以classsearch可能有点鸡肋。</p></blockquote><h3 id="相关贴图：-1"><a href="#相关贴图：-1" class="headerlink" title="相关贴图："></a>相关贴图：</h3><p><img src="/2021/06/24/fridatools/image-20210624210905380.png" alt="image-20210624210905380"></p><p><img src="/2021/06/24/fridatools/image-20210624205727455.png" alt="image-20210624205727455"></p><p><strong>最后整理完成，目前功能还不是很多，而且bug估计还挺多的。希望大佬们多多指点，有什么比较好的想法也可以给点建议。</strong></p>]]></content>
      
      
      <categories>
          
          <category> frida </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android基础篇一（笔记）</title>
      <link href="/2021/06/03/android1/"/>
      <url>/2021/06/03/android1/</url>
      
        <content type="html"><![CDATA[<p>这里主要是看书的笔记。从基础开始。不断记录。直到啃完这本书（android软件安全权威指南：丰生强）</p><h2 id="反编译和回编"><a href="#反编译和回编" class="headerlink" title="反编译和回编"></a>反编译和回编</h2><p>android最常用的反编译工具apktool。可以跨平台win、linux、maos。用来反编译apk文件，反汇编成smali代码。然后可以修改smali代码后。再用apktool重新编译回apk，再签名。就可以直接安装了。贴上github地址：<a href="https://github.com/iBotPeaches/Apktool">https://github.com/iBotPeaches/Apktool</a></p><p>mac可以直接<code>brew install apktool</code>安装</p><p>反编译命令：<code>apktool d ./app-debug.apk -o outdir</code> </p><a id="more"></a><p>反编译后，得到若干文件。res下面是资源文件，smali下面是代码。字符串资源一般在res\values\strings.xml，也有可能硬编码进源码。在apk中。这个字符串资源被加密存储为resources.arsc存放。反编译才解密出来成strings.xml的。</p><p>在正向android开发的时候。字符串资源都在gen/R.java中，而且每个字符串都有个对应的索引。反编译后，这个对应的索引放在public.xml里面。</p><p>outdir/unknown/instant-run.zip是android studio为了快速编译的优化，会将代码生成很多个片段。然后以dex的格式打包到instant-run.zip。启动时，再用特定的方式来加载这个文件。只有编译debug版本时会出现。</p><p>回编指令：<code>apktool b outdir -o app-debug-rel.apk</code></p><p>如果汇编失败，错误是ResourcesFull(Androlib.java:477)</p><p>是因为apktool使用的framework-res.apk的版本太老。例如当前apk的API是25。那就找个对应手机。</p><p>然后<code>adb pull /system/framework/framework-res.apk</code>导出这个文件</p><p>然后安装<code>apt tool if ./framework-res.apk</code></p><p>如果汇编还是失败就删除掉layout-v22目录</p><p>我测试2.5.0的apktool没有上面的问题</p><h2 id="dalvik执行格式与字节码"><a href="#dalvik执行格式与字节码" class="headerlink" title="dalvik执行格式与字节码"></a>dalvik执行格式与字节码</h2><p>android程序不是运行在java虚拟机，而是运行在dalvik虚拟机。android4.4以后又引入了art虚拟机。之前是由jit执行dalvik，后来换成AOT编译art。art也向下兼容，可以执行dalvik字节码。</p><h3 id="dalvik虚拟机和java虚拟机的区别"><a href="#dalvik虚拟机和java虚拟机的区别" class="headerlink" title="dalvik虚拟机和java虚拟机的区别"></a>dalvik虚拟机和java虚拟机的区别</h3><p>1、字节码不同，分别使用的java字节码和dalvik字节码。java代码编译后，生成java字节码保存在class，然后java虚拟机直接解码运行了。而android是java字节码再转换成dalvik字节码，再打包成dex可执行文件。最后dalvik虚拟机解释dex文件来执行字节码。</p><p>2、dalvik可执行文件的体积更小</p><p>sdk中有个叫dx的工具是用来把java字节码转换成dalvik字节码。并且重新排列java类文件。消除冗余信息，避免重复加载。dx对所有java类中的常量池进行了分解。去掉冗余信息组成一个常量池。并且所有类共享。比如A类中有参数为一个string的签名方法。B类，C类中都有。这样方法签名就重复很多了。dx就把这些签名方法统一放一起。所有类从一个地方取。相同的字符串和常量在dex中只会出现一次。所以dalvik的可执行文件更小。下面是dex文件的格式</p><p><img src="/2021/06/03/android1/image-20210604213905401.png" alt="image-20210604213905401"></p><p>3、虚拟机架构不同</p><p>java虚拟机是栈架构的。dalvik是寄存器架构的。直接寄存器的操作肯定是比栈的效率要更高。</p><h3 id="dalvik虚拟机的执行流程"><a href="#dalvik虚拟机的执行流程" class="headerlink" title="dalvik虚拟机的执行流程"></a>dalvik虚拟机的执行流程</h3><p>android系统主要分为4个大块：linux内核、函数库、android运行时、应用程序框架、应用程序。</p><p>dalvik虚拟机属于android运行时环境。它和一些核心库一起负责应用的运行。</p><p>android系统启动-&gt;加载内核-&gt;执行init进程-&gt;init进程负责初始化,然后读取init.rc，然后启动重要的外部程序Zygote</p><p>Zygote是所有进程的孵化器进程。启动后先初始化dalvik虚拟机，然后启动system_server进程并进入zygote模式。然后通过socket等候命令。当打开一个引用时，system_server进程通过Binder IPC方式将命令发送给zygote。前面用socket等候命令的zygote收到命令了。就fork一个自己创建出了个dalvik虚拟机实例来执行应用程序的入口函数。完成了程序的启动过程。</p><p>zygote有三种创建进程方法</p><p>fork()                            创建zygote进程（实际不会调用）</p><p>forkAndSpecialize()     创建非zygote进程</p><p>forkSystemServer()     创建系统服务进程</p><p>for完毕后，就是dalvik虚拟机来完成执行字节码。</p><p>dalvik的执行流程是，先用loadlCassFromdEX()装载类，每个类解析成ClassObject结构存储。所有类存储到gDvm.loadedClasses中。字节码验证器用dvmVerifyCodeFlow()对装入的代码校验。然后虚拟机用findClass查找有main()的方法类。最后调用dvmInterpret()来初始化解释器并执行字节码。这里我去查了一下。发现4.4.4版本是有dvmInterpret的。不过较新的版本就没有了。</p><h3 id="dalvik指令格式"><a href="#dalvik指令格式" class="headerlink" title="dalvik指令格式"></a>dalvik指令格式</h3><p><strong>位描述约定：</strong></p><p>每16位用空格分开</p><p>每个字母代表4位，每个字母按高字节到底字节排序，每4位之前可能用|分割</p><p>顺序采用大写A-Z表示4位的操作码。op表示8位的操作码</p><p>Θ表示字段所有位的值是0</p><p><strong>指令格式标识的约定：</strong></p><p>指令格式标识大都是三个字符组成。前两个是数字，后一个是字母</p><p>第一个数字代表由多少个16位的字组成</p><p>第二个数字是最多使用的寄存器个数</p><p>第三个字母为类型码，标识指令使用的额外数据类型</p><p>特殊情况指令末尾多出一个字母。是s表示采用静态链接，是i表示应该被内联处理。</p><p>（这块看的不是怎么明白。以后再回头仔细琢磨）</p><h3 id="dex反汇编"><a href="#dex反汇编" class="headerlink" title="dex反汇编"></a>dex反汇编</h3><p>android官方提供的反汇编工具dexdump和第三方的baksmali</p><p>反汇编命令<code>dexdump -d classes.dex</code>  </p><p>结果如下。这里注意。dexdump工具是在sdk的build-tools目录中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2336d0: 7010 8447 0100                         |0000: invoke-direct &#123;v1&#125;, Lokio&#x2F;SegmentedByteString;.toByteString:()Lokio&#x2F;ByteString; &#x2F;&#x2F; method@4784</span><br><span class="line">2336d6: 0c00                                   |0003: move-result-object v0</span><br><span class="line">2336d8: 6e10 7a46 0000                         |0004: invoke-virtual &#123;v0&#125;, Lokio&#x2F;ByteString;.utf8:()Ljava&#x2F;lang&#x2F;String; &#x2F;&#x2F; method@467a</span><br><span class="line">2336de: 0c00                                   |0007: move-result-object v0</span><br><span class="line">2336e0: 1100                                   |0008: return-object v0</span><br></pre></td></tr></table></figure><p>baksmali是第三方的。git地址：<a href="https://github.com/JesusFreke/smali.git">https://github.com/JesusFreke/smali.git</a></p><p>下载地址：<a href="https://bitbucket.org/JesusFreke/smali/downloads/">https://bitbucket.org/JesusFreke/smali/downloads/</a></p><p>两者的区别是baksmali的寄存器命名法采用的p命名法，dexdump采用的v命名法。另外baksmali还支持打包反汇编的代码生成dex。</p><p>反汇编命令<code>baksmali d classes.dex -o outdata</code></p><p>好像老版本的命令不一样。我这里用的是2.5.2。</p><p>前面dexdump的结果是直接将解析的结果全部打印出来。而baksmali是将结果解析到一个文件夹里面。层级划分的更加好。所以个人觉得baksmali要更方便点。</p><h3 id="dalvik寄存器"><a href="#dalvik寄存器" class="headerlink" title="dalvik寄存器"></a>dalvik寄存器</h3><p>dalvik虚拟机是寄存器架构的。将部分寄存器映射到了arm寄存器上。还有一部分通过调用栈进行模拟</p><p>使用的寄存器都是32位的。使用两个相邻的寄存器处理64位的类型</p><p>最大支持的寄存器数。之前指令格式的地方，有说dalvik指令的约定。指令每16位划分为一个部分。所以寄存器最大只能是16位存储的极限65535</p><h3 id="dalvik指令集"><a href="#dalvik指令集" class="headerlink" title="dalvik指令集"></a>dalvik指令集</h3><p>这里主要是看smali代码有不懂的时候。可以过来查阅对应指令的说明。详细见63页</p>]]></content>
      
      
      
        <tags>
            
            <tag> andorid基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用unidbg还原标准ollvm的fla控制流程平坦化</title>
      <link href="/2021/05/14/ollvm3/"/>
      <url>/2021/05/14/ollvm3/</url>
      
        <content type="html"><![CDATA[<p>最近网上查了查还原平坦化相关的资料。看了无名侠大佬的文章。由于本人太菜了。好多地方看的有点懵懵懂懂的。最终还是自己摸索着尝试还原平坦化。写的哪里不对。还请大佬指正。</p><p>先贴上几位大佬的文章</p><p>[ARM64 OLLVM反混淆][<a href="https://bbs.pediy.com/thread-252321.htm]">https://bbs.pediy.com/thread-252321.htm]</a></p><p>[利用符号执行去除控制流平坦化][<a href="https://security.tencent.com/index.php/blog/msg/112]">https://security.tencent.com/index.php/blog/msg/112]</a></p><p>翻阅过大佬的文章后。本菜菜得到两个简单的结论。</p><p><strong>一、fla主要功能是将if else这类的逻辑给转换成while+switch组合来处理。达到将简单的逻辑给复杂化，增加静态分析难度的目的。</strong></p><p><strong>二、模拟执行找出真实块之间的关联，patch修改相应的代码。直接将真实块关联起来，从而实现反混淆</strong></p><a id="more"></a><p>接下来。我将采用先射箭后画靶的方式。来逐步的还原一个标准的ollvm fla的案例。</p><p>首先是准备我们的案例，如下是未混淆前的源码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">calcKey</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.length()&gt;<span class="number">10</span>)&#123;</span><br><span class="line">        data=<span class="string">&quot;ceshi&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(data.length()&gt;<span class="number">30</span>)&#123;</span><br><span class="line">        data=<span class="string">&quot;ollvm&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        data=<span class="string">&quot;fla&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> JNIEXPORT jstring JNICALL</span><br><span class="line">Java_com_example_ollvmdemo2_MainActivity_stringFromJNI(</span><br><span class="line">        JNIEnv *env,</span><br><span class="line">        jobject <span class="comment">/* this */</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> hello = <span class="string">&quot;Hello from C++&quot;</span>;</span><br><span class="line">    hello=calcKey(hello);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(hello.c_str());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是混淆的参数配置是<code>add_definitions(&quot;-mllvm -fla -mllvm -split -mllvm -split_num=3&quot;)</code></p><p>贴上混淆后的样本：链接: <a href="https://pan.baidu.com/s/1Dd0T49xhsjgWrJw7PSTQFA">https://pan.baidu.com/s/1Dd0T49xhsjgWrJw7PSTQFA</a>  密码: rrem</p><p>然后贴上ida解析出来的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __int64 __usercall calcKey@&lt;X0&gt;(<span class="keyword">unsigned</span> __int64 result@&lt;X0&gt;, __int64 a2@&lt;X8&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v2; <span class="comment">// w8</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v3; <span class="comment">// w8</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [xsp+10h] [xbp-40h]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [xsp+18h] [xbp-38h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v6; <span class="comment">// [xsp+24h] [xbp-2Ch]</span></span><br><span class="line">  <span class="keyword">bool</span> v7; <span class="comment">// [xsp+3Fh] [xbp-11h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v8; <span class="comment">// [xsp+40h] [xbp-10h]</span></span><br><span class="line">  <span class="keyword">bool</span> v9; <span class="comment">// [xsp+4Fh] [xbp-1h]</span></span><br><span class="line"></span><br><span class="line">  v6 = <span class="number">910266824</span>;</span><br><span class="line">  v5 = a2;</span><br><span class="line">  v4 = result;</span><br><span class="line">  <span class="keyword">while</span> ( v6 != <span class="number">-1929161090</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( v6 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">-1578842400</span>:</span><br><span class="line">        v6 = <span class="number">56578246</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">-1521928633</span>:</span><br><span class="line">        v9 = v8 &gt; <span class="number">0x1E</span>;</span><br><span class="line">        v6 = <span class="number">-124633339</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">-124633339</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v9 )</span><br><span class="line">          v3 = <span class="number">1872828810</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          v3 = <span class="number">1744272424</span>;</span><br><span class="line">        v6 = v3;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">56578246</span>:</span><br><span class="line">        v6 = <span class="number">1089662144</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">256858465</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v7 )</span><br><span class="line">          v2 = <span class="number">1938015978</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          v2 = <span class="number">1363893773</span>;</span><br><span class="line">        v6 = v2;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">910266824</span>:</span><br><span class="line">        v6 = <span class="number">2056492010</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1089662144</span>:</span><br><span class="line">        result = sub_F8E4(v5, v4);</span><br><span class="line">        v6 = <span class="number">-1929161090</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1363893773</span>:</span><br><span class="line">        result = sub_F77C(v4);</span><br><span class="line">        v8 = result;</span><br><span class="line">        v6 = <span class="number">-1521928633</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1493239651</span>:</span><br><span class="line">        v6 = <span class="number">1089662144</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1697837166</span>:</span><br><span class="line">        v6 = <span class="number">56578246</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1744272424</span>:</span><br><span class="line">        result = sub_F830(v4, <span class="string">&quot;fla&quot;</span>);</span><br><span class="line">        v6 = <span class="number">1697837166</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1872828810</span>:</span><br><span class="line">        result = sub_F830(v4, <span class="string">&quot;ollvm&quot;</span>);</span><br><span class="line">        v6 = <span class="number">-1578842400</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1938015978</span>:</span><br><span class="line">        result = sub_F830(v4, <span class="string">&quot;ceshi&quot;</span>);</span><br><span class="line">        v6 = <span class="number">1493239651</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2056492010</span>:</span><br><span class="line">        result = sub_F77C(v4);</span><br><span class="line">        v7 = result &gt; <span class="number">0xA</span>;</span><br><span class="line">        v6 = <span class="number">256858465</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对比看下混淆前和混淆后的代码。原本我们只需要看if条件就知道意义的。但是现在就需要不停的顺着条件。进入case一步步的分析每一步。如果是这么简单的例子。我们还是可以静态分析看的出来真正的条件。但是代码量过于庞大时就很难跟踪分析了。</p><h2 id="思路：先射箭后画靶"><a href="#思路：先射箭后画靶" class="headerlink" title="思路：先射箭后画靶"></a>思路：先射箭后画靶</h2><p>先简单说下如何先射箭后画靶，上面这个例子的逻辑比较简单。初学的情况，我们可以直接静态分析下，找出所有的真实块。然后用ida的keypatch插件来手动将真实块关联起来。再用ida解析看看结果是否和我们的混淆前的一致。结果一致后。我们就可以开始写unidbg代码来根据特征匹配真实块。特征匹配的结果可以和我们静态分析的结果对比看是否一致。最后只要unidbg实现出我们手动关联的效果，就完成了自动化反混淆了。下面我就先手动的还原。</p><h2 id="一、手动还原"><a href="#一、手动还原" class="headerlink" title="一、手动还原"></a>一、手动还原</h2><p>1、找出所有真实块以及对应的汇编地址，标准的ollvm虚假块中一般只有简单的修改v6的值，其他的基本都是真实块</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">-1521928633</span>:                            <span class="comment">//0xF694</span></span><br><span class="line">        v9 = v8 &gt; <span class="number">0x1E</span>;</span><br><span class="line">        v6 = <span class="number">-124633339</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">-124633339</span>:                            <span class="comment">//0xF6BC</span></span><br><span class="line">        <span class="keyword">if</span> ( v9 )</span><br><span class="line">          v3 = <span class="number">1872828810</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          v3 = <span class="number">1744272424</span>;</span><br><span class="line">        v6 = v3;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">256858465</span>:                                <span class="comment">//0xF624</span></span><br><span class="line">        <span class="keyword">if</span> ( v7 )</span><br><span class="line">          v2 = <span class="number">1938015978</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          v2 = <span class="number">1363893773</span>;</span><br><span class="line">        v6 = v2;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1089662144</span>:                            <span class="comment">//0xF750</span></span><br><span class="line">        result = sub_F8E4(v5, v4);</span><br><span class="line">        v6 = <span class="number">-1929161090</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1363893773</span>:                            <span class="comment">//0xF678</span></span><br><span class="line">        result = sub_F77C(v4);</span><br><span class="line">        v8 = result;</span><br><span class="line">        v6 = <span class="number">-1521928633</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1744272424</span>:                            <span class="comment">//0xF710</span></span><br><span class="line">        result = sub_F830(v4, <span class="string">&quot;fla&quot;</span>);</span><br><span class="line">        v6 = <span class="number">1697837166</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1872828810</span>:                            <span class="comment">//0xF6E0</span></span><br><span class="line">        result = sub_F830(v4, <span class="string">&quot;ollvm&quot;</span>);</span><br><span class="line">        v6 = <span class="number">-1578842400</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1938015978</span>:                            <span class="comment">//0xF648</span></span><br><span class="line">        result = sub_F830(v4, <span class="string">&quot;ceshi&quot;</span>);</span><br><span class="line">        v6 = <span class="number">1493239651</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2056492010</span>:                            <span class="comment">//0xF5F8</span></span><br><span class="line">                result = sub_F77C(v4);</span><br><span class="line">        v7 = result &gt; <span class="number">0xA</span>;</span><br><span class="line">        v6 = <span class="number">256858465</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>找出所有真实块的地址后。接着就是顺着逻辑将他们全部串联起来。这里我举两个比较典型的例子。先从函数开始的地方开始。下面简单整理下第一个真实块的关联</p><p>根据v6=910266824第一次赋值。我们锁定到下面的case分支</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __int64 __usercall calcKey@&lt;X0&gt;(<span class="keyword">unsigned</span> __int64 result@&lt;X0&gt;, __int64 a2@&lt;X8&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  v6 = <span class="number">910266824</span>;</span><br><span class="line">  v5 = a2;</span><br><span class="line">  v4 = result;</span><br><span class="line">  <span class="keyword">while</span> ( v6 != <span class="number">-1929161090</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( v6 )</span><br><span class="line">    &#123;</span><br><span class="line">      ....</span><br><span class="line">      <span class="keyword">case</span> <span class="number">910266824</span>:</span><br><span class="line">        v6 = <span class="number">2056492010</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      ....</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2056492010</span>:                            <span class="comment">//0xF5F8        第一个真实块</span></span><br><span class="line">        result = sub_F77C(v4);</span><br><span class="line">        v7 = result &gt; <span class="number">0xA</span>;</span><br><span class="line">        v6 = <span class="number">256858465</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">     ....</span><br><span class="line">     <span class="keyword">case</span> <span class="number">256858465</span>:                                <span class="comment">//0xF624        第二个真实块</span></span><br><span class="line">        <span class="keyword">if</span> ( v7 )</span><br><span class="line">          v2 = <span class="number">1938015978</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          v2 = <span class="number">1363893773</span>;</span><br><span class="line">        v6 = v2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面的代码。我们第一个真实块。应该是直接跳转到0xF5F8这个位置。而第一个跳转的位置。应该是在while循环前。先贴上第一个block的汇编代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000000F470 loc_F470                             </span><br><span class="line">.text:000000000000F470                 LDR             W8, [SP,#0x50+var_2C]</span><br><span class="line">.text:000000000000F474                 MOV             W9, #0x567E</span><br><span class="line">.text:000000000000F478                 MOVK            W9, #0x8D03,LSL#16</span><br><span class="line">.text:000000000000F47C                 CMP             W8, W9</span><br><span class="line">.text:000000000000F480                 STR             W8, [SP,#0x50+var_44]</span><br><span class="line">.text:000000000000F484                 B.EQ            loc_F76C</span><br><span class="line">.text:000000000000F488                 B               loc_F48C</span><br></pre></td></tr></table></figure><p>我们可以直接第一句就跳转到真实指令。因为这里使用的while是fla混淆的所以这些数据我们并不需要去执行。修改代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000000F470 loc_F470                           </span><br><span class="line">.text:000000000000F470                 LDR             W8, [SP,#0x50+var_2C]</span><br><span class="line">.text:000000000000F474                 B               loc_F5F8 ; Keypatch modified this from:</span><br><span class="line">.text:000000000000F474                                         ;   MOV W9, #0x567E</span><br><span class="line">.text:000000000000F478 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000000F478                 MOVK            W9, #0x8D03,LSL#16</span><br><span class="line">.text:000000000000F47C                 CMP             W8, W9</span><br><span class="line">.text:000000000000F480                 STR             W8, [SP,#0x50+var_44]</span><br><span class="line">.text:000000000000F484                 B.EQ            loc_F76C</span><br><span class="line">.text:000000000000F488                 B               loc_F48C</span><br></pre></td></tr></table></figure><p>这样第一个块就关联好了。然后继续关联第二个真实块0xF624。下面先列出第一个真实块的汇编</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000000F5F8 loc_F5F8                                </span><br><span class="line">.text:000000000000F5F8                                     </span><br><span class="line">.text:000000000000F5F8                 LDR             X0, [SP,#0x50+var_40]</span><br><span class="line">.text:000000000000F5FC                 BL              sub_F77C</span><br><span class="line">.text:000000000000F600                 CMP             X0, #0xA</span><br><span class="line">.text:000000000000F604                 CSET            W8, HI</span><br><span class="line">.text:000000000000F608                 MOV             W9, #1</span><br><span class="line">.text:000000000000F60C                 AND             W8, W8, W9</span><br><span class="line">.text:000000000000F610                 STURB           W8, [X29,#var_11]</span><br><span class="line">.text:000000000000F614                 MOV             W8, #0x5961</span><br><span class="line">.text:000000000000F618                 MOVK            W8, #0xF4F,LSL#16</span><br><span class="line">.text:000000000000F61C                 STR             W8, [SP,#0x50+var_2C]</span><br><span class="line">.text:000000000000F620                 B               loc_F778</span><br></pre></td></tr></table></figure><p>汇编的最后是跳转到了0xf778。这里就是又进入控制分发器了。我们直接让他跳转到第二个真实块。修改最后一行汇编如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000000F618                 MOVK            W8, #0xF4F,LSL#16</span><br><span class="line">.text:000000000000F61C                 STR             W8, [SP,#0x50+var_2C]</span><br><span class="line">.text:000000000000F620                 B               loc_F624 ; Keypatch modified this from:</span><br><span class="line">.text:000000000000F620                                         ;   B loc_F778</span><br></pre></td></tr></table></figure><p>第二个真实块这里就有点特殊了。这是一个分支让我们的第三个真实块可能是0xF648位置也可能是0xF678位置。我们先看看c++的部分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">256858465</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v7 )                <span class="comment">//根据条件让第三个真实块不固定了</span></span><br><span class="line">          v2 = <span class="number">1938015978</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          v2 = <span class="number">1363893773</span>;</span><br><span class="line">        v6 = v2;</span><br></pre></td></tr></table></figure><p>那么这里我们就不能简单的b跳转哪个真实块了。这里我的预想是把这块的代码修改成如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">256858465</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v7 )                <span class="comment">//根据条件让第三个真实块不固定了</span></span><br><span class="line">          <span class="comment">//直接跳转到0xF648</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="comment">//直接跳转到0xF678</span></span><br><span class="line">        v6 = v2;</span><br></pre></td></tr></table></figure><p>但是我们肯定不能修改c++的代码。所以看看这个真实块的汇编部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000000F624 loc_F624                                </span><br><span class="line">.text:000000000000F624                                         </span><br><span class="line">.text:000000000000F624                 LDURB           W8, [X29,#var_11]</span><br><span class="line">.text:000000000000F628                 MOV             W9, #0xC6EA</span><br><span class="line">.text:000000000000F62C                 MOVK            W9, #0x7383,LSL#16</span><br><span class="line">.text:000000000000F630                 MOV             W10, #0x5E0D</span><br><span class="line">.text:000000000000F634                 MOVK            W10, #0x514B,LSL#16</span><br><span class="line">.text:000000000000F638                 TST             W8, #1</span><br><span class="line">.text:000000000000F63C                 CSEL            W8, W9, W10, NE</span><br><span class="line">.text:000000000000F640                 STR             W8, [SP,#0x50+var_2C]</span><br><span class="line">.text:000000000000F644                 B               loc_F778</span><br></pre></td></tr></table></figure><p>这里可以看到那个v7的值就是w8。所以我们修改成判断w8=1。就跳转到0xf648。否则跳转到0xf678。下面贴上修改后的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000000F624 loc_F624                                </span><br><span class="line">.text:000000000000F624                                         </span><br><span class="line">.text:000000000000F624                 LDURB           W8, [X29,#var_11]</span><br><span class="line">.text:000000000000F628                 MOV             W9, #0xC6EA</span><br><span class="line">.text:000000000000F62C                 MOVK            W9, #0x7383,LSL#16</span><br><span class="line">.text:000000000000F630                 MOV             W10, #0x5E0D</span><br><span class="line">.text:000000000000F634                 MOVK            W10, #0x514B,LSL#16</span><br><span class="line">.text:000000000000F638                 CMP             W8, #1  ; Keypatch modified this from:</span><br><span class="line">.text:000000000000F638                                         ;   TST W8, #1</span><br><span class="line">.text:000000000000F63C                 B.EQ            loc_F648 ; Keypatch modified this from:</span><br><span class="line">.text:000000000000F63C                                         ;   CSEL W8, W9, W10, NE</span><br><span class="line">.text:000000000000F640                 B               loc_F678 ; Keypatch modified this from:</span><br><span class="line">.text:000000000000F640                                         ;   STR W8, [SP,#0x50+var_2C]</span><br></pre></td></tr></table></figure><p>再往后基本就都是这两种方式关联了。下面我就直接列一下手动修改后的跳转关联</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0xF474        ---&gt;        0xF5F8</span><br><span class="line">0xF620        ---&gt;        0xF624</span><br><span class="line">0xF63C        ---&gt;        0xF648</span><br><span class="line">0xF640        ---&gt;        0xF678</span><br><span class="line">0xF664        ---&gt;        0xF750</span><br><span class="line">0xF690        ---&gt;        0xF694</span><br><span class="line">0xF6B8        ---&gt;        0xF6BC</span><br><span class="line">0xF6D4        ---&gt;        0xF6E0</span><br><span class="line">0xF6D8        ---&gt;        0xF710</span><br><span class="line">0xF6FC        ---&gt;        0xF750</span><br></pre></td></tr></table></figure><p>上面的跳转修改完后。最后把让我们while循环的跳转给改成nop。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000000F778 loc_F778                                </span><br><span class="line">.text:000000000000F778                                        </span><br><span class="line">.text:000000000000F778                 B               loc_F470            &#x2F;&#x2F;修改成nop</span><br></pre></td></tr></table></figure><p>最后我们f5解析一下。基本结果就差不多了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __usercall <span class="title">calcKey</span><span class="params">(<span class="keyword">unsigned</span> __int64 result@&lt;X0&gt;, __int64 a2@&lt;X8&gt;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// x0</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [xsp+10h] [xbp-40h]</span></span><br><span class="line">  __int64 v4; <span class="comment">// [xsp+18h] [xbp-38h]</span></span><br><span class="line">  <span class="keyword">bool</span> v5; <span class="comment">// [xsp+4Fh] [xbp-1h]</span></span><br><span class="line"></span><br><span class="line">  v4 = a2;</span><br><span class="line">  v3 = result;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)sub_F77C(result) &gt; <span class="number">0xA</span> == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_F830(v3, <span class="string">&quot;ceshi&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v5 = (<span class="keyword">unsigned</span> __int64)sub_F77C(v3) &gt; <span class="number">0x1E</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v5 == <span class="number">1</span> )</span><br><span class="line">      sub_F830(v3, <span class="string">&quot;ollvm&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      sub_F830(v3, <span class="string">&quot;fla&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  v2 = sub_F8E4(v4, v3);</span><br><span class="line">  sub_F77C(v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、自动化反混淆"><a href="#二、自动化反混淆" class="headerlink" title="二、自动化反混淆"></a>二、自动化反混淆</h2><p>第一步先用unidbg跑通流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlaTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AndroidEmulator emulator;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> VM vm;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DvmClass mainActivityDvm;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FlaTest bcfTest = <span class="keyword">new</span> FlaTest();</span><br><span class="line">        bcfTest.call_calckey();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FlaTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        emulator = AndroidEmulatorBuilder</span><br><span class="line">                .for64Bit()</span><br><span class="line">                .build();</span><br><span class="line">        Memory memory = emulator.getMemory();</span><br><span class="line">        LibraryResolver resolver = <span class="keyword">new</span> AndroidResolver(<span class="number">23</span>);</span><br><span class="line">        memory.setLibraryResolver(resolver);</span><br><span class="line">        vm = emulator.createDalvikVM(<span class="keyword">null</span>);</span><br><span class="line">        vm.setVerbose(<span class="keyword">false</span>);</span><br><span class="line">        mainActivityDvm = vm.resolveClass(<span class="string">&quot;com/example/ollvmdemo2/MainActivity&quot;</span>);</span><br><span class="line">        DalvikModule dm = vm.loadLibrary(<span class="keyword">new</span> File(<span class="string">&quot;unidbg-android/src/test/resources/example_binaries/ollvm_fla/libnative-lib.so&quot;</span>), <span class="keyword">false</span>);</span><br><span class="line">        dm.callJNI_OnLoad(emulator);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//主动调用目标函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">call_calckey</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringObject res = mainActivityDvm.callStaticJniMethodObject(emulator, <span class="string">&quot;stringFromJNI()Ljava/lang/String;&quot;</span>);</span><br><span class="line">        System.out.println(res.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先找找真实块和混淆块的特征，然后区分它们。可以看出来这个案例中的控制流程只要靠v6这个变量来驱动。真实块中有条件判断。有函数调用。而混淆块中只有对v6的修改。接下来看看混淆块的汇编代码是什么样的。当然不同的混淆参数也会导致特征不一样。要根据实际情况来进行调整。下面是一个混淆块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000000F700 loc_F700  </span><br><span class="line">.text:000000000000F700                 MOV             W8, #0x50C6</span><br><span class="line">.text:000000000000F704                 MOVK            W8, #0x35F,LSL#16</span><br><span class="line">.text:000000000000F708                 STR             W8, [SP,#0x50+var_2C]</span><br><span class="line">.text:000000000000F70C                 B               loc_F778</span><br></pre></td></tr></table></figure><p>这个例子的混淆特征就是一个4行指令的block。mov、movk、str、b。由于我们看到例子中用于驱动控制流程的变量是同一个。所以str的写入地址也可以当做特征。如果无法通过混淆block的特征区分精准。就通过真实块的特征区分。比如block中有bl指令跳转到函数的是真实块。有运算符操作的是真实块。有条件判断的是真实块</p><p>能够区分出混淆块和真实块之后。最后的工作就是完成block之间的关系连接。找出所有的真实块。然后直接跳转过去</p><p>还原流程分析完后。接着列一下实现的步骤</p><p>1、将所有执行的block保存下来</p><p>2、遍历所有block。将真实的block筛选出来</p><p>3、遍历所有真实block。用b指令将他们串联起来。</p><p>下面是保存所有执行块的代码部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用来保存所有执行过的block</span></span><br><span class="line">ArrayList&lt;Pair&lt;Long, Capstone.CsInsn[]&gt;&gt; blocks=<span class="keyword">new</span> ArrayList&lt;Pair&lt;Long, Capstone.CsInsn[]&gt;&gt;();</span><br><span class="line">  <span class="comment">//主动调用目标函数</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">call_calckey</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//这里BlockHook就是按照一个block的触发</span></span><br><span class="line">      emulator.getBackend().hook_add_new(<span class="keyword">new</span> BlockHook() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hook</span><span class="params">(Backend backend, <span class="keyword">long</span> address, <span class="keyword">int</span> size, Object user)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//这里的insns是整个block。</span></span><br><span class="line">              Capstone.CsInsn[] insns = emulator.disassemble(address, size,<span class="number">0</span>);</span><br><span class="line">              blocks.add(<span class="keyword">new</span> Pair&lt;Long, Capstone.CsInsn[]&gt;(address,insns));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,<span class="number">0x4000F44C</span>,<span class="number">0x4000F44C</span>+<span class="number">0x330</span>,<span class="keyword">null</span>);</span><br><span class="line">      <span class="comment">//调用一个返回值为object的静态的jni函数</span></span><br><span class="line">      StringObject res = mainActivityDvm.callStaticJniMethodObject(emulator, <span class="string">&quot;stringFromJNI()Ljava/lang/String;&quot;</span>);</span><br><span class="line">      System.out.println(res.toString());</span><br><span class="line">      <span class="keyword">for</span>(Pair&lt;Long, Capstone.CsInsn[]&gt; block : blocks)&#123;</span><br><span class="line">          System.out.println(String.format(<span class="string">&quot;block address:0x%x&quot;</span>,block.getKey()) );</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这样就将所有执行的block给保存了出来。其中保存的address就是块的第一个地址。后面我们连线到真实块。就是要直接跳到第一个地址。接下来筛选出所有的真实block。这里我的筛选比较简单。能满足我这个例子。其他比较复杂需要调整下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">//如果指令在队列中。则返回true。这是用来筛选block。如果block中有非以下指令的。说明很有可能是一个真实块</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">OpstrContains</span><span class="params">(String opstr)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; flags= <span class="keyword">new</span> ArrayList(Arrays.asList(<span class="string">&quot;ldur&quot;</span>,<span class="string">&quot;ldr&quot;</span>,<span class="string">&quot;str&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;movz&quot;</span>,<span class="string">&quot;movk&quot;</span>,<span class="string">&quot;cmp&quot;</span>,<span class="string">&quot;b.eq&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span>(flags.contains(opstr))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//存储所有真实的block块</span></span><br><span class="line">        ArrayList&lt;Pair&lt;Long, Capstone.CsInsn[]&gt;&gt; readlyBlock=<span class="keyword">new</span> ArrayList&lt;Pair&lt;Long, Capstone.CsInsn[]&gt;&gt;();</span><br><span class="line">        <span class="comment">//过滤出真实块</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LoadReadlyAddress</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="comment">//第一个块肯定是要有的</span></span><br><span class="line">        readlyBlock.add(blocks.get(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;blocks.size();i++)&#123;</span><br><span class="line">            Pair&lt;Long, Capstone.CsInsn[]&gt; pdata=blocks.get(i);</span><br><span class="line">            Capstone.CsInsn[] insns=pdata.getValue();</span><br><span class="line">            Long address=pdata.getKey();</span><br><span class="line">            <span class="keyword">boolean</span> isReadly=<span class="keyword">false</span>;</span><br><span class="line">              <span class="comment">//遍历所有指令。检查出真实块。保存起来</span></span><br><span class="line">            <span class="keyword">for</span>(Capstone.CsInsn ins :insns)&#123;</span><br><span class="line">                <span class="keyword">if</span>(readlyBlock.contains(address))&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!OpstrContains(ins.mnemonic))&#123;</span><br><span class="line">                    isReadly=<span class="keyword">true</span>;</span><br><span class="line">                    String opstr= ARM.assembleDetail(emulator,ins,address,<span class="keyword">false</span>,<span class="keyword">false</span>);</span><br><span class="line">                    System.out.println(String.format(<span class="string">&quot;block readly address:0x%x opstr:%s&quot;</span>,ins.address,opstr) );</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//                    String opstr= ARM.assembleDetail(emulator,ins,address,false,false);</span></span><br><span class="line"><span class="comment">//                    System.out.println(String.format(&quot;block fla address:0x%x opstr:%s&quot;,ins.address,opstr) );</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isReadly)&#123;</span><br><span class="line">                readlyBlock.add(<span class="keyword">new</span> Pair&lt;Long,Capstone.CsInsn[]&gt;(address,insns));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>获取到真实块之后。我们就需要进行跳转。首先处理我们的第一种关联方式。分支的关联方式比较复杂我们放的下面再说</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">                LoadReadlyAddress();</span><br><span class="line">        String modulePath=<span class="string">&quot;unidbg-android/src/test/resources/example_binaries/ollvm_fla/libnative-lib.so&quot;</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] sodata=readFile(modulePath);</span><br><span class="line">        <span class="comment">//遍历真实块。然后直接修改成跳转真实块</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;readlyBlock.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;readlyBlock.size()-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//获取当前真实块</span></span><br><span class="line">                Pair&lt;Long, Capstone.CsInsn[]&gt;block=readlyBlock.get(i);</span><br><span class="line">                System.out.println(String.format(<span class="string">&quot;curBlock address:0x%x&quot;</span>,block.getKey()));</span><br><span class="line">                <span class="comment">//获取下一个真实块</span></span><br><span class="line">                Pair&lt;Long, Capstone.CsInsn[]&gt;nextBlock=readlyBlock.get(i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//取出当前真实块最后一个指令的地址</span></span><br><span class="line">                <span class="keyword">int</span> end_address= GetEndAddress(block.getValue()).intValue();</span><br><span class="line">                <span class="keyword">if</span>(end_address&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取下一个真实块第一个指令的地址</span></span><br><span class="line">                <span class="keyword">int</span> start_address=GetStartAddress(nextBlock.getValue()).intValue();</span><br><span class="line">                <span class="comment">//这里是最后跳转出结束的地方。由于已经被我们nop掉了循环。所以如果下一个块是跳转出while的。可以直接跳过了</span></span><br><span class="line">                <span class="keyword">if</span>(nextBlock.getKey().intValue()==<span class="number">0x4000f76c</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//准备转换汇编代码进行替换</span></span><br><span class="line">                <span class="keyword">try</span> (Keystone keystone = <span class="keyword">new</span> Keystone(KeystoneArchitecture.Arm64, KeystoneMode.LittleEndian)) &#123;</span><br><span class="line">                    <span class="keyword">int</span> subAddress=start_address-end_address;</span><br><span class="line">                    <span class="comment">//用来patch修改的asm指令。这里是要计算出当前地址的相对地址跳转。所以上面要减一下。</span></span><br><span class="line">                    String asmStr=String.format(<span class="string">&quot;b #0x%x&quot;</span>,subAddress);</span><br><span class="line">                    <span class="comment">//这个是我们显示日志看结果的。看看和我们之前手动分析的是不是差不多</span></span><br><span class="line">                    String showStr=String.format(<span class="string">&quot;b #0x%x&quot;</span>,start_address);</span><br><span class="line"><span class="comment">//                    System.out.println(String.format(&quot;address:0x%x chang asm:%s&quot;,end_address,showStr));</span></span><br><span class="line">                    <span class="comment">//转换汇编</span></span><br><span class="line">                    KeystoneEncoded encoded = keystone.assemble(asmStr);</span><br><span class="line">                    <span class="keyword">byte</span>[] patch = encoded.getMachineCode();</span><br><span class="line">                    <span class="keyword">if</span> (patch.length &lt;=<span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;转换汇编失败&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">//                    System.out.println(bytesToHexString(patch));</span></span><br><span class="line">                    <span class="comment">//替换原来的字节数据</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> y =<span class="number">0</span>;y&lt;patch.length;y++)&#123;</span><br><span class="line">                        sodata[end_address+y]=patch[y];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环的地方给nop掉</span></span><br><span class="line">        <span class="keyword">byte</span>[] nop_byte=<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">0x1F</span>,<span class="number">0x20</span>,<span class="number">0x03</span>,(<span class="keyword">byte</span>)<span class="number">0xD5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> nop_address=<span class="number">0xF778</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y =<span class="number">0</span>;y&lt;nop_byte.length;y++)&#123;</span><br><span class="line">            sodata[nop_address+y]=nop_byte[y];</span><br><span class="line">        &#125;</span><br><span class="line">        String savepath=<span class="string">&quot;unidbg-android/src/test/resources/example_binaries/ollvm_fla/libnative-lib.patch.so&quot;</span>;</span><br><span class="line">        writeFile(sodata,savepath);</span><br><span class="line">        System.out.println(<span class="string">&quot;处理完成&quot;</span>);</span><br></pre></td></tr></table></figure><p>然后看看日志。因为我们之前已经静态分析解混淆过一次了。所以结果我们是清楚的。那么下面的结果对比我们手动的答案要不同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">address:0xf484 chang asm:b #0xf5f8</span><br><span class="line">address:0xf620 chang asm:b #0xf624</span><br><span class="line">address:0xf644 chang asm:b #0xf648</span><br><span class="line">address:0xf654 chang asm:b #0xf750</span><br><span class="line">address:0xf758 chang asm:b #0xf76c</span><br></pre></td></tr></table></figure><p>问题其实就是因为我们没有处理分支。只是单纯根据执行结果在跳转。那么这里我们需要判断一下csel来特殊处理一下。</p><p>需要处理的地方有两处。</p><p>1、分支的当前关联。也就是仿照我们手动关联时的cmp + b.eq + b来实现跳转两个地方</p><p>2、未执行分支的后续关联。手动关联是我们虽然不知道执行哪个分支。但是看v6的变化可以找到下一个真实块。但是自动化时。我们前面获取到的真实块。都是基于执行流程的。未执行部分的block块我们并未保存下来。所以我们要不就是一步步解析未执行分支的后续关联。要不就是直接修改分支判断的寄存器。把另一条分支的执行块也给记录下来。</p><p>我们先调整下hook部分的代码。将分支不同的执行块结果保存出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">                emulator.getBackend().hook_add_new(<span class="keyword">new</span> BlockHook() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hook</span><span class="params">(Backend backend, <span class="keyword">long</span> address, <span class="keyword">int</span> size, Object user)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//这里的insns是整个block。</span></span><br><span class="line">                Capstone.CsInsn[] insns = emulator.disassemble(address, size,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//                System.out.println(String.format(&quot;address:0x%x size:0x%x&quot;,address,insns.length));</span></span><br><span class="line">                <span class="keyword">if</span>(brance_data==<span class="number">0</span>)&#123;</span><br><span class="line">                    blocks.add(<span class="keyword">new</span> Pair&lt;Long, Capstone.CsInsn[]&gt;(address,insns));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    branchBlocks.add(<span class="keyword">new</span> Pair&lt;Long, Capstone.CsInsn[]&gt;(address,insns));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">0x4000F44C</span>,<span class="number">0x4000F778</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//碰到csel的时候把w8的值修改下。控制走其他分支</span></span><br><span class="line">        emulator.getBackend().hook_add_new(<span class="keyword">new</span> CodeHook() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hook</span><span class="params">(Backend backend, <span class="keyword">long</span> address, <span class="keyword">int</span> size, Object user)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//这里的insns是整个block。</span></span><br><span class="line">                Capstone.CsInsn[] insns = emulator.disassemble(address, size,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">for</span>(Capstone.CsInsn ins :insns)&#123;</span><br><span class="line">                    <span class="comment">//这里就是控制如果brance_data为0就固定走第一个分支。为1就固定走第二个分支</span></span><br><span class="line">                    <span class="keyword">if</span>(ins.mnemonic.equals(<span class="string">&quot;csel&quot;</span>))&#123;</span><br><span class="line">                        <span class="keyword">int</span> w9=emulator.getBackend().reg_read(Arm64Const.UC_ARM64_REG_W9).intValue();</span><br><span class="line">                        <span class="keyword">int</span> w10=emulator.getBackend().reg_read(Arm64Const.UC_ARM64_REG_W10).intValue();</span><br><span class="line">                        <span class="keyword">if</span>(brance_data==<span class="number">0</span>)&#123;</span><br><span class="line">                            emulator.getBackend().reg_write(Arm64Const.UC_ARM64_REG_W10,w9);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            emulator.getBackend().reg_write(Arm64Const.UC_ARM64_REG_W9,w10);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">0x4000F44C</span>,<span class="number">0x4000F778</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用一个返回值为object的静态的jni函数</span></span><br><span class="line">        StringObject res = mainActivityDvm.callStaticJniMethodObject(emulator, <span class="string">&quot;stringFromJNI()Ljava/lang/String;&quot;</span>);</span><br><span class="line">        System.out.println(res.toString());</span><br><span class="line">        brance_data=<span class="number">1</span>;</span><br><span class="line">        StringObject res2 = mainActivityDvm.callStaticJniMethodObject(emulator, <span class="string">&quot;stringFromJNI()Ljava/lang/String;&quot;</span>);</span><br><span class="line">        System.out.println(res2.toString());</span><br><span class="line">        LoadReadlyAddress();</span><br></pre></td></tr></table></figure><p>然后就可以在跳转的地方获取到两个跳转的真实块地址了。然后打上patch替换掉原来的三行汇编</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">                                <span class="comment">//获取当前块中的csel地址。如果没有csel则为0</span></span><br><span class="line">                Long cselAddress=GetCselddress(block.getValue());</span><br><span class="line">                <span class="comment">//存在csel指令说明是有分支。然后要特殊处理</span></span><br><span class="line">                <span class="keyword">if</span>(cselAddress&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//获取另一个分支的下一个真实块</span></span><br><span class="line">                    <span class="keyword">int</span> start_address2=GetBranchReadlyAddress(block.getKey());</span><br><span class="line">                    <span class="keyword">try</span> (Keystone keystone = <span class="keyword">new</span> Keystone(KeystoneArchitecture.Arm64, KeystoneMode.LittleEndian))&#123;</span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        *要改以下三行的汇编。前面获取出来的cselAddress是CSEL的地址。</span></span><br><span class="line"><span class="comment">                        * TST             W8, #1</span></span><br><span class="line"><span class="comment">                        * CSEL            W8, W9, W10, NE</span></span><br><span class="line"><span class="comment">                        * STR             W8, [SP,#0x50+var_2C]</span></span><br><span class="line"><span class="comment">                        * */</span></span><br><span class="line">                        <span class="keyword">int</span> subAddress1=start_address-(cselAddress.intValue())+<span class="number">4</span>;</span><br><span class="line">                        <span class="keyword">int</span> subAddress2=start_address2-(cselAddress.intValue())+<span class="number">4</span>;</span><br><span class="line">                        String asm1=<span class="string">&quot;cmp w8,#0x1&quot;</span>;</span><br><span class="line">                        String showAsm1=String.format(<span class="string">&quot;b.eq 0x%x&quot;</span>,start_address);</span><br><span class="line">                        String showAsm2=String.format(<span class="string">&quot;b #0x%x&quot;</span>,start_address2);</span><br><span class="line"><span class="comment">//                        System.out.println(String.format(&quot;address:0x%x chang asm1:%s&quot;,cselAddress,showAsm1));</span></span><br><span class="line"><span class="comment">//                        System.out.println(String.format(&quot;address:0x%x chang asm2:%s&quot;,cselAddress,showAsm2));</span></span><br><span class="line">                        String asm2=String.format(<span class="string">&quot;b.eq 0x%x&quot;</span>,subAddress1);</span><br><span class="line">                        String asm3=String.format(<span class="string">&quot;b 0x%x&quot;</span>,subAddress2);</span><br><span class="line">                        <span class="comment">//转换汇编</span></span><br><span class="line">                        KeystoneEncoded encoded = keystone.assemble(Arrays.asList(asm1,asm2,asm3));</span><br><span class="line">                        <span class="keyword">byte</span>[] patch = encoded.getMachineCode();</span><br><span class="line">                        <span class="keyword">if</span> (patch.length &lt;=<span class="number">0</span>) &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;转换汇编失败&quot;</span>);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(bytesToHexString(patch));</span><br><span class="line">                        <span class="comment">//这里去掉基址。再往上一个指令的位置开始写入</span></span><br><span class="line">                        <span class="keyword">int</span> replace_address=cselAddress.intValue()-<span class="number">4</span>;</span><br><span class="line">                        <span class="comment">//替换原来的字节数据</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> y =<span class="number">0</span>;y&lt;patch.length;y++)&#123;</span><br><span class="line">                            sodata[replace_address+y]=patch[y];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>贴上执行完成后解析的结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">__int64 __usercall calcKey@&lt;X0&gt;(__int64 a1@&lt;X0&gt;, __int64 a2@&lt;X8&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// x0</span></span><br><span class="line">  __int64 v4; <span class="comment">// [xsp+10h] [xbp-40h]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [xsp+18h] [xbp-38h]</span></span><br><span class="line"></span><br><span class="line">  v5 = a2;</span><br><span class="line">  v4 = a1;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)sub_F77C(a1) &gt; <span class="number">0xA</span> == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_F830(v4, <span class="string">&quot;ceshi&quot;</span>);</span><br><span class="line">    v2 = sub_F8E4(v5, v4);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v2 = sub_F77C(v4);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sub_F77C(v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比之前我们手动还原的结果看了下。还是差了点。但是当前的执行流程的反混淆结果可以看了。未执行部分的分支如何去关联我想了好久越想越复杂了。就没有继续倒腾了。有知道的大佬麻烦提点下。</p><p>中间还有一些细节处理的地方没有贴代码，我就直接丢上地址了。代码我都尽量写上注释了。</p><p><a href="https://github.com/dqzg12300/unidbg_tools.git">https://github.com/dqzg12300/unidbg_tools.git</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 反混淆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用unidbg去ollvm虚假分支反混淆</title>
      <link href="/2021/05/04/ollvm2/"/>
      <url>/2021/05/04/ollvm2/</url>
      
        <content type="html"><![CDATA[<p>从原理上面来讲。去除虚假分支其实很简单。所以先简单说下理论。</p><p>虚假分支的混淆会在增加大量的if else分支。增加静态分析的复杂度。但是实际在动态执行的时候。很多if else实际都是没有执行的。所以去掉虚假分支其实就是删除掉那些没有执行到的代码块。那么我们只要知道目标函数中，哪些汇编代码执行了，并且记录下执行汇编的address。然后把这些汇编以外的代码全部标记为nop。然后再用ida反汇编看到的结果。就直接是去掉虚假分支的结果了。</p><p>下面我们从准备环境开始。</p><a id="more"></a><h2 id="1、编译ollvm"><a href="#1、编译ollvm" class="headerlink" title="1、编译ollvm"></a>1、编译ollvm</h2><p>​    <code>mkdir ~/ollvm/llvm-project-llvmorg-9.0.1/build-release</code></p><p>​    <code>cd ~/ollvm/llvm-project-llvmorg-9.0.1/build-release</code></p><p>​    <code>cmake -G Ninja -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS=&quot;clang;clang++&quot; ../llvm</code></p><p>​    <code>ninja</code></p><h2 id="2、配置ndk，使用ollvm的clang来进行编译apk"><a href="#2、配置ndk，使用ollvm的clang来进行编译apk" class="headerlink" title="2、配置ndk，使用ollvm的clang来进行编译apk"></a>2、配置ndk，使用ollvm的clang来进行编译apk</h2><p>​    首先下载ndk，地址：<a href="https://developer.android.google.cn/ndk/downloads/">https://developer.android.google.cn/ndk/downloads/</a></p><p>​    然后将ollvm编译好的cmake-build-release这个目录下的bin、lib、include三个目录拷贝到下载的ndk的目录~/ndk/toolchains/llvm/prebuilt/linux-x86_64/中。</p><p>​    然后修改我们的apk项目中的使用ndk的目录。否则会默认使用sdk中的ndk来编译。找到local.properties增加<code>ndk.dir=/home/king/android-ndk-r21e</code></p><p>​    最后配置ollvm的参数在cpp/CMakeLists.txt中添加配置<code>add_definitions(&quot;-mllvm -bcf -mllvm -bcf_loop=3&quot;)</code></p><p>​    然后这里碰到了一个问题。就是带上-mllvm -bcf这个参数。就会导致一直在gradle build中。这个实际上是ollvm的一个bug。由于我拉去的分支是没有修复这个bug的。所以需要根据这个地址的提交代码修改下就可以了<a href="https://github.com/obfuscator-llvm/obfuscator/pull/76">https://github.com/obfuscator-llvm/obfuscator/pull/76</a></p><h2 id="3、写个native-cpp的简单逻辑代码。用来作为反混淆的目标。"><a href="#3、写个native-cpp的简单逻辑代码。用来作为反混淆的目标。" class="headerlink" title="3、写个native-cpp的简单逻辑代码。用来作为反混淆的目标。"></a>3、写个native-cpp的简单逻辑代码。用来作为反混淆的目标。</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> JNIEXPORT jstring JNICALL</span><br><span class="line">Java_com_example_ollvmdemo2_MainActivity_stringFromJNI(</span><br><span class="line">        JNIEnv *env,</span><br><span class="line">        jobject <span class="comment">/* this */</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> hello = <span class="string">&quot;Hello from C++&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (hello.length()&gt;<span class="number">10</span>)&#123;</span><br><span class="line">        hello=<span class="string">&quot;ceshi&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(hello.length()&gt;<span class="number">30</span>)&#123;</span><br><span class="line">        hello=<span class="string">&quot;ollvm&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        hello=<span class="string">&quot;fla&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(hello.c_str());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后。使用ida打开native-lib.so。然后发现混淆没有起作用</p><p><img src="/2021/05/04/ollvm2/image-20210510225854777.png" alt="image-20210510225854777"></p><p>这里编译使用的是clang++编译的。所以我们用clang++简单的测试一下混淆</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> hello=<span class="string">&quot;heheda ollvm&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (hello.length()&gt;<span class="number">10</span>)&#123;</span><br><span class="line">        hello=<span class="string">&quot;ceshi&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(hello.length()&gt;<span class="number">30</span>)&#123;</span><br><span class="line">        hello=<span class="string">&quot;ollvm&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        hello=<span class="string">&quot;fla&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; hello.c_str() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在ollvm的混淆处手动打个日志。看看混淆的目标函数是什么</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bogus</span><span class="params">(Function &amp;F)</span> </span>&#123;</span><br><span class="line">    errs() &lt;&lt; <span class="string">&quot;bcf: Started on function &quot;</span> &lt;&lt; F.getName() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着编译一下我们的测试例子</p><p><code>clang++  -mllvm -bcf main.cpp</code></p><p>编译结果如下，并没有看到对我们的main函数进行混淆处理。然后我们再测试下clang的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bcf: Started on function __cxx_global_var_init</span><br><span class="line">bcf: Started on function _GLOBAL__sub_I_main.cpp</span><br></pre></td></tr></table></figure><p><code>clang  -mllvm -bcf main.c</code></p><p>编译结果如下，有对我们的main函数进行混淆</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcf: Started on function main</span><br></pre></td></tr></table></figure><p>那么可以看出区别了。当我们是对c++的项目进行混淆时。要避免需要保护的代码在主函数中。因此，我们再修改下上面的测试代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">calcKey</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.length()&gt;<span class="number">10</span>)&#123;</span><br><span class="line">        data=<span class="string">&quot;ceshi&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(data.length()&gt;<span class="number">30</span>)&#123;</span><br><span class="line">        data=<span class="string">&quot;ollvm&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        data=<span class="string">&quot;fla&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> JNIEXPORT jstring JNICALL</span><br><span class="line">Java_com_example_ollvmdemo2_MainActivity_stringFromJNI(</span><br><span class="line">        JNIEnv *env,</span><br><span class="line">        jobject <span class="comment">/* this */</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> hello = <span class="string">&quot;Hello from C++&quot;</span>;</span><br><span class="line">    hello=calcKey(hello);</span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(hello.c_str());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么再进行一次混淆。结果如下。</p><p><img src="/2021/05/04/ollvm2/image-20210510231622603.png" alt="image-20210510231622603"></p><p>我们再看看calcKey里面想要保护的代码是否有混淆</p><p><img src="/2021/05/04/ollvm2/image-20210510231708102.png" alt="image-20210510231708102"></p><p>到这里准备的案例程序ok了。接着我们开始还原这个虚假分支的混淆。首先我们需要知道这个函数中哪些汇编执行了。所以我们要trace打印每一句执行了的汇编代码地址。</p><h2 id="4、使用unidbg模拟执行so"><a href="#4、使用unidbg模拟执行so" class="headerlink" title="4、使用unidbg模拟执行so"></a>4、使用unidbg模拟执行so</h2><p>先贴上大佬的github地址:<a href="https://github.com/zhkl0228/unidbg">https://github.com/zhkl0228/unidbg</a></p><p>然后先用unidbg把我们的so给模拟执行起来。下面贴上代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BcfTest</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AndroidEmulator emulator;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> VM vm;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DvmClass mainActivityDvm;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  BcfTest bcfTest = <span class="keyword">new</span> BcfTest();</span><br><span class="line">  bcfTest.call_calckey();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">BcfTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">  emulator = AndroidEmulatorBuilder</span><br><span class="line">    .for64Bit()</span><br><span class="line">    .build();</span><br><span class="line">  Memory memory = emulator.getMemory();</span><br><span class="line">  LibraryResolver resolver = <span class="keyword">new</span> AndroidResolver(<span class="number">23</span>);</span><br><span class="line">  memory.setLibraryResolver(resolver);</span><br><span class="line">  vm = emulator.createDalvikVM(<span class="keyword">null</span>);</span><br><span class="line">  vm.setVerbose(<span class="keyword">false</span>);</span><br><span class="line">  mainActivityDvm = vm.resolveClass(<span class="string">&quot;com/example/ollvmdemo2/MainActivity&quot;</span>);</span><br><span class="line">  DalvikModule dm = vm.loadLibrary(<span class="keyword">new</span> File(<span class="string">&quot;unidbg-android/src/test/resources/example_binaries/ollvm_bcf/libnative-lib.so&quot;</span>), <span class="keyword">false</span>);</span><br><span class="line">  dm.callJNI_OnLoad(emulator);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主动调用目标函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">call_calckey</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//调用一个返回值为object的静态的jni函数</span></span><br><span class="line">  StringObject res = mainActivityDvm.callStaticJniMethodObject(emulator, <span class="string">&quot;stringFromJNI()Ljava/lang/String;&quot;</span>);</span><br><span class="line">  System.out.println(res.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果是直接显示<code>ceshi</code>。接着我们需要把这个函数执行过程中的每个执行的汇编地址打印一下。</p><p>首先找到calcKey函数的起始位置0x124CC以及函数大小0x838</p><p><img src="/2021/05/04/ollvm2/image-20210511213205514.png" alt="image-20210511213205514"></p><p>接着给我们之前的代码加上一个tracecode监控。直接修改那个调用函数。在调用前先挂上监控</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">call_calckey</span><span class="params">()</span></span>&#123;</span><br><span class="line">        emulator.getBackend().hook_add_new(<span class="keyword">new</span> CodeHook() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hook</span><span class="params">(Backend backend, <span class="keyword">long</span> address, <span class="keyword">int</span> size, Object user)</span> </span>&#123;</span><br><span class="line">                  <span class="comment">//打印当前地址。这里要把unidbg使用的基址给去掉。</span></span><br><span class="line">                System.out.println(String.format(<span class="string">&quot;0x%x&quot;</span>,address-<span class="number">0x40000000</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">0x400124CC</span>,<span class="number">0x400124CC</span>+<span class="number">0x838</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//调用一个返回值为object的静态的jni函数</span></span><br><span class="line">        StringObject res = mainActivityDvm.callStaticJniMethodObject(emulator, <span class="string">&quot;stringFromJNI()Ljava/lang/String;&quot;</span>);</span><br><span class="line">        System.out.println(res.toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行完成后得到如下结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">0x124cc</span><br><span class="line">0x124d0</span><br><span class="line">0x124d4</span><br><span class="line">0x124d8</span><br><span class="line">0x124dc</span><br><span class="line">0x124e0</span><br><span class="line">0x124e4</span><br><span class="line">0x124e8</span><br><span class="line">0x124ec</span><br><span class="line">0x124f0</span><br><span class="line">0x124f4</span><br><span class="line">0x124f8</span><br><span class="line">0x124fc</span><br><span class="line">0x12500</span><br><span class="line">0x12504</span><br><span class="line">0x12508</span><br><span class="line">0x1250c</span><br><span class="line">0x12510</span><br><span class="line">0x12514</span><br><span class="line">0x12518</span><br><span class="line">0x1251c</span><br><span class="line">0x12520</span><br><span class="line">0x12524</span><br><span class="line">0x12528</span><br><span class="line">0x1252c</span><br><span class="line">0x12530</span><br><span class="line">0x12534</span><br><span class="line">0x12538</span><br><span class="line">0x12540</span><br><span class="line">0x12544</span><br><span class="line">0x12548</span><br><span class="line">0x1254c</span><br><span class="line">0x12550</span><br><span class="line">0x12554</span><br><span class="line">0x12558</span><br><span class="line">0x1255c</span><br><span class="line">0x12560</span><br><span class="line">0x12564</span><br><span class="line">0x12568</span><br><span class="line">0x12d04</span><br><span class="line">0x1256c</span><br><span class="line">0x12570</span><br><span class="line">0x12574</span><br><span class="line">0x12578</span><br><span class="line">0x1257c</span><br><span class="line">0x12580</span><br><span class="line">0x12584</span><br><span class="line">0x12588</span><br><span class="line">0x1258c</span><br><span class="line">0x12590</span><br><span class="line">0x12594</span><br><span class="line">0x12598</span><br><span class="line">0x1259c</span><br><span class="line">0x125a0</span><br><span class="line">0x125a4</span><br><span class="line">0x125a8</span><br><span class="line">0x125ac</span><br><span class="line">0x125b4</span><br><span class="line">0x125b8</span><br><span class="line">0x125bc</span><br><span class="line">0x125c0</span><br><span class="line">0x125c4</span><br><span class="line">0x125c8</span><br><span class="line">0x125cc</span><br><span class="line">0x125d0</span><br><span class="line">0x12b54</span><br><span class="line">0x12b58</span><br><span class="line">0x12b5c</span><br><span class="line">0x12b60</span><br><span class="line">0x12b64</span><br><span class="line">0x12b68</span><br></pre></td></tr></table></figure><p>这里的汇编地址就都是确定有执行到的了。</p><h2 id="5、idapython去虚假指令"><a href="#5、idapython去虚假指令" class="headerlink" title="5、idapython去虚假指令"></a>5、idapython去虚假指令</h2><p>上面获取到执行了的汇编地址。接下来我们用ida来执行py脚本把执行的部分进行高亮。并且将这个函数范围中的未执行的部分代码修改成nop。改成nop之后ida就不会把未执行的汇编解析出来了。这里可以直接使用idapython，也可以用对idapython进行包装的库。这里的例子用的sark来进行处理。<a href="https://github.com/tmr232/Sark">https://github.com/tmr232/Sark</a></p><p>用ida的插件keypatch看了下nop的对应字节是1f 20 03 d5</p><p><img src="/2021/05/04/ollvm2/image-20210511224318355.png" alt="image-20210511224318355"></p><p>下面附上py代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> sark</span><br><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">patch_code</span>(<span class="params">addr,code</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(code)):</span><br><span class="line">        idc.patch_byte(addr+i,code[i])</span><br><span class="line"></span><br><span class="line"><span class="comment">#将指定地址的字节修改成nop</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nop</span>(<span class="params">addr</span>):</span></span><br><span class="line">    nop_code=[<span class="number">0x1f</span>,<span class="number">0x20</span>,<span class="number">0x03</span>,<span class="number">0xd5</span>]</span><br><span class="line">    patch_code(addr,nop_code)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    logfilename=<span class="string">&quot;/Volumes/mac_disk/src/python_project/idapythonDemo/ollvm_bcf.log&quot;</span></span><br><span class="line">    <span class="comment">#定义要处理函数的起始和终止范围</span></span><br><span class="line">    start=<span class="number">0x124CC</span></span><br><span class="line">    end=<span class="number">0x124CC</span>+<span class="number">0x838</span></span><br><span class="line">    addrs=[]</span><br><span class="line">    <span class="comment">#将所有执行的汇编地址读取进来</span></span><br><span class="line">    <span class="keyword">with</span> open(logfilename,<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> logfile:</span><br><span class="line">        lines=logfile.readlines()</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            addrs.append(int(line.replace(<span class="string">&quot;\n&quot;</span>,<span class="string">&quot;&quot;</span>),<span class="number">16</span>))</span><br><span class="line">    <span class="comment">#所有执行过的汇编地址修改一下颜色。高亮起来便于查看</span></span><br><span class="line">    <span class="keyword">for</span> addr <span class="keyword">in</span> addrs:</span><br><span class="line">        line=sark.line.Line(addr)</span><br><span class="line">        line.color=<span class="number">0x00ffff</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#获取到目标函数内的所有汇编地址</span></span><br><span class="line">    funcLines=sark.lines(start,end)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> funcLines:</span><br><span class="line">        <span class="comment">#如果该行是code则判断颜色是否被我们标注成有效代码。</span></span><br><span class="line">        <span class="keyword">if</span> line.type==<span class="string">&quot;code&quot;</span>:</span><br><span class="line">            <span class="keyword">if</span> line.color!=<span class="number">0x00ffff</span>:</span><br><span class="line">                nop(line.ea)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后ida执行脚本一下。下面附上处理后的效果图</p><p><img src="/2021/05/04/ollvm2/image-20210511231252792.png" alt="image-20210511231252792"></p><p>然后看看F5解析出来的变成什么样子了</p><p><img src="/2021/05/04/ollvm2/image-20210511231310122.png" alt="image-20210511231310122"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 反混淆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android抓包学习的整理和归纳</title>
      <link href="/2021/05/04/zhuabao/"/>
      <url>/2021/05/04/zhuabao/</url>
      
        <content type="html"><![CDATA[<p>最近学习了各种抓包。为了防止忘记。学到的东西必须是整理一波啊。向大佬们看齐。如果有啥地方写的不对，希望大家多多指点</p><p>抓包主要是针对网络通讯数据，客户端向服务端上报的数据拦截下来。一般都是抓取http、https、tcp、udp。想要获取到数据包。有多种方式，下面简单列一下。</p><h2 id="抓包方式"><a href="#抓包方式" class="headerlink" title="抓包方式"></a>抓包方式</h2><p>1、hook app业务层，根据业务代码逻辑找到触发请求的函数，比如按钮触发，或者触发数据上报时的提示框等方式。分析后找到发送数据的地方hook打印。</p><p><strong>优点：不受app的防抓包手段的影响，只要能hook到就能抓到包。</strong></p><p><strong>缺点：必须分析app找关键点，并且每个不同的请求都要找对应的触发函数，效率太慢。</strong></p><a id="more"></a><p>2、系统框架层的hook。直接hook系统源码发送和接受数据的地方。</p><p><strong>优点：可以直接省略掉业务层的分析。因为业务层不论逻辑怎么样最终都是调用系统的或者是第三方的库来进行数据传输。并且通用性更好。基本不用修改就可以抓很多app的包。并且可以在这里直接打印堆栈回溯请求触发的函数，提高分析的效率。同样不受防抓包手段影响。</strong></p><p><strong>缺点：hook出来的抓包数据不便于我们分析和筛选。只能在日志中查找对应的数据，分析数据包会比较繁琐。简单的需求或者是溯源时使用比较好</strong></p><p>3、中间人抓包，使用charles、burp等抓包工具进行拦截，中间人抓包在https请求时，抓包软件的证书在中间冒充服务端接收客服端的请求。然后又冒充客户端，发送请求给服务端。在中间拿到了客户端和服务端的数据。</p><p><strong>优点：专业的抓包分析软件，更加友好的分析页面。更加强大的功能，例如可以拦截请求进行改写替换，安装证书可以解析抓到的https数据包。支持vpn抓包</strong></p><p><strong>缺点：防抓包手段针对的主要目标，例如服务端验证客户端证书，不正确就拒绝访问，我们需要把客户端的证书给dump出来，然后让中间人抓包使用指定证书。或者是客户端验证服务端证书。我们需要找到并hook去掉验证的代码。无法抓tcp和udp的包</strong></p><p>4、网卡抓包、路由抓包。如wireshark，科来之类的。</p><p><strong>优点：这种方式不受任何限制，并且通杀，绝对能抓到。</strong></p><p><strong>缺点：对于加密的数据没有办法。需要自己进行解密，对于http和https包的展示不太友好</strong></p><p>其中比较通用一点的是系统层的hook。所以我这里主要针对这个记录下系统层hook的方式抓取http、https、tcp、udp的数据。</p><h2 id="系统层hook抓包"><a href="#系统层hook抓包" class="headerlink" title="系统层hook抓包"></a>系统层hook抓包</h2><h3 id="1、java层的抓包"><a href="#1、java层的抓包" class="headerlink" title="1、java层的抓包"></a>1、java层的抓包</h3><p>首先贴一个网上找的经典的网络模型图。可以看出来。http包是处于应用层的一种封装，所以我们抓tcp包的时候就可以抓到http包。</p><p><img src="/2021/05/04/zhuabao/zhuabao.png" alt="image-20210524221336406"></p><p>最常听到别人说的一句话就是想要逆向先会正向。我们得先知道如何在android中发包。下面我直接封装两种不同库的http请求方式和一个tcp的请求。然后再顺着代码去分析。看是否能直接在一个地方hook。将这三种情况的包都能抓到。</p><p>先贴上用来测试当tcp服务端的代码。我在网上随便搜的：<a href="https://github.com/fschr/simpletcp.git">https://github.com/fschr/simpletcp.git</a></p><p>下面是我拿来测试的tcp server代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">from</span> simpletcp.tcpserver <span class="keyword">import</span> TCPServer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo</span>(<span class="params">ip, queue, data</span>):</span></span><br><span class="line">    queue.put(bytes(<span class="string">&quot;server recv &quot;</span>,<span class="string">&quot;UTF-8&quot;</span>)+data)</span><br><span class="line">    print(<span class="string">&quot;echo &quot;</span>+data.decode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"></span><br><span class="line">server = TCPServer(<span class="string">&quot;192.168.3.8&quot;</span>, <span class="number">5000</span>, echo)</span><br><span class="line">server.run()</span><br></pre></td></tr></table></figure><p>然后下面贴上java的代码。三种请求的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetByHttpURL</span><span class="params">(<span class="keyword">final</span> String url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String resultData=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                URL connUrl=<span class="keyword">new</span> URL (url);</span><br><span class="line">                HttpURLConnection urlConn= (HttpURLConnection)connUrl.openConnection (); </span><br><span class="line">                InputStreamReader in=<span class="keyword">new</span> InputStreamReader (urlConn.getInputStream());</span><br><span class="line">                BufferedReader buffer=<span class="keyword">new</span> BufferedReader (in);</span><br><span class="line">                String inputLine=<span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">while</span> (((inputLine=buffer.readLine()) !=<span class="keyword">null</span>)) &#123;</span><br><span class="line">                    resultData+=inputLine+<span class="string">&quot;\n&quot;</span>; </span><br><span class="line">                &#125;</span><br><span class="line">                in.close();</span><br><span class="line">                urlConn.disconnect();</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;GetByHttpURL &quot;</span>+resultData);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;GetByHttpURL error &quot;</span>+e.getMessage());</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetByOkHttp</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        OkHttpClient okHttpClient = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">        <span class="keyword">final</span> Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">                .url(url)</span><br><span class="line">                .get()<span class="comment">//默认就是GET请求，可以不写</span></span><br><span class="line">                .build();</span><br><span class="line">        Call call = okHttpClient.newCall(request);</span><br><span class="line">        call.enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;onFailure: &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;GetByOkHttp onResponse: &quot;</span> + response.body().string());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;GetByOkHttp error &quot;</span>+e.getMessage());</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoTcp</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">&quot;DoTcp bind tcp&quot;</span>);</span><br><span class="line">    Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;192.168.3.8&quot;</span>, <span class="number">5000</span>);</span><br><span class="line">    socket.setSoTimeout(<span class="number">10000</span>);</span><br><span class="line">    <span class="comment">//发送数据给服务端</span></span><br><span class="line">    OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">    outputStream.write(<span class="string">&quot;hello,server&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    socket.shutdownOutput();</span><br><span class="line">    <span class="comment">//读取数据</span></span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">    String line = br.readLine();</span><br><span class="line">    <span class="comment">//打印读取到的数据</span></span><br><span class="line">    Log.d(TAG, <span class="string">&quot;tcp server recv:&quot;</span> + line);</span><br><span class="line">    br.close();</span><br><span class="line">    socket.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    TextView tv = findViewById(R.id.sample_text);</span><br><span class="line">    tv.setText(stringFromJNI());</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;start send http&quot;</span>);</span><br><span class="line">                    GetByOkHttp(<span class="string">&quot;http://missking.cc/&quot;</span>);</span><br><span class="line">                    GetByHttpURL(<span class="string">&quot;http://10.ip138.com&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    DoTcp();</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;DoTcp error: &quot;</span> + e.getMessage());</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;DoTcp error: &quot;</span> + e.getMessage());</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面列出了HttpURLConnection请求。OkHttp3的库来请求。以及一个tcp的请求。我们知道http最终也是调用的tcp连接来传输的。所以我们直接分析tcp的调用流程即可。在调用链中。任意一个含有我们传递参数的位置都可以打印出想要的明文信息。但是我们要尽量的找一个更通用一些。能获取到数据更完整的点来hook。所以我们找到最后调用的native的位置。下面列出我们接下来的目标</p><p>1、找到tcp请求发送数据的native函数处</p><p>2、hook函数打印发送的数据以及目标服务器地址、端口。</p><p>3、找到tcp请求接受数据的native函数处</p><p>4、hook函数打印接收的数据以及目标服务器地址、端口。</p><p>目标服务器地址和端口我们直接hook了Socket的构造函数即可拿到。所以直接分析发送数据部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public abstract class OutputStream   //这个OutputStream是一个抽象类，我们需要找到这个对象的真实类型</span></span><br><span class="line">OutputStream outputStream = socket.getOutputStream();</span><br><span class="line"><span class="comment">//找到对应的真实类型后，再找到对应的write函数</span></span><br><span class="line">outputStream.write(<span class="string">&quot;hello,server&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"><span class="comment">//下面打印下input和output的真实类型</span></span><br><span class="line">Log.d(TAG,<span class="string">&quot;output class:&quot;</span>+outputStream.getClass());</span><br><span class="line">Log.d(TAG,<span class="string">&quot;input class:&quot;</span>+socket.getInputStream().getClass());</span><br></pre></td></tr></table></figure><p>然后结果如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output class:class java.net.SocketOutputStream</span><br><span class="line">input class:class java.net.SocketInputStream</span><br></pre></td></tr></table></figure><p>我们先看看write的调用链。整理后如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SocketOutputStream.java</span></span><br><span class="line"><span class="comment">//第一步调用到这里</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      socketWrite(b, <span class="number">0</span>, b.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二步调用到这个</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">socketWrite</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">0</span> || off &lt; <span class="number">0</span> || len &gt; b.length - off) &#123;</span><br><span class="line">            <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">&quot;len == &quot;</span> + len</span><br><span class="line">                    + <span class="string">&quot; off == &quot;</span> + off + <span class="string">&quot; buffer length == &quot;</span> + b.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FileDescriptor fd = impl.acquireFD();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BlockGuard.getThreadPolicy().onNetwork();</span><br><span class="line">            socketWrite0(fd, b, off, len);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException se) &#123;</span><br><span class="line">            <span class="keyword">if</span> (se <span class="keyword">instanceof</span> sun.net.ConnectionResetException) &#123;</span><br><span class="line">                impl.setConnectionResetPending();</span><br><span class="line">                se = <span class="keyword">new</span> SocketException(<span class="string">&quot;Connection reset&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (impl.isClosedOrPending()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">&quot;Socket closed&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> se;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            impl.releaseFD();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三部调用到这里。java部分的就走完了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">socketWrite0</span><span class="params">(FileDescriptor fd, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以我们发送数据抓包可以通过hook函数socketWrite0来获取</p><p>接下来是接受数据readline的流程，这里比上面稍微复杂一些。我会列出完整的来龙去脉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先贴是怎么调用的</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">String line = br.readLine();</span><br><span class="line"></span><br><span class="line"><span class="comment">//所以直接看BufferedReader.java的readLine()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">readLine</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> readLine(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后调用了另外一个重载，这个函数比较大。省略掉非关键位置</span></span><br><span class="line"><span class="function">String <span class="title">readLine</span><span class="params">(<span class="keyword">boolean</span> ignoreLF)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    fill();  </span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后看看fill的处理</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    in.read(cb, dst, cb.length - dst);</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面的in是InputStreamReader这个类型所以InputStreamReader.java中看看read</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> sd.read(cbuf, offset, length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个sd是StreamDecoder这个类。继续到里面看看read函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">return</span> n + implRead(cbuf, off, off + len);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继续看implRead</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">implRead</span><span class="params">(<span class="keyword">char</span>[] cbuf, <span class="keyword">int</span> off, <span class="keyword">int</span> end)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">int</span> n = readBytes();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继续看readBytes。这里的in就是我们的SocketInputStream。绕了一圈终于到这里了。继续往后看</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">readBytes</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">int</span> n = in.read(bb.array(), bb.arrayOffset() + pos, rem);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面是SocketInputStream.java中的read函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> read(b, off, length, impl.getTimeout());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继续看调用的另外一个重载</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> length, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    n = socketRead(fd, b, off, length, timeout);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继续看socketRead。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">socketRead</span><span class="params">(FileDescriptor fd,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> timeout)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> socketRead0(fd, b, off, len, timeout);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//终于到达了最后的native函数。java部分走完了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">socketRead0</span><span class="params">(FileDescriptor fd,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">int</span> timeout)</span><span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据上面我们的线索。下面开始写代码hook一下。最后看看是不是能通抓三个发包的数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将数组转换成c++的byte[]。并且hexdump打印结果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print_bytes</span>(<span class="params">bytes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> buf  = Memory.alloc(bytes.length);</span><br><span class="line">    Memory.writeByteArray(buf, byte_to_ArrayBuffer(bytes));</span><br><span class="line">    <span class="built_in">console</span>.log(hexdump(buf, &#123;<span class="attr">offset</span>: <span class="number">0</span>, <span class="attr">length</span>: bytes.length, <span class="attr">header</span>: <span class="literal">false</span>, <span class="attr">ansi</span>: <span class="literal">true</span>&#125;));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将java的数组转换成js的数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">byte_to_ArrayBuffer</span>(<span class="params">bytes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> size=bytes.length;</span><br><span class="line">    <span class="keyword">var</span> tmparray = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> val = bytes[i];</span><br><span class="line">        <span class="keyword">if</span>(val &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            val += <span class="number">256</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmparray[i] = val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmparray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// java.net.Socket$init(ip,port) 获取ip和端口</span></span><br><span class="line"><span class="comment">// socketWrite0(FileDescriptor fd, byte[] b, int off,int len) 获取发送的数据</span></span><br><span class="line"><span class="comment">// socketRead0(FileDescriptor fd,byte b[], int off, int len,int timeout) 获取接受的数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_tcp</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> socketClass= Java.use(<span class="string">&quot;java.net.Socket&quot;</span>);</span><br><span class="line">    socketClass.$init.overload(<span class="string">&#x27;java.net.InetAddress&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).implementation=<span class="function"><span class="keyword">function</span>(<span class="params">ip,port</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;socket$init &quot;</span>,ip,<span class="string">&quot;:&quot;</span>,port);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.$init(ip,port);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> outputClass=Java.use(<span class="string">&quot;java.net.SocketOutputStream&quot;</span>);</span><br><span class="line">    outputClass.socketWrite0.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">fd,buff,off,len</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;tcp write fd:&quot;</span>,fd);</span><br><span class="line">        print_bytes(buff);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.socketWrite0(fd,buff,off,len);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> inputClass=Java.use(<span class="string">&quot;java.net.SocketInputStream&quot;</span>);</span><br><span class="line">    inputClass.socketRead0.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">fd,buff,off,len,timeout</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> res=<span class="built_in">this</span>.socketRead0(fd,buff,off,len,timeout);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;tcp read fd:&quot;</span>,fd)</span><br><span class="line">        print_bytes(buff);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_java</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        hook_tcp();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    hook_java();</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></table></figure><p>最后跑一下。将结果存储到文本中。搜索一下我们访问的两个地址<code>http://missking.cc/</code>以及<code>http://10.ip138.com</code>还有tcp服务器返回是否有收到</p><p><img src="/2021/05/04/zhuabao/image-20210525222902261.png" alt="image-20210525222902261"></p><p><img src="/2021/05/04/zhuabao/image-20210525222938288.png" alt="image-20210525222938288"></p><p><img src="/2021/05/04/zhuabao/image-20210525223221153.png" alt="image-20210525223221153"></p><p><img src="/2021/05/04/zhuabao/image-20210525223739749.png" alt="image-20210525223739749"></p><p>上面的日志显示。成功抓到了两种http请求和tcp的包</p><h3 id="2、jni层抓http包"><a href="#2、jni层抓http包" class="headerlink" title="2、jni层抓http包"></a>2、jni层抓http包</h3><p>有的时候发包的步骤并不是在java层中。而是在jni层直接就发包了。所以我们即使在java层的最深处。也没法抓到。准备一个例子</p><p>所以我们继续追踪之前的http发包例子的后续。socketWrite0和socketRead0的c层的调用链。通过编译配置，可以层层筛选找到代码在libopenjdk.so中。从当前测试手机中导出这个so文件。用ida打开后直接搜索就能找到socketWrite0。</p><p>socketWrite0解析的结果后发现调用的是NET_Send。再往后调用libc的sendto来进行发送数据</p><p><img src="/2021/05/04/zhuabao/image-20210528225035954.png" alt="image-20210528225035954"></p><p>socketRead0解析的结果后发现调用的是NET_Read。再往后调用libc的recvfrom来进行发送数据</p><p><img src="/2021/05/04/zhuabao/image-20210528225357994.png" alt="image-20210528225357994"></p><p>最后开始写代码来处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSocketData</span>(<span class="params">fd</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;fd:&quot;</span>,fd);</span><br><span class="line">    <span class="keyword">var</span> socketType=Socket.type(fd)</span><br><span class="line">    <span class="keyword">if</span>(socketType!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> res=<span class="string">&quot;type:&quot;</span>+socketType+<span class="string">&quot;,loadAddress:&quot;</span>+<span class="built_in">JSON</span>.stringify(Socket.localAddress(fd))+<span class="string">&quot;,peerAddress&quot;</span>+<span class="built_in">JSON</span>.stringify(Socket.peerAddress(fd));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;type:&quot;</span>+socketType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_jni_tcp</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sendtoPtr=Module.getExportByName(<span class="string">&quot;libc.so&quot;</span>,<span class="string">&quot;sendto&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> recvfromPtr=Module.getExportByName(<span class="string">&quot;libc.so&quot;</span>,<span class="string">&quot;recvfrom&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;sendto:&quot;</span>,sendtoPtr,<span class="string">&quot;,recvfrom:&quot;</span>,recvfromPtr);</span><br><span class="line">    <span class="comment">//sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len)</span></span><br><span class="line">    Interceptor.attach(sendtoPtr,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> fd=args[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">var</span> buff=args[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">var</span> size=args[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">var</span> sockdata=getSocketData(fd.toInt32());</span><br><span class="line">            <span class="built_in">console</span>.log(sockdata);</span><br><span class="line">            <span class="built_in">console</span>.log(hexdump(buff,&#123;<span class="attr">length</span>:size.toInt32()&#125;));</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len)</span></span><br><span class="line">    Interceptor.attach(recvfromPtr,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.fd=args[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">this</span>.buff=args[<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">this</span>.size=args[<span class="number">2</span>];</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> sockdata=getSocketData(<span class="built_in">this</span>.fd.toInt32());</span><br><span class="line">            <span class="built_in">console</span>.log(sockdata);</span><br><span class="line">            <span class="built_in">console</span>.log(hexdump(<span class="built_in">this</span>.buff,&#123;<span class="attr">length</span>:<span class="built_in">this</span>.size.toInt32()&#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的hook结果。这里注意。我们刚刚梳理的jni调用流程是http的。所以测试程序的请求连接要修改下。</p><p><img src="/2021/05/04/zhuabao/image-20210528231015686.png" alt="image-20210528231015686"></p><h3 id="3、java层ssl抓包"><a href="#3、java层ssl抓包" class="headerlink" title="3、java层ssl抓包"></a>3、java层ssl抓包</h3><p>https实际上就是http+ssl。由于http发送的数据直接就是明文。安全性非常差。https会在数据发送前，先用ssl进行加密。如下图</p><p><img src="/2021/05/04/zhuabao/image-20210525224736434.png" alt="image-20210525224736434"></p><p>而加密则是使用对应的证书。接受到服务端数据后。再使用证书来进行解密</p><p><img src="/2021/05/04/zhuabao/image-20210525224939145.png" alt="image-20210525224939145"></p><p>下面是https交互的流程。ssl会先将证书中的公钥发送给服务器。然后服务器将自己的公钥返回给客户端。然后客户端拿到公钥后和证书中的私钥计算出共享密钥。然后就使用共享密钥来加解密服务端传递来的数据。服务端同样也是拿到客户端的公钥，就和自己的私钥计算出共享密钥。</p><p><img src="/2021/05/04/zhuabao/image-20210525225216620.png" alt="image-20210525225216620"></p><p>看完https的理论部分。我们就清楚如何达到自己的目的了。实际上只要在数据加密前的函数调用流程任意一个环节hook都能抓到明文。</p><p>下面直接修改访问地址成https。由于有些证书是手机内置的无需我们自行添加证书。所以代码不需要修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GetByOkHttp(<span class="string">&quot;https://www.baidu.com/&quot;</span>);</span><br><span class="line">GetByHttpURL(<span class="string">&quot;https://www.jd.com/&quot;</span>);</span><br></pre></td></tr></table></figure><p>请求地址修改后。重新使用上面的脚本来hook。发现无法再抓到tcp的请求数据了。说明调用链发生了变化。所以我们分析下访问https时的调用链</p><p>由于这个调用链比较长。我就只针对OkHttp3进行跟踪分析。这里我采用的是调试的方式来追踪这个函数。由于整个追踪跳转的较多。我就只针对重点部分进行记录了。在开始调试之前。我们先整理清楚自己的目的。</p><p>1、调试GetByOkHttp执行的流程。在执行过程中找到ssl相关的处理。</p><p>2、追踪ssl相关的处理。找到最后调用的native函数。</p><p>那么下面贴上调试时得到的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最关键的是这个newCall。断点跟踪进去</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetByOkHttp</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Call call = okHttpClient.newCall(request);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面调用了一个静态的初始化RealCall</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> RealCall.newRealCall(<span class="keyword">this</span>, request, <span class="keyword">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里初始化RealCall</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> RealCall <span class="title">newRealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Safely publish the Call instance to the EventListener.</span></span><br><span class="line">    RealCall call = <span class="keyword">new</span> RealCall(client, originalRequest, forWebSocket);</span><br><span class="line">    call.eventListener = client.eventListenerFactory().create(call);</span><br><span class="line">    <span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//到这里初始化好了。这里注意，retryAndFollowUpInterceptor这个实际上是一个拦截器，那么接下来我们应该把断点放在拦截器的intercept函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">RealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.client = client;</span><br><span class="line">    <span class="keyword">this</span>.originalRequest = originalRequest;</span><br><span class="line">    <span class="keyword">this</span>.forWebSocket = forWebSocket;</span><br><span class="line">    <span class="keyword">this</span>.retryAndFollowUpInterceptor = <span class="keyword">new</span> RetryAndFollowUpInterceptor(client, forWebSocket);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拦截器的触发函数。proceed里面的流程较长。里面经过了多次的跳转。</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">      response = realChain.proceed(request, streamAllocation, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//多次跳转后。最后走进了RealConnection.java的connect函数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> pingIntervalMillis, <span class="keyword">boolean</span> connectionRetryEnabled, Call call,</span></span></span><br><span class="line"><span class="function"><span class="params">      EventListener eventListener)</span> </span>&#123;</span><br><span class="line">           ...</span><br><span class="line">      <span class="comment">//这里判断如果非ssl的处理</span></span><br><span class="line">      <span class="keyword">if</span> (route.address().sslSocketFactory() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RouteException(<span class="keyword">new</span> UnknownServiceException(</span><br><span class="line">              <span class="string">&quot;CLEARTEXT communication not enabled for client&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        String host = route.address().url().host();</span><br><span class="line">        <span class="keyword">if</span> (!Platform.get().isCleartextTrafficPermitted(host)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RouteException(<span class="keyword">new</span> UnknownServiceException(</span><br><span class="line">              <span class="string">&quot;CLEARTEXT communication to &quot;</span> + host + <span class="string">&quot; not permitted by network security policy&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">          ...</span><br><span class="line">      <span class="comment">//这里面调用的socket.connect()</span></span><br><span class="line">      connectSocket(connectTimeout, readTimeout, call, eventListener);</span><br><span class="line">          ...</span><br><span class="line">      <span class="comment">//这里面发送的请求</span></span><br><span class="line">      establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);</span><br><span class="line">          ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先看看socket的连接部分</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connectSocket</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, Call call,</span></span></span><br><span class="line"><span class="function"><span class="params">      EventListener eventListener)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    <span class="comment">//根据不同的type创建不同的socket</span></span><br><span class="line">    rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP</span><br><span class="line">    ? address.socketFactory().createSocket()</span><br><span class="line">    : <span class="keyword">new</span> Socket(proxy);</span><br><span class="line">      ...</span><br><span class="line">    <span class="comment">//socket的连接</span></span><br><span class="line">    Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后这里只是单纯的调用下连接。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectSocket</span><span class="params">(Socket socket, InetSocketAddress address,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> connectTimeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    socket.connect(address, connectTimeout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面继续看发送请求的函数establishProtocol</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">establishProtocol</span><span class="params">(ConnectionSpecSelector connectionSpecSelector,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> pingIntervalMillis, Call call, EventListener eventListener)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">//非ssl的请求直接在这里就返回了</span></span><br><span class="line">    <span class="keyword">if</span> (route.address().sslSocketFactory() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      protocol = Protocol.HTTP_1_1;</span><br><span class="line">      socket = rawSocket;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">//后面是ssl相关的处理</span></span><br><span class="line">    eventListener.secureConnectStart(call);</span><br><span class="line">      <span class="comment">//最关键的是这里会创建sslsocket。并且和服务端进行握手交互</span></span><br><span class="line">    connectTls(connectionSpecSelector);</span><br><span class="line">    eventListener.secureConnectEnd(call, handshake);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (protocol == Protocol.HTTP_2) &#123;</span><br><span class="line">      socket.setSoTimeout(<span class="number">0</span>); <span class="comment">// HTTP/2 connection timeouts are set per-stream.</span></span><br><span class="line">      http2Connection = <span class="keyword">new</span> Http2Connection.Builder(<span class="keyword">true</span>)</span><br><span class="line">          .socket(socket, route.address().url().host(), source, sink)</span><br><span class="line">          .listener(<span class="keyword">this</span>)</span><br><span class="line">          .pingIntervalMillis(pingIntervalMillis)</span><br><span class="line">          .build();</span><br><span class="line">      http2Connection.start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最关键的部分。所以我就贴上完整的代码了。里面很多地方有英文注释。我就不自己画蛇添足了。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connectTls</span><span class="params">(ConnectionSpecSelector connectionSpecSelector)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Address address = route.address();</span><br><span class="line">    SSLSocketFactory sslSocketFactory = address.sslSocketFactory();</span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">    SSLSocket sslSocket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Create the wrapper over the connected socket.</span></span><br><span class="line">      sslSocket = (SSLSocket) sslSocketFactory.createSocket(</span><br><span class="line">          rawSocket, address.url().host(), address.url().port(), <span class="keyword">true</span> <span class="comment">/* autoClose */</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Configure the socket&#x27;s ciphers, TLS versions, and extensions.</span></span><br><span class="line">      ConnectionSpec connectionSpec = connectionSpecSelector.configureSecureSocket(sslSocket);</span><br><span class="line">      <span class="keyword">if</span> (connectionSpec.supportsTlsExtensions()) &#123;</span><br><span class="line">        Platform.get().configureTlsExtensions(</span><br><span class="line">            sslSocket, address.url().host(), address.protocols());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Force handshake. This can throw!</span></span><br><span class="line">      sslSocket.startHandshake();</span><br><span class="line">      <span class="comment">// block for session establishment</span></span><br><span class="line">      SSLSession sslSocketSession = sslSocket.getSession();</span><br><span class="line">      <span class="keyword">if</span> (!isValid(sslSocketSession)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;a valid ssl session was not established&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      Handshake unverifiedHandshake = Handshake.get(sslSocketSession);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Verify that the socket&#x27;s certificates are acceptable for the target host.</span></span><br><span class="line">      <span class="keyword">if</span> (!address.hostnameVerifier().verify(address.url().host(), sslSocketSession)) &#123;</span><br><span class="line">        X509Certificate cert = (X509Certificate) unverifiedHandshake.peerCertificates().get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SSLPeerUnverifiedException(<span class="string">&quot;Hostname &quot;</span> + address.url().host() + <span class="string">&quot; not verified:&quot;</span></span><br><span class="line">            + <span class="string">&quot;\n    certificate: &quot;</span> + CertificatePinner.pin(cert)</span><br><span class="line">            + <span class="string">&quot;\n    DN: &quot;</span> + cert.getSubjectDN().getName()</span><br><span class="line">            + <span class="string">&quot;\n    subjectAltNames: &quot;</span> + OkHostnameVerifier.allSubjectAltNames(cert));</span><br><span class="line">      &#125;</span><br><span class="line">            <span class="comment">//这里是证书的校验</span></span><br><span class="line">      <span class="comment">// Check that the certificate pinner is satisfied by the certificates presented.</span></span><br><span class="line">      address.certificatePinner().check(address.url().host(),</span><br><span class="line">          unverifiedHandshake.peerCertificates());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Success! Save the handshake and the ALPN protocol.</span></span><br><span class="line">      String maybeProtocol = connectionSpec.supportsTlsExtensions()</span><br><span class="line">          ? Platform.get().getSelectedProtocol(sslSocket)</span><br><span class="line">          : <span class="keyword">null</span>;</span><br><span class="line">      socket = sslSocket;</span><br><span class="line">      source = Okio.buffer(Okio.source(socket));</span><br><span class="line">      sink = Okio.buffer(Okio.sink(socket));</span><br><span class="line">      handshake = unverifiedHandshake;</span><br><span class="line">      protocol = maybeProtocol != <span class="keyword">null</span></span><br><span class="line">          ? Protocol.get(maybeProtocol)</span><br><span class="line">          : Protocol.HTTP_1_1;</span><br><span class="line">      success = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (AssertionError e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Util.isAndroidGetsocknameError(e)) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(e);</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (sslSocket != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Platform.get().afterHandshake(sslSocket);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        closeQuietly(sslSocket);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面流程走完。ssl的连接就建立起来了。继续跟踪后。走到下一个关键拦截器CallServerInterceptor.java。我们直接看拦截器函数实现部分</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="comment">//前面的代码应该是准备header的数据。我就都省略了。下面这个函数是发送请求的关键函数</span></span><br><span class="line">    httpCodec.finishRequest();</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继续往后跟踪flush</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    sink.flush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继续跟踪sink.write</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (closed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;closed&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (buffer.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      sink.write(buffer, buffer.size);</span><br><span class="line">    &#125;</span><br><span class="line">    sink.flush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继续往后看write</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Buffer source, <span class="keyword">long</span> byteCount)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        checkOffsetAndCount(source.size, <span class="number">0</span>, byteCount);</span><br><span class="line">      ...</span><br><span class="line">    sink.write(source, toWrite);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个write就到一个关键的位置了。这个out对象就是我们关心的类了。我们查一下out的类型</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Buffer source, <span class="keyword">long</span> byteCount)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//out对象的类型是com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream</span></span><br><span class="line">    out.write(head.data, head.pos, toCopy);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接下来我们就可以去找SSLOutputStream的write了。我们在调试中跟踪过去失败了。那么直接去翻源码把。下面是对应的write</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> offset, <span class="keyword">int</span> byteCount)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    ssl.write(Platform.getFileDescriptor(socket), buf, offset, byteCount,writeTimeoutMilliseconds);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继续看ssl.write。这个ssl的类型是SslWrapper。找到对应的write如下。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(FileDescriptor fd, <span class="keyword">byte</span>[] buf, <span class="keyword">int</span> offset, <span class="keyword">int</span> len, <span class="keyword">int</span> timeoutMillis)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        NativeCrypto.SSL_write(ssl, fd, handshakeCallbacks, buf, offset, len, timeoutMillis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继续找NativeCrypto类的SSL_write函数。到这里就结束了。终于到达java调用链的最后一层了。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">SSL_write</span><span class="params">(<span class="keyword">long</span> sslNativePointer, FileDescriptor fd,</span></span></span><br><span class="line"><span class="function"><span class="params">            SSLHandshakeCallbacks shc, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len, <span class="keyword">int</span> writeTimeoutMillis)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据上面的一连串翻找。终于走完了https请求时的java部分的整个调用链。至于读取包的。可以直接猜测一下，看有没有对应的SSL_read。搜了一下。果然是有的。很可能就是这个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">SSL_read</span><span class="params">(<span class="keyword">long</span> sslNativePointer, FileDescriptor fd, SSLHandshakeCallbacks shc,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len, <span class="keyword">int</span> readTimeoutMillis)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><p>接下来开始写hook脚本来处理SSL_write和SSL_read。在这之前。我们要先找到NativeCrypto类的包名才行。用frida来搜索一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Java.enumerateLoadedClassesSync().forEach(<span class="function"><span class="keyword">function</span>(<span class="params">className</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(className.indexOf(name)!=<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">getFullName(<span class="string">&quot;NativeCrypto&quot;</span>)</span><br></pre></td></tr></table></figure><p>最后得到结果<code>com.android.org.conscrypt.NativeCrypto</code></p><p>然后来处理读取和写入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NativeCrypto   SSL_write(long sslNativePointer, FileDescriptor fd,</span></span><br><span class="line"><span class="comment">//             SSLHandshakeCallbacks shc, byte[] b, int off, int len, int writeTimeoutMillis)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//NativeCrypto   SSL_read(long sslNativePointer, FileDescriptor fd, SSLHandshakeCallbacks shc,</span></span><br><span class="line"><span class="comment">//             byte[] b, int off, int len, int readTimeoutMillis)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_ssl</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> NativeCryptoClass= Java.use(<span class="string">&quot;com.android.org.conscrypt.NativeCrypto&quot;</span>);</span><br><span class="line">    NativeCryptoClass.SSL_write.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">sslPtr,fd,shc,b,off,len,timeout</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;enter SSL_write&quot;</span>);</span><br><span class="line">        print_bytes(b);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.SSL_write(sslPtr,fd,shc,b,off,len,timeout);</span><br><span class="line">    &#125;;</span><br><span class="line">    NativeCryptoClass.SSL_read.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">sslPtr,fd,shc,b,off,len,timeout</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;enter SSL_read&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> res=<span class="built_in">this</span>.SSL_read(sslPtr,fd,shc,b,off,len,timeout);</span><br><span class="line">        print_bytes(b);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这里就能获取到https的包数据了。但是如果是tcp的情况会有个问题。就是没有连接的服务器ip地址和端口。在整个调用链环节中。我们可以找个尽量靠近native层调用，并且能取到服务器地址和端口的函数来hook。比如直接hook了SSLOutputStream的write和SSLInputStream的read。我们先看看断点调试走到最后的SLLOutPutStream的那里。然后展开这个out对象看看有些什么属性</p><p><img src="/2021/05/04/zhuabao/image-20210528205036217.png" alt="image-20210528205036217"></p><p>看到在out里面有个this$0里面的socket有我们想要的目标服务器地址和端口。这个$0实际上是指向当前这个类中类的父级对象。那么我们再hook一下这里</p><p>老样子先用之前的办法取到完整类名<code>com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSocketData2</span>(<span class="params">stream</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data0=stream.this$<span class="number">0.</span>value;</span><br><span class="line">    <span class="keyword">var</span> sockdata=data0.socket.value;</span><br><span class="line">    <span class="keyword">return</span> sockdata;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SSLOutputStream  write(byte[] buf, int offset, int byteCount)</span></span><br><span class="line"><span class="comment">//SSLInputStream     read(byte[] buf, int offset, int byteCount)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_ssl2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> SSLOutputClass=Java.use(<span class="string">&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream&quot;</span>);</span><br><span class="line">    SSLOutputClass.write.overload(<span class="string">&#x27;[B&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).implementation=<span class="function"><span class="keyword">function</span>(<span class="params">buf,off,cnt</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(getSocketData2(<span class="built_in">this</span>));</span><br><span class="line">        print_bytes(buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.write(buf,off,cnt);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> SSLInputClass=Java.use(<span class="string">&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream&quot;</span>);</span><br><span class="line">    SSLInputClass.read.overload(<span class="string">&#x27;[B&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).implementation=<span class="function"><span class="keyword">function</span>(<span class="params">buf,off,cnt</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> res=<span class="built_in">this</span>.read(buf,off,cnt);</span><br><span class="line">        <span class="built_in">console</span>.log(getSocketData2(<span class="built_in">this</span>));</span><br><span class="line">        print_bytes(buf);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后看看效果。能成功抓到请求了。</p><p><img src="/2021/05/04/zhuabao/image-20210528210239341.png" alt="image-20210528210239341"></p><h3 id="4、jni层抓https包"><a href="#4、jni层抓https包" class="headerlink" title="4、jni层抓https包"></a>4、jni层抓https包</h3><p>继续跟着前面的线索往jni层跟踪。前面我们看到的最后一层是SSL_write和SSL_read，所属类是NativeCrypto。直接搜索函数NativeCrypto_SSL_write。下面贴出关键代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">NativeCrypto_SSL_write</span><span class="params">(JNIEnv* env, jclass, jlong ssl_address, jobject fdObject,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   jobject shc, jbyteArray b, jint offset, jint len,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   jint write_timeout_millis)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    ret = sslWrite(env, ssl, fdObject, shc, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(&amp;buf[<span class="number">0</span>]), len,</span><br><span class="line">                           sslError, write_timeout_millis);</span><br><span class="line">      ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续查看sslWrite的实现。发现里面又调用了一层SSL_write。这个函数虽然和上面的函数同名。但是不是同一个了。该函数是boringssl中的了。这是谷歌创建的openssl的分支，内置在android中的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sslWrite</span><span class="params">(JNIEnv* env, SSL* ssl, jobject fdObject, jobject shc, <span class="keyword">const</span> <span class="keyword">char</span>* buf, jint len,</span></span></span><br><span class="line"><span class="function"><span class="params">                    OpenSslError&amp; sslError, <span class="keyword">int</span> write_timeout_millis)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">int</span> result = SSL_write(ssl, buf, len);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看boringssl中的SSL_write。这里调用的函数是根据不同ssl版本调用的。所以找对应的函数应该带上对应版本比如ssl3_write_app_data</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_write</span><span class="params">(SSL *ssl, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    ret = ssl-&gt;method-&gt;write_app_data(ssl, &amp;needs_handshake,</span><br><span class="line">                                      (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)buf, num);</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>继续看ssl3_write_app_data的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ssl3_write_app_data</span><span class="params">(SSL *ssl, <span class="keyword">int</span> *out_needs_handshake, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">int</span> ret = do_ssl3_write(ssl, SSL3_RT_APPLICATION_DATA, &amp;buf[tot], nw);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看do_ssl3_write的实现。这里可以看到这里就是明文的终点了。再往后面去的函数数据都是密文的了。从这里往前的流程都是明文。可以找任意一个觉得合适的地方来hook。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_ssl3_write</span><span class="params">(SSL *ssl, <span class="keyword">int</span> type, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *buf, <span class="keyword">unsigned</span> len)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">/* Add any unflushed handshake data as a prefix. This may be a KeyUpdate</span></span><br><span class="line"><span class="comment">* acknowledgment or 0-RTT key change messages. |pending_flight| must be clear</span></span><br><span class="line"><span class="comment">* when data is added to |write_buffer| or it will be written in the wrong</span></span><br><span class="line"><span class="comment">* order. */</span></span><br><span class="line">  <span class="keyword">if</span> (ssl-&gt;s3-&gt;pending_flight != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    OPENSSL_memcpy(</span><br><span class="line">        out, ssl-&gt;s3-&gt;pending_flight-&gt;data + ssl-&gt;s3-&gt;pending_flight_offset,</span><br><span class="line">        flight_len);</span><br><span class="line">    BUF_MEM_free(ssl-&gt;s3-&gt;pending_flight);</span><br><span class="line">    ssl-&gt;s3-&gt;pending_flight = <span class="literal">NULL</span>;</span><br><span class="line">    ssl-&gt;s3-&gt;pending_flight_offset = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!tls_seal_record(ssl, out + flight_len, &amp;ciphertext_len,</span><br><span class="line">                       max_out - flight_len, type, buf, len)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ssl_write_buffer_set_len(ssl, flight_len + ciphertext_len);</span><br><span class="line">    ...</span><br><span class="line">  <span class="comment">/* we now just need to write the buffer */</span></span><br><span class="line">  <span class="keyword">return</span> ssl3_write_pending(ssl, type, buf, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在开始写hook处理前解决一个疑问。就是之前在recvfrom和sendto进行hook。并没有取到https的密文。所以我们去看一下。boringssl中是怎么处理最终发送数据的。在boringssl项目的文件<code>crypto/bio/socket.c</code>中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sock_read</span><span class="params">(BIO *b, <span class="keyword">char</span> *out, <span class="keyword">int</span> outl)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (out == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  bio_clear_socket_error();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(OPENSSL_WINDOWS)</span></span><br><span class="line">  ret = recv(b-&gt;num, out, outl, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  ret = <span class="built_in">read</span>(b-&gt;num, out, outl);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  BIO_clear_retry_flags(b);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bio_fd_should_retry(ret)) &#123;</span><br><span class="line">      BIO_set_retry_read(b);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sock_write</span><span class="params">(BIO *b, <span class="keyword">const</span> <span class="keyword">char</span> *in, <span class="keyword">int</span> inl)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">  bio_clear_socket_error();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(OPENSSL_WINDOWS)</span></span><br><span class="line">  ret = send(b-&gt;num, in, inl, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  ret = <span class="built_in">write</span>(b-&gt;num, in, inl);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  BIO_clear_retry_flags(b);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bio_fd_should_retry(ret)) &#123;</span><br><span class="line">      BIO_set_retry_write(b);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到如何是jni层的ssl里面最终发送数据的地方。判断了如果是win平台就用send和recv。否则就使用write和read。这样我们就知道jni层的ssl怎么抓明文和密文了。明文的hook点直接选择openssl调用的函数SSL_write和SSL_read接下来开始写代码。下面贴上完整的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将数组转换成c++的byte[]。并且hexdump打印结果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print_bytes</span>(<span class="params">bytes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> buf  = Memory.alloc(bytes.length);</span><br><span class="line">    Memory.writeByteArray(buf, byte_to_ArrayBuffer(bytes));</span><br><span class="line">    <span class="built_in">console</span>.log(hexdump(buf, &#123;<span class="attr">offset</span>: <span class="number">0</span>, <span class="attr">length</span>: bytes.length, <span class="attr">header</span>: <span class="literal">false</span>, <span class="attr">ansi</span>: <span class="literal">true</span>&#125;));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将java的数组转换成js的数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">byte_to_ArrayBuffer</span>(<span class="params">bytes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> size=bytes.length;</span><br><span class="line">    <span class="keyword">var</span> tmparray = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> val = bytes[i];</span><br><span class="line">        <span class="keyword">if</span>(val &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            val += <span class="number">256</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmparray[i] = val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmparray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// java.net.Socket$init(ip,port) 获取ip和端口</span></span><br><span class="line"><span class="comment">// socketWrite0(FileDescriptor fd, byte[] b, int off,int len) 获取发送的数据</span></span><br><span class="line"><span class="comment">// socketRead0(FileDescriptor fd,byte b[], int off, int len,int timeout) 获取接受的数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_tcp</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> socketClass= Java.use(<span class="string">&quot;java.net.Socket&quot;</span>);</span><br><span class="line">    socketClass.$init.overload(<span class="string">&#x27;java.net.InetAddress&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).implementation=<span class="function"><span class="keyword">function</span>(<span class="params">ip,port</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;socket$init &quot;</span>,ip,<span class="string">&quot;:&quot;</span>,port);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.$init(ip,port);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> outputClass=Java.use(<span class="string">&quot;java.net.SocketOutputStream&quot;</span>);</span><br><span class="line">    outputClass.socketWrite0.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">fd,buff,off,len</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;tcp write fd:&quot;</span>,fd);</span><br><span class="line">        print_bytes(buff);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.socketWrite0(fd,buff,off,len);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> inputClass=Java.use(<span class="string">&quot;java.net.SocketInputStream&quot;</span>);</span><br><span class="line">    inputClass.socketRead0.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">fd,buff,off,len,timeout</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> res=<span class="built_in">this</span>.socketRead0(fd,buff,off,len,timeout);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;tcp read fd:&quot;</span>,fd)</span><br><span class="line">        print_bytes(buff);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SSL_write(long sslNativePointer, FileDescriptor fd,</span></span><br><span class="line"><span class="comment">//             SSLHandshakeCallbacks shc, byte[] b, int off, int len, int writeTimeoutMillis)</span></span><br><span class="line"><span class="comment">//SSL_read(long sslNativePointer, FileDescriptor fd, SSLHandshakeCallbacks shc,</span></span><br><span class="line"><span class="comment">//             byte[] b, int off, int len, int readTimeoutMillis)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSocketData</span>(<span class="params">fd</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;fd:&quot;</span>,fd);</span><br><span class="line">    <span class="keyword">var</span> socketType=Socket.type(fd)</span><br><span class="line">    <span class="keyword">if</span>(socketType!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> res=<span class="string">&quot;type:&quot;</span>+socketType+<span class="string">&quot;,loadAddress:&quot;</span>+<span class="built_in">JSON</span>.stringify(Socket.localAddress(fd))+<span class="string">&quot;,peerAddress&quot;</span>+<span class="built_in">JSON</span>.stringify(Socket.peerAddress(fd));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;type:&quot;</span>+socketType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSocketData2</span>(<span class="params">stream</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data0=stream.this$<span class="number">0.</span>value;</span><br><span class="line">    <span class="keyword">var</span> sockdata=data0.socket.value;</span><br><span class="line">    <span class="keyword">return</span> sockdata;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_ssl</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> NativeCryptoClass= Java.use(<span class="string">&quot;com.android.org.conscrypt.NativeCrypto&quot;</span>);</span><br><span class="line">    NativeCryptoClass.SSL_write.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">sslPtr,fd,shc,b,off,len,timeout</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;enter SSL_write&quot;</span>);</span><br><span class="line">        print_bytes(b);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.SSL_write(sslPtr,fd,shc,b,off,len,timeout);</span><br><span class="line">    &#125;;</span><br><span class="line">    NativeCryptoClass.SSL_read.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">sslPtr,fd,shc,b,off,len,timeout</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;enter SSL_read&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> res=<span class="built_in">this</span>.SSL_read(sslPtr,fd,shc,b,off,len,timeout);</span><br><span class="line">        print_bytes(b);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SSLOutputStream  write(byte[] buf, int offset, int byteCount)</span></span><br><span class="line"><span class="comment">//SSLInputStream     read(byte[] buf, int offset, int byteCount)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_ssl2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> SSLOutputClass=Java.use(<span class="string">&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream&quot;</span>);</span><br><span class="line">    SSLOutputClass.write.overload(<span class="string">&#x27;[B&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).implementation=<span class="function"><span class="keyword">function</span>(<span class="params">buf,off,cnt</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(getSocketData2(<span class="built_in">this</span>));</span><br><span class="line">        print_bytes(buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.write(buf,off,cnt);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> SSLInputClass=Java.use(<span class="string">&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream&quot;</span>);</span><br><span class="line">    SSLInputClass.read.overload(<span class="string">&#x27;[B&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).implementation=<span class="function"><span class="keyword">function</span>(<span class="params">buf,off,cnt</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> res=<span class="built_in">this</span>.read(buf,off,cnt);</span><br><span class="line">        <span class="built_in">console</span>.log(getSocketData2(<span class="built_in">this</span>));</span><br><span class="line">        print_bytes(buf);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//jni的ssl的加密数据hook</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_jni_ssl_enc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> writePtr=Module.getExportByName(<span class="string">&quot;libc.so&quot;</span>,<span class="string">&quot;write&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> readPtr=Module.getExportByName(<span class="string">&quot;libc.so&quot;</span>,<span class="string">&quot;read&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;write:&quot;</span>,writePtr,<span class="string">&quot;,read:&quot;</span>,readPtr);</span><br><span class="line">    Interceptor.attach(writePtr,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> fd=args[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">var</span> buff=args[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">var</span> size=args[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">var</span> sockdata=getSocketData(fd.toInt32());</span><br><span class="line">            <span class="keyword">if</span>(sockdata.indexOf(<span class="string">&quot;tcp&quot;</span>))&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(sockdata);</span><br><span class="line">                <span class="built_in">console</span>.log(hexdump(buff,&#123;<span class="attr">length</span>:size.toInt32()&#125;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Interceptor.attach(readPtr,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.fd=args[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">this</span>.buff=args[<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">this</span>.size=args[<span class="number">2</span>];</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> sockdata=getSocketData(<span class="built_in">this</span>.fd.toInt32());</span><br><span class="line">            <span class="keyword">if</span>(sockdata.indexOf(<span class="string">&quot;tcp&quot;</span>))&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(sockdata);</span><br><span class="line">                <span class="built_in">console</span>.log(hexdump(<span class="built_in">this</span>.buff,&#123;<span class="attr">length</span>:<span class="built_in">this</span>.size.toInt32()&#125;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//jni的ssl明文数据hook</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_jni_ssl</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sslWritePtr=Module.getExportByName(<span class="string">&quot;libssl.so&quot;</span>,<span class="string">&quot;SSL_write&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> sslReadPtr=Module.getExportByName(<span class="string">&quot;libssl.so&quot;</span>,<span class="string">&quot;SSL_read&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;sslWrite:&quot;</span>,sslWritePtr,<span class="string">&quot;,sslRead:&quot;</span>,sslReadPtr);</span><br><span class="line">    <span class="keyword">var</span> sslGetFdPtr=Module.getExportByName(<span class="string">&quot;libssl.so&quot;</span>,<span class="string">&quot;SSL_get_rfd&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> sslGetFdFunc=<span class="keyword">new</span> NativeFunction(sslGetFdPtr,<span class="string">&#x27;int&#x27;</span>,[<span class="string">&#x27;pointer&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int SSL_write(SSL *ssl, const void *buf, int num)</span></span><br><span class="line">    Interceptor.attach(sslWritePtr,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> sslPtr=args[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">var</span> buff=args[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">var</span> size=args[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">var</span> fd=sslGetFdFunc(sslPtr);</span><br><span class="line">            <span class="keyword">var</span> sockdata=getSocketData(fd);</span><br><span class="line">            <span class="built_in">console</span>.log(sockdata);</span><br><span class="line">            <span class="built_in">console</span>.log(hexdump(buff,&#123;<span class="attr">length</span>:size.toInt32()&#125;));</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//int SSL_read(SSL *ssl, void *buf, int num)</span></span><br><span class="line">    Interceptor.attach(sslReadPtr,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.sslPtr=args[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">this</span>.buff=args[<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">this</span>.size=args[<span class="number">2</span>];</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> fd=sslGetFdFunc(<span class="built_in">this</span>.sslPtr);</span><br><span class="line">            <span class="keyword">var</span> sockdata=getSocketData(fd);</span><br><span class="line">            <span class="built_in">console</span>.log(sockdata);</span><br><span class="line">            <span class="built_in">console</span>.log(hexdump(<span class="built_in">this</span>.buff,&#123;<span class="attr">length</span>:<span class="built_in">this</span>.size.toInt32()&#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_jni_tcp</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sendtoPtr=Module.getExportByName(<span class="string">&quot;libc.so&quot;</span>,<span class="string">&quot;sendto&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> recvfromPtr=Module.getExportByName(<span class="string">&quot;libc.so&quot;</span>,<span class="string">&quot;recvfrom&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;sendto:&quot;</span>,sendtoPtr,<span class="string">&quot;,recvfrom:&quot;</span>,recvfromPtr);</span><br><span class="line">    <span class="comment">//sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len)</span></span><br><span class="line">    Interceptor.attach(sendtoPtr,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> fd=args[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">var</span> buff=args[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">var</span> size=args[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">var</span> sockdata=getSocketData(fd.toInt32());</span><br><span class="line">            <span class="built_in">console</span>.log(sockdata);</span><br><span class="line">            <span class="built_in">console</span>.log(hexdump(buff,&#123;<span class="attr">length</span>:size.toInt32()&#125;));</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len)</span></span><br><span class="line">    Interceptor.attach(recvfromPtr,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.fd=args[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">this</span>.buff=args[<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">this</span>.size=args[<span class="number">2</span>];</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> sockdata=getSocketData(<span class="built_in">this</span>.fd.toInt32());</span><br><span class="line">            <span class="built_in">console</span>.log(sockdata);</span><br><span class="line">            <span class="built_in">console</span>.log(hexdump(<span class="built_in">this</span>.buff,&#123;<span class="attr">length</span>:<span class="built_in">this</span>.size.toInt32()&#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_java</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// hook_tcp();</span></span><br><span class="line">        <span class="comment">// hook_ssl();</span></span><br><span class="line">        <span class="comment">// hook_ssl2();</span></span><br><span class="line">        <span class="comment">// hook_jni_tcp();</span></span><br><span class="line">        hook_jni_ssl_enc();</span><br><span class="line">        hook_jni_ssl();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Java.enumerateLoadedClassesSync().forEach(<span class="function"><span class="keyword">function</span>(<span class="params">className</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(className.indexOf(name)!=<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    hook_java();</span><br><span class="line">    <span class="comment">// getFullName(&quot;SSLOutputStream&quot;)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></table></figure><p>跑起来后的结果如下。成功抓到ssl的密文和ssl的明文。想要回溯的话直接加上打印堆栈即可。</p><p><img src="/2021/05/04/zhuabao/image-20210531232115639.png" alt="image-20210531232115639"></p><p><img src="/2021/05/04/zhuabao/image-20210531232306136.png" alt="image-20210531232306136"></p><h2 id="中间人抓包"><a href="#中间人抓包" class="headerlink" title="中间人抓包"></a>中间人抓包</h2><p>我们常常用的burp和charles就是属于中间人抓包。前面我们看过了https的加密方式，需要使用证书的公钥去交换加密再发送数据。那么这些工具是如何做到抓取https的数据包并解密的呢。方式就和他的名字一样。这个抓包的应用他也有一个证书。然后客户端向服务端发送数据时，中间人就假装自己是服务端。将自己证书的公钥发送给客户端，然后拿到客户发送的数据后，再假装自己是客户端，把自己的证书公钥发送给服务端。大概可以想象成一个双面间谍。客户端面前冒充服务端，服务端面前冒充客户端。下面贴上网上找的交互的示意图，包括握手流程都写的非常详细了。</p><p><img src="/2021/05/04/zhuabao/image-20210602233051668.png" alt="image-20210602233051668"></p><p>而使用中间人抓包。常常会碰到防抓包手段。这些手段一般都是针对证书的检测。</p><h3 id="1、服务端验证客户端证书"><a href="#1、服务端验证客户端证书" class="headerlink" title="1、服务端验证客户端证书"></a>1、服务端验证客户端证书</h3><p>服务端会检测客户端交互使用的证书是不是正确的。这种情况我们可以直接将客户端里面使用的证书导出来，然后设置让charles使用指定的证书来抓包。这里导出证书的办法有两种。</p><p>第一种是直接hook代码中设置证书的地方，直接重新设置一次空的证书。让其不要验证。</p><p>这里看一个网上找的android设置证书的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">val resourceStream = resources.openRawResource(R.raw.infinisign_cert)</span><br><span class="line">val keyStoreType = KeyStore.getDefaultType()</span><br><span class="line">val keyStore = KeyStore.getInstance(keyStoreType)</span><br><span class="line">keyStore.load(resourceStream, <span class="keyword">null</span>)</span><br><span class="line">  </span><br><span class="line">val trustManagerAlgorithm = TrustManagerFactory.getDefaultAlgorithm()</span><br><span class="line">val trustManagerFactory = TrustManagerFactory.getInstance(trustManagerAlgorithm)</span><br><span class="line">trustManagerFactory.init(keyStore)</span><br><span class="line">  </span><br><span class="line">val sslContext = SSLContext.getInstance(<span class="string">&quot;TLS&quot;</span>)</span><br><span class="line">sslContext.init(<span class="keyword">null</span>, trustManagerFactory.trustManagers, <span class="keyword">null</span>)</span><br><span class="line">val url = URL(<span class="string">&quot;http://infinisign.com/&quot;</span>)</span><br><span class="line">val urlConnection = url.openConnection() as HttpsURLConnection</span><br><span class="line">urlConnection.sslSocketFactory = sslContext.socketFactory</span><br></pre></td></tr></table></figure><p>大概意思是从资源文件加载到证书。然后用keyStore加载证书。后面再使用。所以我们直接看看keyStore的load函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(InputStream stream, <span class="keyword">char</span>[] password)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, NoSuchAlgorithmException, CertificateException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        keyStoreSpi.engineLoad(stream, password);</span><br><span class="line">        initialized = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>还有其他方式加载证书。看下面的我网上翻的另外一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">CertificateFactory factory = CertificateFactory.getInstance(<span class="string">&quot;X.509&quot;</span>);<span class="comment">//设置证书类型，X.509是一种格式标准</span></span><br><span class="line">InputStream stream;</span><br><span class="line">Certificate certificate;<span class="comment">//Certificate是证书信息封装的一个bean类</span></span><br><span class="line"></span><br><span class="line">KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());</span><br><span class="line">keyStore.load(<span class="keyword">null</span>);<span class="comment">//清除默认证书,使用我们自己制定的证书</span></span><br><span class="line"></span><br><span class="line">CertificateFactory cf = CertificateFactory.getInstance(<span class="string">&quot;X.509&quot;</span>);</span><br><span class="line">InputStream caInput = getAssets().open(<span class="string">&quot;burp.der&quot;</span>);</span><br><span class="line">Certificate cert = cf.generateCertificate(caInput);</span><br><span class="line"><span class="comment">//设置自己的证书</span></span><br><span class="line">keyStore.setCertificateEntry(<span class="string">&quot;misskings&quot;</span>,cert);</span><br><span class="line"></span><br><span class="line">TrustManagerFactory trustManagerFactory =       TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());</span><br><span class="line">trustManagerFactory.init(keyStore);<span class="comment">//通过keyStore得到信任管理器</span></span><br><span class="line"></span><br><span class="line">KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());</span><br><span class="line">keyManagerFactory.init(keyStore, <span class="string">&quot;pwd&quot;</span>.toCharArray());<span class="comment">//通过keyStore得到密匙管理器</span></span><br><span class="line"></span><br><span class="line">SSLContext sslContext = SSLContext.getInstance(<span class="string">&quot;TLS&quot;</span>);</span><br><span class="line">sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), <span class="keyword">new</span> SecureRandom());</span><br><span class="line">SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();<span class="comment">//拿到SSLSocketFactory</span></span><br><span class="line"></span><br><span class="line">TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();</span><br><span class="line"><span class="keyword">if</span> (trustManagers.length != <span class="number">1</span> || !(trustManagers[<span class="number">0</span>] <span class="keyword">instanceof</span> X509TrustManager)) &#123;</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">X509TrustManager trustManager = (X509TrustManager) trustManagers[<span class="number">0</span>];</span><br><span class="line">okHttpClient.sslSocketFactory(sslSocketFactory, trustManager)<span class="comment">//设置ssl证书</span></span><br><span class="line">okHttpClient.build();</span><br></pre></td></tr></table></figure><p>发现这个例子里面的keyStore.load是null。是在后面进行再设置进去的。所以如果我们处理load函数。就会没有啥效果了。我们可以找找其他hook点。比如我直接在两个init的地方进行hook</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_keystore</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> keyManager=Java.use(<span class="string">&quot;javax.net.ssl.KeyManagerFactory&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> trustManager=Java.use(<span class="string">&quot;javax.net.ssl.TrustManagerFactory&quot;</span>);</span><br><span class="line">    keyManager.init.overload(<span class="string">&#x27;java.security.KeyStore&#x27;</span>, <span class="string">&#x27;[C&#x27;</span>).implementation=<span class="function"><span class="keyword">function</span>(<span class="params">ks,pwd</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;enter keyManager init&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> savePath=<span class="string">&quot;/sdcard/keyManagerFactory_init.p12&quot;</span>;</span><br><span class="line">            <span class="keyword">var</span> outStream=Java.use(<span class="string">&quot;java.io.FileOutputStream&quot;</span>).$new(savePath);</span><br><span class="line">            ks.store(outStream,Java.use(<span class="string">&quot;java.lang.String&quot;</span>).$new(pwd).toCharArray());</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;keyManager store success&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ex)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.init(ks,pwd);</span><br><span class="line">    &#125;</span><br><span class="line">    trustManager.init.overload(<span class="string">&#x27;java.security.KeyStore&#x27;</span>).implementation=<span class="function"><span class="keyword">function</span>(<span class="params">ks</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;enter trustManager init&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> savePath=<span class="string">&quot;/sdcard/TrustManagerFactory_init.p12&quot;</span>;</span><br><span class="line">            <span class="keyword">var</span> outStream=Java.use(<span class="string">&quot;java.io.FileOutputStream&quot;</span>).$new(savePath);</span><br><span class="line">            ks.store(outStream);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;trustManager store success&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ex)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.init(ks);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们测试下自己的例子。<code>frida -U --no-pause -f com.example.zhuabao -l zhuabao.js</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trustManager store success</span><br><span class="line">keyManager store success</span><br></pre></td></tr></table></figure><p>最后导出来的文件。我对比了一下原文件。发现要去掉头部的0x43个字节（这里是因为我安卓代码里面设置了别名）和尾部的0x15个字节。就和原证书文件完全一致了。不过是否通用就不知道了。未测试多个样本。</p><p>第二种是直接解压apk。然后在里面搜索证书特征的文件。例如下面。大概搜一下一些证书的后缀。一般也可能直接找到。</p><p><img src="/2021/05/04/zhuabao/image-20210602225401073.png" alt="image-20210602225401073"></p><h3 id="2、客户端验证服务端证书"><a href="#2、客户端验证服务端证书" class="headerlink" title="2、客户端验证服务端证书"></a>2、客户端验证服务端证书</h3><p>大概就是客户端向服务端请求。然后服务端把自己的证书返回了。客户端验证一下证书是否正确有效。没啥问题才正常通讯。而这种判断逻辑直接在客户端的。那就直接hook修改让他不要处理就行了。</p><p>解决这个的开源项目有很多。</p><p>xposed解决方案:<a href="https://github.com/Fuzion24/JustTrustMe">JustTrustMe</a></p><p>frida解决方案:<a href="https://github.com/WooyunDota/DroidSSLUnpinning">DroidSSLUnpinning</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> andorid,抓包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法还原实战9</title>
      <link href="/2021/02/03/zuoye9/"/>
      <url>/2021/02/03/zuoye9/</url>
      
        <content type="html"><![CDATA[<p>练习algorithmbase_80.apk</p><p>先是用frida脚本跑几个数据看看加密特征</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">call_encode80</span>(<span class="params">input</span>)</span>&#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> MainActivity=Java.use(<span class="string">&quot;com.kanxue.algorithmbase.MainActivity&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> res=MainActivity.encodeFromJni_80(input);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;input:&quot;</span>,input,<span class="string">&quot;output&quot;</span>,res);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后加密几个测试数据看到了。当输入长度为16以下时。输出长度为128.输入长度为&gt;=16并且&lt;32时。输出长度为160。由此可以判断这应该是一个组合的非标准算法。前面组合的部分目测为某个hash算法</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[AOSP on msm8996::com.kanxue.algorithmbase]-&gt; call_encode80(&quot;0000&quot;)</span><br><span class="line">input: 0000 output 23A92603A73333E2EE8DA421C319BB6743595D02CF5AC0CCD1AE26CDE40334589CA0983402D21FA53A1B6FB796328E9CC0B4A8CE1BB68F7E7A7C4C25B7667FA5 output len: 128</span><br><span class="line">[AOSP on msm8996::com.kanxue.algorithmbase]-&gt; call_encode80(&quot;000000000000000&quot;)</span><br><span class="line">input: 000000000000000 output CF3FFB756CEC35BD04AACB520E23ED3BCF3E332956275DF8E2E0A5C6D88B88B2845CA6A4AF374AF2B7618074119E919F8A673BDCC60E5DFAEF0CF103CD71790C output len: 128</span><br><span class="line">[AOSP on msm8996::com.kanxue.algorithmbase]-&gt; call_encode80(&quot;0000000000000000&quot;)</span><br><span class="line">input: 0000000000000000 output 5F5AB31F6BEF26F7FE5BA423B4B71D76357787C9E7DBFB39FAD9FE0BBB67587E6E8F24CAEF7EFFF52A539F37997FD51836824D20AD230940BFC5206145FD52434B72058D139812D5ADA7EBB12BD4333A output len: 160</span><br><span class="line">[AOSP on msm8996::com.kanxue.algorithmbase]-&gt; call_encode80(&quot;0000000000000000000000000000000&quot;)</span><br><span class="line">input: 0000000000000000000000000000000 output D06F822D572D89CB569BA83A63E11A1800861418ED2CB432419B6FD36C1DFD5488067965E42841424E40DDE955974C16AECBF485F828DE38663C7923BF7003456A64EFCCF070DD817D13E137D0CC3471 output len: 160</span><br><span class="line">[AOSP on msm8996::com.kanxue.algorithmbase]-&gt; call_encode80(&quot;00000000000000000000000000000000&quot;)</span><br><span class="line">input: 00000000000000000000000000000000 output 6E46BE17EB55AE1CCA05E85E542A9EC24A948CF9ECB563C932F98002C7AF2D214FA3625C9D1B8B163D59699EFBB0E698313560682808B623278697B8DB9477F82AC8F580971AD97A104177862B9E833B0DFC80A63852524BD3E183A4D0252061 output len: 192</span><br></pre></td></tr></table></figure><p>由于这个起始长度特征很眼熟。128的长度sha256的长度一致的。所以直接测试一下。</p><p><img src="/2021/02/03/zuoye9/image-20210203225936678.png" alt="image-20210203225936678"></p><p>看到结果和上面的不一致。可能这不是sha256算法。或者是一个修改了的sha256。我们接下来验证一下。先搜索一下。看看sha256标准算法有哪些常量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> k[<span class="number">64</span>] = &#123;</span><br><span class="line">    <span class="number">0x428a2f98</span>, <span class="number">0x71374491</span>, <span class="number">0xb5c0fbcf</span>, <span class="number">0xe9b5dba5</span>, <span class="number">0x3956c25b</span>, <span class="number">0x59f111f1</span>, <span class="number">0x923f82a4</span>, <span class="number">0xab1c5ed5</span>,</span><br><span class="line">    <span class="number">0xd807aa98</span>, <span class="number">0x12835b01</span>, <span class="number">0x243185be</span>, <span class="number">0x550c7dc3</span>, <span class="number">0x72be5d74</span>, <span class="number">0x80deb1fe</span>, <span class="number">0x9bdc06a7</span>, <span class="number">0xc19bf174</span>,</span><br><span class="line">    <span class="number">0xe49b69c1</span>, <span class="number">0xefbe4786</span>, <span class="number">0x0fc19dc6</span>, <span class="number">0x240ca1cc</span>, <span class="number">0x2de92c6f</span>, <span class="number">0x4a7484aa</span>, <span class="number">0x5cb0a9dc</span>, <span class="number">0x76f988da</span>,</span><br><span class="line">    <span class="number">0x983e5152</span>, <span class="number">0xa831c66d</span>, <span class="number">0xb00327c8</span>, <span class="number">0xbf597fc7</span>, <span class="number">0xc6e00bf3</span>, <span class="number">0xd5a79147</span>, <span class="number">0x06ca6351</span>, <span class="number">0x14292967</span>,</span><br><span class="line">    <span class="number">0x27b70a85</span>, <span class="number">0x2e1b2138</span>, <span class="number">0x4d2c6dfc</span>, <span class="number">0x53380d13</span>, <span class="number">0x650a7354</span>, <span class="number">0x766a0abb</span>, <span class="number">0x81c2c92e</span>, <span class="number">0x92722c85</span>,</span><br><span class="line">    <span class="number">0xa2bfe8a1</span>, <span class="number">0xa81a664b</span>, <span class="number">0xc24b8b70</span>, <span class="number">0xc76c51a3</span>, <span class="number">0xd192e819</span>, <span class="number">0xd6990624</span>, <span class="number">0xf40e3585</span>, <span class="number">0x106aa070</span>,</span><br><span class="line">    <span class="number">0x19a4c116</span>, <span class="number">0x1e376c08</span>, <span class="number">0x2748774c</span>, <span class="number">0x34b0bcb5</span>, <span class="number">0x391c0cb3</span>, <span class="number">0x4ed8aa4a</span>, <span class="number">0x5b9cca4f</span>, <span class="number">0x682e6ff3</span>,</span><br><span class="line">    <span class="number">0x748f82ee</span>, <span class="number">0x78a5636f</span>, <span class="number">0x84c87814</span>, <span class="number">0x8cc70208</span>, <span class="number">0x90befffa</span>, <span class="number">0xa4506ceb</span>, <span class="number">0xbef9a3f7</span>, <span class="number">0xc67178f2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sha256</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *data, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> h0 = <span class="number">0x6a09e667</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> h1 = <span class="number">0xbb67ae85</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> h2 = <span class="number">0x3c6ef372</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> h3 = <span class="number">0xa54ff53a</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> h4 = <span class="number">0x510e527f</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> h5 = <span class="number">0x9b05688c</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> h6 = <span class="number">0x1f83d9ab</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> h7 = <span class="number">0x5be0cd19</span>;</span><br><span class="line">    <span class="comment">//省略掉其他逻辑的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后搜索一下常量特征</p><p><img src="/2021/02/03/zuoye9/image-20210203230322069.png" alt="image-20210203230322069"></p><p>然后我们看看那个类似MD5_Init的常量是否发生了改变。搜索一下特征0x6a09e667</p><p><img src="/2021/02/03/zuoye9/image-20210203232750391.png" alt="image-20210203232750391"></p><p>没有啥变化。和上面的h0-h7的常量对比。是一致的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一些日常使用frida经常会用到的一些小方法</title>
      <link href="/2021/01/31/frida1/"/>
      <url>/2021/01/31/frida1/</url>
      
        <content type="html"><![CDATA[<p>整理一下之前的学习笔记。以及常用的一些frida的技巧。以备哪天快速回顾</p><p>首先是常规的java层的函数hook</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> manActivity=Java.use(<span class="string">&quot;com.kanxue.algorithmbase.MainActivity&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> res= manActivity.encodeFromJni_71(input)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;input:&quot;</span>,input,<span class="string">&quot;output:&quot;</span>,res);</span><br></pre></td></tr></table></figure><p>然后是主动调用函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主动调用静态函数</span></span><br><span class="line"><span class="keyword">var</span> FridaActivity2 = Java.use(<span class="string">&quot;com.kanxue.algorithmbase.MainActivity&quot;</span>);</span><br><span class="line">FridaActivity2.setStatic_bool_var(); </span><br><span class="line"><span class="comment">//主动调用非静态函数</span></span><br><span class="line">Java.choose(<span class="string">&quot;com.example.androiddemo.Activity.FridaActivity2&quot;</span>, &#123;</span><br><span class="line">  onMatch: <span class="function"><span class="keyword">function</span> (<span class="params">instance</span>) </span>&#123;</span><br><span class="line">    instance.setBool_var();</span><br><span class="line">  &#125;,</span><br><span class="line">  onComplete: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>主动设置成员变量</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> FridaActivity3 = Java.use(<span class="string">&quot;com.example.androiddemo.Activity.FridaActivity3&quot;</span>);</span><br><span class="line"><span class="comment">//设置非静态成员变量的值</span></span><br><span class="line">FridaActivity3.static_bool_var.value = <span class="literal">true</span>;        </span><br><span class="line"><span class="built_in">console</span>.log(FridaActivity3.static_bool_var.value);</span><br><span class="line">Java.choose(<span class="string">&quot;com.example.androiddemo.Activity.FridaActivity3&quot;</span>, &#123;</span><br><span class="line">  onMatch: <span class="function"><span class="keyword">function</span> (<span class="params">instance</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//设置非静态成员变量的值</span></span><br><span class="line">  instance.bool_var.value = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">//设置有相同函数名的成员变量的值</span></span><br><span class="line">  instance._same_name_bool_var.value = <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(instance.bool_var.value, instance._same_name_bool_var.value);</span><br><span class="line">  &#125;,</span><br><span class="line">  onComplete: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>hook内部类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> InnerClasses = Java.use(<span class="string">&quot;com.example.androiddemo.Activity.FridaActivity4$InnerClasses&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(InnerClasses);</span><br><span class="line">InnerClasses.check1.implementation = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据条件判断动态hook多个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> class_name = <span class="string">&quot;com.example.androiddemo.Activity.FridaActivity4$InnerClasses&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> InnerClasses = Java.use(class_name);</span><br><span class="line"><span class="keyword">var</span> all_methods = InnerClasses.class.getDeclaredMethods();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; all_methods.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> method = (all_methods[i]);</span><br><span class="line">  <span class="keyword">var</span> methodStr = method.toString();</span><br><span class="line">  <span class="keyword">var</span> substring = methodStr.substr(methodStr.indexOf(class_name) + class_name.length + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> methodname = substring.substr(<span class="number">0</span>, substring.indexOf(<span class="string">&quot;(&quot;</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(methodname);</span><br><span class="line">  InnerClasses[methodname].implementation = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hook_mul_function:&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>interface中的函数进行hook。需要先切换classloader</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> FridaActivity5 = Java.use(<span class="string">&quot;com.example.androiddemo.Activity.FridaActivity5&quot;</span>);</span><br><span class="line">Java.choose(<span class="string">&quot;com.example.androiddemo.Activity.FridaActivity5&quot;</span>, &#123;</span><br><span class="line">  onMatch: <span class="function"><span class="keyword">function</span> (<span class="params">instance</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(instance.getDynamicDexCheck().$className);</span><br><span class="line">  &#125;, <span class="attr">onComplete</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Java.enumerateClassLoaders(&#123;</span><br><span class="line">  onMatch: <span class="function"><span class="keyword">function</span> (<span class="params">loader</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (loader.findClass(<span class="string">&quot;com.example.androiddemo.Dynamic.DynamicCheck&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(loader);</span><br><span class="line">        Java.classFactory.loader = loader;  </span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="attr">onComplete</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> DynamicCheck = Java.use(<span class="string">&quot;com.example.androiddemo.Dynamic.DynamicCheck&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(DynamicCheck);</span><br><span class="line">DynamicCheck.check.implementation = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;DynamicCheck.check&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>frida动态加载dex然后再调用dex中的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ddex2 = Java.openClassFile(<span class="string">&quot;/data/local/tmp/ddex2.dex&quot;</span>);</span><br><span class="line">ddex2.load();</span><br><span class="line"><span class="keyword">var</span> DecodeUtils = Java.use(<span class="string">&quot;com.example.androiddemo.DecodeUtils&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;DecodeUtils.decode_p:&quot;</span>, DecodeUtils.decode_p());</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>hook构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = Java.use(<span class="string">&quot;com.tlamb96.kgbmessenger.b.a&quot;</span>);</span><br><span class="line">  <span class="comment">//hook 构造函数</span></span><br><span class="line">  a.$init.implementation = <span class="function"><span class="keyword">function</span> (<span class="params">i, str, str2, z</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.$init(i, str, str2, z);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;a.$init:&quot;</span>, i, str, str2, z);</span><br><span class="line">  print_stack();       <span class="comment">//打印了调用栈</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>打印java堆栈</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print_stack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> Exception = Java.use(<span class="string">&quot;java.lang.Exception&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> instance = Exception.$new(<span class="string">&quot;print_stack&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> stack = instance.getStackTrace();</span><br><span class="line">        <span class="built_in">console</span>.log(stack);</span><br><span class="line">        instance.$dispose();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用NativeFunction来写入文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write_reg_dat2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//把C函数定义为NativeFunction来写文件</span></span><br><span class="line">    <span class="keyword">var</span> addr_fopen = Module.findExportByName(<span class="string">&quot;libc.so&quot;</span>, <span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> addr_fputs = Module.findExportByName(<span class="string">&quot;libc.so&quot;</span>, <span class="string">&quot;fputs&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> addr_fclose = Module.findExportByName(<span class="string">&quot;libc.so&quot;</span>, <span class="string">&quot;fclose&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;addr_fopen:&quot;</span>, addr_fopen, <span class="string">&quot;addr_fputs:&quot;</span>, addr_fputs, <span class="string">&quot;addr_fclose:&quot;</span>, addr_fclose);</span><br><span class="line">    <span class="keyword">var</span> fopen = <span class="keyword">new</span> NativeFunction(addr_fopen, <span class="string">&quot;pointer&quot;</span>, [<span class="string">&quot;pointer&quot;</span>, <span class="string">&quot;pointer&quot;</span>]);</span><br><span class="line">    <span class="keyword">var</span> fputs = <span class="keyword">new</span> NativeFunction(addr_fputs, <span class="string">&quot;int&quot;</span>, [<span class="string">&quot;pointer&quot;</span>, <span class="string">&quot;pointer&quot;</span>]);</span><br><span class="line">    <span class="keyword">var</span> fclose = <span class="keyword">new</span> NativeFunction(addr_fclose, <span class="string">&quot;int&quot;</span>, [<span class="string">&quot;pointer&quot;</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> filename = Memory.allocUtf8String(<span class="string">&quot;/sdcard/reg.dat&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> open_mode = Memory.allocUtf8String(<span class="string">&quot;w+&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> file = fopen(filename, open_mode);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;fopen file:&quot;</span>, file);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> buffer = Memory.allocUtf8String(<span class="string">&quot;EoPAoY62@ElRD&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> ret = fputs(buffer, file);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;fputs ret:&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">    fclose(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将指针以字符串的方式打印</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print_string</span>(<span class="params">addr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> base_hello_jni = Module.findBaseAddress(<span class="string">&quot;libhello-jni.so&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> addr_str = base_hello_jni.add(addr);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;addr:&quot;</span>, addr, <span class="string">&quot; &quot;</span>, ptr(addr_str).readCString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>延时hook。当用frida来启动应用时。hook的so还没有加载。所以要延时到加载完这个so后。才能hook</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_dlopen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dlopen = Module.findExportByName(<span class="literal">null</span>, <span class="string">&quot;dlopen&quot;</span>);</span><br><span class="line">    Interceptor.attach(dlopen, &#123;</span><br><span class="line">        onEnter: <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.call_hook = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">var</span> so_name = ptr(args[<span class="number">0</span>]).readCString();</span><br><span class="line">            <span class="keyword">if</span> (so_name.indexOf(<span class="string">&quot;libhello-jni.so&quot;</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;dlopen:&quot;</span>, ptr(args[<span class="number">0</span>]).readCString());</span><br><span class="line">                <span class="built_in">this</span>.call_hook = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="attr">onLeave</span>: <span class="function"><span class="keyword">function</span> (<span class="params">retval</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.call_hook) &#123;</span><br><span class="line">                inline_hook();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 高版本Android系统使用android_dlopen_ext</span></span><br><span class="line">    <span class="keyword">var</span> android_dlopen_ext = Module.findExportByName(<span class="literal">null</span>, <span class="string">&quot;android_dlopen_ext&quot;</span>);</span><br><span class="line">    Interceptor.attach(android_dlopen_ext, &#123;</span><br><span class="line">        onEnter: <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.call_hook = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">var</span> so_name = ptr(args[<span class="number">0</span>]).readCString();</span><br><span class="line">            <span class="keyword">if</span> (so_name.indexOf(<span class="string">&quot;libhello-jni.so&quot;</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;android_dlopen_ext:&quot;</span>, ptr(args[<span class="number">0</span>]).readCString());</span><br><span class="line">                <span class="built_in">this</span>.call_hook = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="attr">onLeave</span>: <span class="function"><span class="keyword">function</span> (<span class="params">retval</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.call_hook) &#123;</span><br><span class="line">                inline_hook();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>hook获取时间的函数。并且替换函数内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_gettimeofday</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> addr_gettimeofday = Module.findExportByName(<span class="literal">null</span>, <span class="string">&quot;gettimeofday&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> gettimeofday = <span class="keyword">new</span> NativeFunction(addr_gettimeofday, <span class="string">&quot;int&quot;</span>, [<span class="string">&quot;pointer&quot;</span>, <span class="string">&quot;pointer&quot;</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> source = [</span><br><span class="line">        <span class="string">&#x27;struct timeval &#123;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;    int tv_sec;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;    int tv_usec;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&#125;;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;void modify_time(struct timeval* tv, int tv_sec, int tv_usec) &#123;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;  tv-&gt;tv_sec = tv_sec;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;  tv-&gt;tv_usec = tv_usec;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>,</span><br><span class="line">    ].join(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cm = <span class="keyword">new</span> CModule(source);</span><br><span class="line">    <span class="keyword">var</span> modify_time = <span class="keyword">new</span> NativeFunction(cm.modify_time, <span class="string">&#x27;void&#x27;</span>, [<span class="string">&quot;pointer&quot;</span>, <span class="string">&quot;int&quot;</span>, <span class="string">&quot;int&quot;</span>]);</span><br><span class="line"></span><br><span class="line">    Interceptor.replace(addr_gettimeofday, <span class="keyword">new</span> NativeCallback(<span class="function"><span class="keyword">function</span> (<span class="params">ptr_tz, ptr_tzp</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> result = gettimeofday(ptr_tz, ptr_tzp);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;hook gettimeofday:&quot;</span>, ptr_tz, ptr_tzp, result);</span><br><span class="line">            <span class="comment">//modify_time(ptr_tz, 0xAAAA, 0xBBBB);</span></span><br><span class="line">            <span class="keyword">var</span> t = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(<span class="built_in">ArrayBuffer</span>.wrap(ptr_tz, <span class="number">8</span>));</span><br><span class="line">            t[<span class="number">0</span>] = <span class="number">0xAAAA</span>;</span><br><span class="line">            t[<span class="number">1</span>] = <span class="number">0xBBBB</span>;</span><br><span class="line">            <span class="built_in">console</span>.log(hexdump(ptr_tz));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;, <span class="string">&quot;int&quot;</span>, [<span class="string">&quot;pointer&quot;</span>, <span class="string">&quot;pointer&quot;</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>frida打patch补丁。可以用来搞反调试的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dis</span>(<span class="params">address, number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> ins = Instruction.parse(address);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;address:&quot;</span> + address + <span class="string">&quot;--dis:&quot;</span> + ins.toString());</span><br><span class="line">        address = ins.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//libc-&gt;strstr()</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//call_function(&quot;DT_INIT&quot;, init_func_, get_realpath());</span></span><br><span class="line">    <span class="keyword">var</span> linkermodule = Process.getModuleByName(<span class="string">&quot;linker&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> call_function_addr = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> symbols = linkermodule.enumerateSymbols();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; symbols.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> symbol = symbols[i];</span><br><span class="line">        <span class="comment">//LogPrint(linkername + &quot;-&gt;&quot; + symbol.name + &quot;---&quot; + symbol.address);</span></span><br><span class="line">        <span class="keyword">if</span> (symbol.name.indexOf(<span class="string">&quot;__dl__ZL13call_functionPKcPFviPPcS2_ES0_&quot;</span>) != <span class="number">-1</span>) &#123;</span><br><span class="line">            call_function_addr = symbol.address;</span><br><span class="line">            <span class="comment">//LogPrint(&quot;linker-&gt;&quot; + symbol.name + &quot;---&quot; + symbol.address)</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Interceptor.attach(call_function_addr, &#123;</span><br><span class="line">        onEnter: <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> type = ptr(args[<span class="number">0</span>]).readUtf8String();</span><br><span class="line">            <span class="keyword">var</span> address = args[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">var</span> sopath = ptr(args[<span class="number">2</span>]).readUtf8String();</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;loadso:&quot;</span> + sopath + <span class="string">&quot;--addr:&quot;</span> + address + <span class="string">&quot;--type:&quot;</span> + type);</span><br><span class="line">            <span class="keyword">if</span> (sopath.indexOf(<span class="string">&quot;libnative-lib.so&quot;</span>) != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> libnativemodule = Process.getModuleByName(<span class="string">&quot;libnative-lib.so&quot;</span>);</span><br><span class="line">                <span class="keyword">var</span> base = libnativemodule.base;</span><br><span class="line">                dis(base.add(<span class="number">0x8D8E</span>).add(<span class="number">1</span>), <span class="number">10</span>);</span><br><span class="line">                <span class="keyword">var</span> patchaddr = base.add(<span class="number">0x8d96</span>);</span><br><span class="line">                Memory.patchCode(patchaddr, <span class="number">4</span>, <span class="function"><span class="params">patchaddr</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">var</span> cw = <span class="keyword">new</span> ThumbWriter(patchaddr);</span><br><span class="line">                    cw.putNop();</span><br><span class="line">                    cw = <span class="keyword">new</span> ThumbWriter(patchaddr.add(<span class="number">0x2</span>));</span><br><span class="line">                    cw.putNop();</span><br><span class="line">                    cw.flush();</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">/*                Memory.protect(base.add(0x8d96),4,&#x27;rwx&#x27;);</span></span><br><span class="line"><span class="comment">                                base.add(0x8d96).writeByteArray([0x00,0xbf,0x00,0xbf]);*/</span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;+++++++++++++++++++++++&quot;</span>)</span><br><span class="line">                dis(base.add(<span class="number">0x8D8E</span>).add(<span class="number">1</span>), <span class="number">10</span>);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;----------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">                dis(base.add(<span class="number">0x8E6E</span>).add(<span class="number">1</span>), <span class="number">10</span>);</span><br><span class="line">                Memory.protect(base.add(<span class="number">0x8E78</span>), <span class="number">4</span>, <span class="string">&#x27;rwx&#x27;</span>);</span><br><span class="line">                base.add(<span class="number">0x8E78</span>).writeByteArray([<span class="number">0x00</span>, <span class="number">0xbf</span>, <span class="number">0x00</span>, <span class="number">0xbf</span>]);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;+++++++++++++++++++++++&quot;</span>)</span><br><span class="line">                dis(base.add(<span class="number">0x8E6E</span>).add(<span class="number">1</span>), <span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用stalker来trace</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_native</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> base_addr=Module.getBaseAddress(<span class="string">&quot;libnative-lib.so&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> encodeFromJni_71=base_addr.add(<span class="number">0x156B4</span>);</span><br><span class="line">    Interceptor.attach(encodeFromJni_71,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.tid=Process.getCurrentThreadId();</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;enter encodeFromJni_71 tid:&quot;</span>,<span class="built_in">this</span>.tid);</span><br><span class="line">            Stalker.follow(<span class="built_in">this</span>.tid, &#123;</span><br><span class="line">                events: &#123;</span><br><span class="line">                    call: <span class="literal">true</span>, <span class="comment">// CALL instructions: yes please</span></span><br><span class="line">                    <span class="comment">// Other events:</span></span><br><span class="line">                    ret: <span class="literal">false</span>, <span class="comment">// RET instructions</span></span><br><span class="line">                    exec: <span class="literal">false</span>, <span class="comment">// all instructions: not recommended as it&#x27;s</span></span><br><span class="line">                                 <span class="comment">//                   a lot of data</span></span><br><span class="line">                    block: <span class="literal">false</span>, <span class="comment">// block executed: coarse execution trace</span></span><br><span class="line">                    compile: <span class="literal">false</span> <span class="comment">// block compiled: useful for coverage</span></span><br><span class="line">                &#125;,</span><br><span class="line">                onCallSummary:<span class="function"><span class="keyword">function</span>(<span class="params">summary</span>)</span>&#123;        <span class="comment">//调用的地址和调用的次数</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">var</span> iter <span class="keyword">in</span> summary)&#123;</span><br><span class="line">                        <span class="keyword">var</span> <span class="built_in">module</span>= Process.getModuleByAddress(ptr(iter))</span><br><span class="line">                        <span class="keyword">if</span>(<span class="built_in">module</span>.name.indexOf(<span class="string">&quot;libnative-lib.so&quot;</span>)!=<span class="number">-1</span>)&#123;</span><br><span class="line">                            <span class="built_in">console</span>.log(ptr(iter).sub(<span class="built_in">module</span>.base));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                onReceive:<span class="function"><span class="keyword">function</span>(<span class="params">events</span>)</span>&#123;             <span class="comment">//调用的流程，地址1是哪里发生的调用。地址2是调用到了哪里</span></span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&quot;enter onReceive&quot;</span>)</span><br><span class="line">                    <span class="keyword">var</span> eventsData=Stalker.parse(events,&#123;</span><br><span class="line">                        annotate: <span class="literal">true</span>,</span><br><span class="line">                        stringify: <span class="literal">true</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">var</span> idx <span class="keyword">in</span> eventsData)&#123;</span><br><span class="line">                        <span class="keyword">var</span> dataSp=eventsData[idx];</span><br><span class="line">                        <span class="keyword">var</span> addr1=dataSp[<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">var</span> addr2=dataSp[<span class="number">2</span>];</span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            <span class="keyword">var</span> module1=Process.getModuleByAddress(ptr(addr1));</span><br><span class="line">                            <span class="keyword">if</span>(module1.name.indexOf(<span class="string">&quot;libnative-lib.so&quot;</span>)!=<span class="number">-1</span>)&#123;</span><br><span class="line">                                <span class="keyword">var</span> module2=Process.getModuleByAddress(ptr(addr2));</span><br><span class="line">                                <span class="built_in">console</span>.log(dataSp[<span class="number">0</span>],module1.name,addr1,module2.name,addr2);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">                            <span class="built_in">console</span>.log(dataSp);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,onLeave(retval)&#123;</span><br><span class="line">            Stalker.unfollow(<span class="built_in">this</span>.tid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较通用的native函数hook打印</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hexdumpMem</span>(<span class="params">addr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Process.findRangeByAddress(addr))&#123;</span><br><span class="line">        <span class="keyword">return</span> hexdump(ptr(addr),&#123;<span class="attr">length</span>:<span class="number">0x40</span>&#125;)+<span class="string">&quot;\r\n&quot;</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr(addr)+<span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//比较通用的hook地址并且打印5个参数。如果参数是地址就打印下内存信息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nativeHookFunction</span>(<span class="params">addr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> base_addr=Module.getBaseAddress(<span class="string">&quot;libnative-lib.so&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> hook_addr=base_addr.add(addr);</span><br><span class="line">    Interceptor.attach(hook_addr,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.logs=[];</span><br><span class="line">            <span class="built_in">this</span>.logs.push(<span class="string">&quot;call&quot;</span>,addr);</span><br><span class="line">            <span class="built_in">this</span>.arg0=args[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">this</span>.arg1=args[<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">this</span>.arg2=args[<span class="number">2</span>];</span><br><span class="line">            <span class="built_in">this</span>.arg3=args[<span class="number">3</span>];</span><br><span class="line">            <span class="built_in">this</span>.arg4=args[<span class="number">4</span>];</span><br><span class="line">            <span class="built_in">this</span>.arg5=args[<span class="number">5</span>];</span><br><span class="line">            <span class="built_in">this</span>.logs.push(<span class="string">&quot;arg0:&quot;</span>,hexdumpMem(<span class="built_in">this</span>.arg0));</span><br><span class="line">            <span class="built_in">this</span>.logs.push(<span class="string">&quot;arg1:&quot;</span>,hexdumpMem(<span class="built_in">this</span>.arg1));</span><br><span class="line">            <span class="built_in">this</span>.logs.push(<span class="string">&quot;arg2:&quot;</span>,hexdumpMem(<span class="built_in">this</span>.arg2));</span><br><span class="line">            <span class="built_in">this</span>.logs.push(<span class="string">&quot;arg3:&quot;</span>,hexdumpMem(<span class="built_in">this</span>.arg3));</span><br><span class="line">            <span class="built_in">this</span>.logs.push(<span class="string">&quot;arg4:&quot;</span>,hexdumpMem(<span class="built_in">this</span>.arg4));</span><br><span class="line">            <span class="built_in">this</span>.logs.push(<span class="string">&quot;arg5:&quot;</span>,hexdumpMem(<span class="built_in">this</span>.arg5));</span><br><span class="line">        &#125;,<span class="attr">onLeave</span>:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.logs.push(<span class="string">&quot;arg0 leave:&quot;</span>,hexdumpMem(<span class="built_in">this</span>.arg0));</span><br><span class="line">            <span class="built_in">this</span>.logs.push(<span class="string">&quot;arg1 leave:&quot;</span>,hexdumpMem(<span class="built_in">this</span>.arg1));</span><br><span class="line">            <span class="built_in">this</span>.logs.push(<span class="string">&quot;arg2 leave:&quot;</span>,hexdumpMem(<span class="built_in">this</span>.arg2));</span><br><span class="line">            <span class="built_in">this</span>.logs.push(<span class="string">&quot;arg3 leave:&quot;</span>,hexdumpMem(<span class="built_in">this</span>.arg3));</span><br><span class="line">            <span class="built_in">this</span>.logs.push(<span class="string">&quot;arg4 leave:&quot;</span>,hexdumpMem(<span class="built_in">this</span>.arg4));</span><br><span class="line">            <span class="built_in">this</span>.logs.push(<span class="string">&quot;arg5 leave:&quot;</span>,hexdumpMem(<span class="built_in">this</span>.arg5));</span><br><span class="line">            <span class="built_in">this</span>.logs.push(<span class="string">&quot;retval leave:&quot;</span>,hexdumpMem(retval));</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.logs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Frida打印java中的byte数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bytes2HexString</span>(<span class="params">arrBytes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arrBytes.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> tmp;</span><br><span class="line">        <span class="keyword">var</span> num = arrBytes[i];</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//此处填坑，当byte因为符合位导致数值为负时候，需要对数据进行处理</span></span><br><span class="line">            tmp = (<span class="number">255</span> + num + <span class="number">1</span>).toString(<span class="number">16</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp = num.toString(<span class="number">16</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp.length === <span class="number">1</span>) &#123;</span><br><span class="line">            tmp = <span class="string">&quot;0&quot;</span> + tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        str += tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> frida </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法还原实战8</title>
      <link href="/2021/01/27/zuoye8/"/>
      <url>/2021/01/27/zuoye8/</url>
      
        <content type="html"><![CDATA[<p>分析样例下载：链接: <a href="https://pan.baidu.com/s/1sl0rnYC2u0wre0YYutIwhg">https://pan.baidu.com/s/1sl0rnYC2u0wre0YYutIwhg</a>  密码: 26b9</p><p>练习algorithmbase_71.apk</p><p>ida打开libnative-lib.so找到encodeFromJni_171。然后frida打印下输出结果。观察看有什么特征</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">call_encodeFromJni_71</span>(<span class="params">input</span>)</span>&#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> native_lib=Java.use(<span class="string">&quot;com.kanxue.algorithmbase.MainActivity&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> res= native_lib.encodeFromJni_71(input)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;input:&quot;</span>,input,<span class="string">&quot;output:&quot;</span>,res);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后主动填参数调用一下。看看长度不同的时候加密数据的特征</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">input: 0000 output: 290BE933FC53A33BB5DA56800BBCE79C</span><br><span class="line">input: 00000000 output: 5E88221ADFE7AC9EC43B51D6547D697B</span><br><span class="line">input: 0000000000000000 output: 5E88221ADFE7AC9EC43B51D6547D697B</span><br><span class="line">input: 00000000000000000000 output: 5E88221ADFE7AC9EC43B51D6547D697B</span><br><span class="line">input: 00000000000000000000000000000000000000000000 output: 290BE933FC53A33BB5DA56800BBCE79</span><br></pre></td></tr></table></figure><p>然后发现加密数据的长度不会变化。那么这个可能是一个hash算法。比如MD5、SHA之类的。但是意外的发现第2、3、4条数据的结果一致。并且直接hook的时候。结果的长度也发生了巨大的变化。如下</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input: PPZOJXVYlPosRUmYAEFvDaaGyxfqIqaLKHnE output: FF9314F66ACB16596546183E91989D09D78F7E38D8970BDA322E791AD1718B6C793C4C09F2B1F01BFC56474603FF6112</span><br></pre></td></tr></table></figure><p>看起来似乎是一个非标准算法。接着我们先尝试下trace。由于刚看视频学了下stalker。所以这里就不用unidbg来跑了。下面先写一个frida来hook所有的call</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hexdumpMem</span>(<span class="params">addr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Process.findRangeByAddress(addr))&#123;</span><br><span class="line">        <span class="keyword">return</span> hexdump(ptr(addr),&#123;<span class="attr">length</span>:<span class="number">0x40</span>&#125;)+<span class="string">&quot;\r\n&quot;</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr(addr)+<span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//比较通用的hook地址并且打印5个参数。如果参数是地址就打印下内存信息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nativeHookFunction</span>(<span class="params">addr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> base_addr=Module.getBaseAddress(<span class="string">&quot;libnative-lib.so&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> hook_addr=base_addr.add(addr);</span><br><span class="line">    Interceptor.attach(hook_addr,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.logs=[];</span><br><span class="line">            <span class="built_in">this</span>.logs.push(<span class="string">&quot;call&quot;</span>,addr.sub(base_addr));</span><br><span class="line">            <span class="built_in">this</span>.arg0=args[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">this</span>.arg1=args[<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">this</span>.arg2=args[<span class="number">2</span>];</span><br><span class="line">            <span class="built_in">this</span>.arg3=args[<span class="number">3</span>];</span><br><span class="line">            <span class="built_in">this</span>.arg4=args[<span class="number">4</span>];</span><br><span class="line">            <span class="built_in">this</span>.arg5=args[<span class="number">5</span>];</span><br><span class="line">            <span class="built_in">this</span>.logs.push(<span class="string">&quot;arg0:&quot;</span>,hexdumpMem(<span class="built_in">this</span>.arg0));</span><br><span class="line">            <span class="built_in">this</span>.logs.push(<span class="string">&quot;arg1:&quot;</span>,hexdumpMem(<span class="built_in">this</span>.arg1));</span><br><span class="line">            <span class="built_in">this</span>.logs.push(<span class="string">&quot;arg2:&quot;</span>,hexdumpMem(<span class="built_in">this</span>.arg2));</span><br><span class="line">            <span class="built_in">this</span>.logs.push(<span class="string">&quot;arg3:&quot;</span>,hexdumpMem(<span class="built_in">this</span>.arg3));</span><br><span class="line">            <span class="built_in">this</span>.logs.push(<span class="string">&quot;arg4:&quot;</span>,hexdumpMem(<span class="built_in">this</span>.arg4));</span><br><span class="line">            <span class="built_in">this</span>.logs.push(<span class="string">&quot;arg5:&quot;</span>,hexdumpMem(<span class="built_in">this</span>.arg5));</span><br><span class="line">        &#125;,<span class="attr">onLeave</span>:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.logs.push(<span class="string">&quot;arg0 leave:&quot;</span>,hexdumpMem(<span class="built_in">this</span>.arg0));</span><br><span class="line">            <span class="built_in">this</span>.logs.push(<span class="string">&quot;arg1 leave:&quot;</span>,hexdumpMem(<span class="built_in">this</span>.arg1));</span><br><span class="line">            <span class="built_in">this</span>.logs.push(<span class="string">&quot;arg2 leave:&quot;</span>,hexdumpMem(<span class="built_in">this</span>.arg2));</span><br><span class="line">            <span class="built_in">this</span>.logs.push(<span class="string">&quot;arg3 leave:&quot;</span>,hexdumpMem(<span class="built_in">this</span>.arg3));</span><br><span class="line">            <span class="built_in">this</span>.logs.push(<span class="string">&quot;arg4 leave:&quot;</span>,hexdumpMem(<span class="built_in">this</span>.arg4));</span><br><span class="line">            <span class="built_in">this</span>.logs.push(<span class="string">&quot;arg5 leave:&quot;</span>,hexdumpMem(<span class="built_in">this</span>.arg5));</span><br><span class="line">            <span class="built_in">this</span>.logs.push(<span class="string">&quot;retval leave:&quot;</span>,hexdumpMem(retval));</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.logs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_native</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> base_addr=Module.getBaseAddress(<span class="string">&quot;libnative-lib.so&quot;</span>);</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x1894c</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x15da4</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x517c4</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x5c6d8</span>));</span><br><span class="line">    <span class="comment">// nativeHookFunction(ptr(0xfd50));           .memcpy</span></span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x8bef4</span>));</span><br><span class="line">    <span class="comment">// nativeHookFunction(ptr(0xfd00));             .strlen</span></span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x93cd4</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x17428</span>));</span><br><span class="line">    <span class="comment">// nativeHookFunction(ptr(0x8fafc));</span></span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x163ec</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x12d38</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x9429c</span>));</span><br><span class="line">    <span class="comment">// nativeHookFunction(ptr(0xfdb0));         .free</span></span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x10ad0</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x648a8</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x133b8</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x145fc</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x59684</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x6b640</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x5ac58</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x5799c</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x91b84</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x10638</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x8cc8c</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x8d678</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x1716c</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x4f458</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x17704</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x4f018</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x18c7c</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x58f38</span>));</span><br><span class="line">    <span class="comment">// nativeHookFunction(ptr(0xfd40));         .malloc</span></span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x52814</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x97568</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x50790</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x56808</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x103b4</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x191c4</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x1a73c</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x8c944</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x8cc10</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x8bfc0</span>));</span><br><span class="line">    <span class="comment">// nativeHookFunction(ptr(0xf9e0));         ._Znwm</span></span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x975f4</span>));</span><br><span class="line">    <span class="comment">// nativeHookFunction(ptr(0xfd70));         .memset</span></span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x58190</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x1846c</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x68b1c</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x17954</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x506e4</span>));</span><br><span class="line">    <span class="comment">// nativeHookFunction(ptr(0xfc50));         ._ZdlPv</span></span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x536d4</span>));</span><br><span class="line">    nativeHookFunction(ptr(<span class="number">0x4f6c0</span>));</span><br><span class="line">    <span class="keyword">var</span> encodeFromJni_71=base_addr.add(<span class="number">0x156B4</span>);</span><br><span class="line">    Interceptor.attach(encodeFromJni_71,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.tid=Process.getCurrentThreadId();</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;enter encodeFromJni_71 tid:&quot;</span>,<span class="built_in">this</span>.tid);</span><br><span class="line">            Stalker.follow(<span class="built_in">this</span>.tid, &#123;</span><br><span class="line">                events: &#123;</span><br><span class="line">                    call: <span class="literal">true</span>, <span class="comment">// CALL instructions: yes please</span></span><br><span class="line">                    <span class="comment">// Other events:</span></span><br><span class="line">                    ret: <span class="literal">false</span>, <span class="comment">// RET instructions</span></span><br><span class="line">                    exec: <span class="literal">false</span>, <span class="comment">// all instructions: not recommended as it&#x27;s</span></span><br><span class="line">                                 <span class="comment">//                   a lot of data</span></span><br><span class="line">                    block: <span class="literal">false</span>, <span class="comment">// block executed: coarse execution trace</span></span><br><span class="line">                    compile: <span class="literal">false</span> <span class="comment">// block compiled: useful for coverage</span></span><br><span class="line">                &#125;,</span><br><span class="line">                onCallSummary:<span class="function"><span class="keyword">function</span>(<span class="params">summary</span>)</span>&#123;        <span class="comment">//调用的地址和调用的次数</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">var</span> iter <span class="keyword">in</span> summary)&#123;</span><br><span class="line">                        <span class="keyword">var</span> <span class="built_in">module</span>= Process.getModuleByAddress(ptr(iter))</span><br><span class="line">                        <span class="keyword">if</span>(<span class="built_in">module</span>.name.indexOf(<span class="string">&quot;libnative-lib.so&quot;</span>)!=<span class="number">-1</span>)&#123;</span><br><span class="line">                            <span class="built_in">console</span>.log(ptr(iter).sub(<span class="built_in">module</span>.base));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">// onReceive:function(events)&#123;             //调用的流程，地址1是哪里发生的调用。地址2是调用到了哪里</span></span><br><span class="line">                <span class="comment">//     console.log(&quot;enter onReceive&quot;)</span></span><br><span class="line">                <span class="comment">//     var eventsData=Stalker.parse(events,&#123;</span></span><br><span class="line">                <span class="comment">//         annotate: true,</span></span><br><span class="line">                <span class="comment">//         stringify: true</span></span><br><span class="line">                <span class="comment">//     &#125;);</span></span><br><span class="line">                <span class="comment">//     for(var idx in eventsData)&#123;</span></span><br><span class="line">                <span class="comment">//         var dataSp=eventsData[idx];</span></span><br><span class="line">                <span class="comment">//         var addr1=dataSp[1];</span></span><br><span class="line">                <span class="comment">//         var addr2=dataSp[2];</span></span><br><span class="line">                <span class="comment">//         try&#123;</span></span><br><span class="line">                <span class="comment">//             var module1=Process.getModuleByAddress(ptr(addr1));</span></span><br><span class="line">                <span class="comment">//             if(module1.name.indexOf(&quot;libnative-lib.so&quot;)!=-1)&#123;</span></span><br><span class="line">                <span class="comment">//                 var module2=Process.getModuleByAddress(ptr(addr2));</span></span><br><span class="line">                <span class="comment">//                 console.log(dataSp[0],module1.name,addr1,module2.name,addr2);</span></span><br><span class="line">                <span class="comment">//             &#125;</span></span><br><span class="line">                <span class="comment">//         &#125;catch(err)&#123;</span></span><br><span class="line">                <span class="comment">//             console.log(dataSp);</span></span><br><span class="line">                <span class="comment">//         &#125;</span></span><br><span class="line">                <span class="comment">//     &#125;</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,onLeave(retval)&#123;</span><br><span class="line">            Stalker.unfollow(<span class="built_in">this</span>.tid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_java</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> native_lib=Java.use(<span class="string">&quot;com.kanxue.algorithmbase.MainActivity&quot;</span>);</span><br><span class="line">        native_lib.encodeFromJni_71.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">input</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> res=<span class="built_in">this</span>.encodeFromJni_71(input);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;input:&quot;</span>,input,<span class="string">&quot;output:&quot;</span>,res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">call_encodeFromJni_71</span>(<span class="params">input</span>)</span>&#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> native_lib=Java.use(<span class="string">&quot;com.kanxue.algorithmbase.MainActivity&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> res= native_lib.encodeFromJni_71(input)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;input:&quot;</span>,input,<span class="string">&quot;output:&quot;</span>,res);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    hook_java();</span><br><span class="line">    hook_native();</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></table></figure><p>这里使用stalker把所有调用的函数获取出来。并且把每个函数都hook上。然后参数都打印出来。这样我们可以搜一下加密结果。然后找到最早先出现的位置。当前这次trace的加密结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input: ZUKZKXAJ output: FF9314F66ACB16596546183E91989D09776013E072D330921D4CE13D47B1D091</span><br></pre></td></tr></table></figure><p>然后搜索FF 93 14 F6。就可以搜索到很多地方有出现了。这里我们找到最早先出现的位置数据如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">call,0x4f6c0,arg0:,             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">77ca768900  78 6e 61 6b 69 5f 65 75 6e 61 79 6d 5f 5f 5f 67  xnaki_eunaym___g</span><br><span class="line">77ca768910  fd a1 ae a5 94 fe cb d0 fa 9f b2 bd a5 c0 ed da  ................</span><br><span class="line">77ca768920  aa a7 14 f2 3e 59 df 22 c4 c6 6d 9f 61 06 80 45  ....&gt;Y.&quot;..m.a..E</span><br><span class="line">77ca768930  c4 48 7b 3b fa 11 a4 19 3e d7 c9 86 5f d1 49 c3  .H&#123;;....&gt;..._.I.</span><br><span class="line">,arg1:,             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">7fcd649d08  6b 61 6e 78 75 65 5f 69 6d 79 61 6e 67 5f 5f 5f  kanxue_imyang___</span><br><span class="line">7fcd649d18  23 d3 eb 22 f2 f5 9e 79 d0 a0 64 cd 7f 00 00 00  #..&quot;...y..d.....</span><br><span class="line">7fcd649d28  80 b1 62 be 77 00 00 00 a0 ea 8b d5 77 00 00 00  ..b.w.......w...</span><br><span class="line">7fcd649d38  a1 95 d3 6e 00 00 00 00 65 a2 50 e8 00 00 00 00  ...n....e.P.....</span><br><span class="line">,arg2:,             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">7fcd649d08  6b 61 6e 78 75 65 5f 69 6d 79 61 6e 67 5f 5f 5f  kanxue_imyang___</span><br><span class="line">7fcd649d18  23 d3 eb 22 f2 f5 9e 79 d0 a0 64 cd 7f 00 00 00  #..&quot;...y..d.....</span><br><span class="line">7fcd649d28  80 b1 62 be 77 00 00 00 a0 ea 8b d5 77 00 00 00  ..b.w.......w...</span><br><span class="line">7fcd649d38  a1 95 d3 6e 00 00 00 00 65 a2 50 e8 00 00 00 00  ...n....e.P.....</span><br><span class="line">,arg3:,0xb559a344</span><br><span class="line">,arg4:,0xdc3faab</span><br><span class="line">,arg5:,0xe825ecad</span><br><span class="line">,arg0 leave:,             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">77ca768900  78 6e 61 6b 69 5f 65 75 6e 61 79 6d 5f 5f 5f 67  xnaki_eunaym___g</span><br><span class="line">77ca768910  fd a1 ae a5 94 fe cb d0 fa 9f b2 bd a5 c0 ed da  ................</span><br><span class="line">77ca768920  aa a7 14 f2 3e 59 df 22 c4 c6 6d 9f 61 06 80 45  ....&gt;Y.&quot;..m.a..E</span><br><span class="line">77ca768930  c4 48 7b 3b fa 11 a4 19 3e d7 c9 86 5f d1 49 c3  .H&#123;;....&gt;..._.I.</span><br><span class="line">,arg1 leave:,             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">7fcd649d08  ff 93 14 f6 6a cb 16 59 65 46 18 3e 91 98 9d 09  ....j..YeF.&gt;....</span><br><span class="line">7fcd649d18  23 d3 eb 22 f2 f5 9e 79 d0 a0 64 cd 7f 00 00 00  #..&quot;...y..d.....</span><br><span class="line">7fcd649d28  80 b1 62 be 77 00 00 00 a0 ea 8b d5 77 00 00 00  ..b.w.......w...</span><br><span class="line">7fcd649d38  a1 95 d3 6e 00 00 00 00 65 a2 50 e8 00 00 00 00  ...n....e.P.....</span><br><span class="line">,arg2 leave:,             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">7fcd649d08  ff 93 14 f6 6a cb 16 59 65 46 18 3e 91 98 9d 09  ....j..YeF.&gt;....</span><br><span class="line">7fcd649d18  23 d3 eb 22 f2 f5 9e 79 d0 a0 64 cd 7f 00 00 00  #..&quot;...y..d.....</span><br><span class="line">7fcd649d28  80 b1 62 be 77 00 00 00 a0 ea 8b d5 77 00 00 00  ..b.w.......w...</span><br><span class="line">7fcd649d38  a1 95 d3 6e 00 00 00 00 65 a2 50 e8 00 00 00 00  ...n....e.P.....</span><br></pre></td></tr></table></figure><p>这里虽然是最早先出现的位置。但是只有前16字节是相同的。后16字节完全不一样。说明可能是分了两次处理的。再找一下后16字节最早出现的位置。</p><p>搜索77 60 13 E0。然后找到第一个找到的数据。列出这块数据如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">call,0x4f6c0,arg0:,             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">77ca768900  78 6e 61 6b 69 5f 65 75 6e 61 79 6d 5f 5f 5f 67  xnaki_eunaym___g</span><br><span class="line">77ca768910  fd a1 ae a5 94 fe cb d0 fa 9f b2 bd a5 c0 ed da  ................</span><br><span class="line">77ca768920  aa a7 14 f2 3e 59 df 22 c4 c6 6d 9f 61 06 80 45  ....&gt;Y.&quot;..m.a..E</span><br><span class="line">77ca768930  c4 48 7b 3b fa 11 a4 19 3e d7 c9 86 5f d1 49 c3  .H&#123;;....&gt;..._.I.</span><br><span class="line">,arg1:,             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">7fcd649d08  ef 83 04 e6 7a db 06 49 75 56 08 2e 81 88 8d 19  ....z..IuV......</span><br><span class="line">7fcd649d18  23 d3 eb 22 f2 f5 9e 79 d0 a0 64 cd 7f 00 00 00  #..&quot;...y..d.....</span><br><span class="line">7fcd649d28  80 b1 62 be 77 00 00 00 a0 ea 8b d5 77 00 00 00  ..b.w.......w...</span><br><span class="line">7fcd649d38  a1 95 d3 6e 00 00 00 00 65 a2 50 e8 00 00 00 00  ...n....e.P.....</span><br><span class="line">,arg2:,             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">7fcd649d08  ef 83 04 e6 7a db 06 49 75 56 08 2e 81 88 8d 19  ....z..IuV......</span><br><span class="line">7fcd649d18  23 d3 eb 22 f2 f5 9e 79 d0 a0 64 cd 7f 00 00 00  #..&quot;...y..d.....</span><br><span class="line">7fcd649d28  80 b1 62 be 77 00 00 00 a0 ea 8b d5 77 00 00 00  ..b.w.......w...</span><br><span class="line">7fcd649d38  a1 95 d3 6e 00 00 00 00 65 a2 50 e8 00 00 00 00  ...n....e.P.....</span><br><span class="line">,arg3:,0x6c7298f0</span><br><span class="line">,arg4:,0xee0b0e20</span><br><span class="line">,arg5:,0xa3437e07</span><br><span class="line">,arg0 leave:,             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">77ca768900  78 6e 61 6b 69 5f 65 75 6e 61 79 6d 5f 5f 5f 67  xnaki_eunaym___g</span><br><span class="line">77ca768910  fd a1 ae a5 94 fe cb d0 fa 9f b2 bd a5 c0 ed da  ................</span><br><span class="line">77ca768920  aa a7 14 f2 3e 59 df 22 c4 c6 6d 9f 61 06 80 45  ....&gt;Y.&quot;..m.a..E</span><br><span class="line">77ca768930  c4 48 7b 3b fa 11 a4 19 3e d7 c9 86 5f d1 49 c3  .H&#123;;....&gt;..._.I.</span><br><span class="line">,arg1 leave:,             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">7fcd649d08  77 60 13 e0 72 d3 30 92 1d 4c e1 3d 47 b1 d0 91  w&#96;..r.0..L.&#x3D;G...</span><br><span class="line">7fcd649d18  23 d3 eb 22 f2 f5 9e 79 d0 a0 64 cd 7f 00 00 00  #..&quot;...y..d.....</span><br><span class="line">7fcd649d28  80 b1 62 be 77 00 00 00 a0 ea 8b d5 77 00 00 00  ..b.w.......w...</span><br><span class="line">7fcd649d38  a1 95 d3 6e 00 00 00 00 65 a2 50 e8 00 00 00 00  ...n....e.P.....</span><br><span class="line">,arg2 leave:,             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">7fcd649d08  77 60 13 e0 72 d3 30 92 1d 4c e1 3d 47 b1 d0 91  w&#96;..r.0..L.&#x3D;G...</span><br><span class="line">7fcd649d18  23 d3 eb 22 f2 f5 9e 79 d0 a0 64 cd 7f 00 00 00  #..&quot;...y..d.....</span><br><span class="line">7fcd649d28  80 b1 62 be 77 00 00 00 a0 ea 8b d5 77 00 00 00  ..b.w.......w...</span><br><span class="line">7fcd649d38  a1 95 d3 6e 00 00 00 00 65 a2 50 e8 00 00 00 00  ...n....e.P.....</span><br><span class="line">,arg3 leave:,0x6c7298f0</span><br><span class="line">,arg4 leave:,0xee0b0e20</span><br><span class="line">,arg5 leave:,0xa3437e07</span><br><span class="line">,retval leave:,0x0</span><br></pre></td></tr></table></figure><p>我们先看前16字节的计算的位置是0x4f6c0。打开这个函数后发现这个函数很有可能就是算法里面了。我们找到一个全局变量</p><p><img src="/2021/01/27/zuoye8/image-20210127214658775.png" alt="image-20210127214658775"></p><p>然后进去看看。里面有我们需要的算法用的常量。可以随便搜索一个看看</p><p><img src="/2021/01/27/zuoye8/image-20210127214747050.png" alt="image-20210127214747050"></p><p>查到的是aes的算法。那么这个分成两段加密。前面这段应该是aes。后面一段还不清楚。我们继续查查aes的key和iv分别是多少。找到调用0x4f6c0函数的sub_4F018。然后直接在日志里面搜索4f018找相应的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">call,0x4f018,arg0:,             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">77bea66080  6b 61 6e 78 75 65 5f 69 6d 79 61 6e 67 5f 5f 5f  kanxue_imyang___</span><br><span class="line">77bea66090  00 00 00 00 00 00 00 00 62 61 73 69 63 5f 73 74  ........basic_st</span><br><span class="line">77bea660a0  72 69 6e 67 00 00 00 00 00 00 00 00 00 00 00 00  ring............</span><br><span class="line">77bea660b0  61 6c 6c 6f 63 61 74 6f 72 3c 54 3e 3a 3a 61 6c  allocator&lt;T&gt;::al</span><br><span class="line">,arg1:,             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">77bea66080  6b 61 6e 78 75 65 5f 69 6d 79 61 6e 67 5f 5f 5f  kanxue_imyang___</span><br><span class="line">77bea66090  00 00 00 00 00 00 00 00 62 61 73 69 63 5f 73 74  ........basic_st</span><br><span class="line">77bea660a0  72 69 6e 67 00 00 00 00 00 00 00 00 00 00 00 00  ring............</span><br><span class="line">77bea660b0  61 6c 6c 6f 63 61 74 6f 72 3c 54 3e 3a 3a 61 6c  allocator&lt;T&gt;::al</span><br><span class="line">,arg2:,             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">77bd8610b0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">77bd8610c0  10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10  ................</span><br><span class="line">77bd8610d0  00 72 69 6e 67 3b 00 00 6e 67 2e 53 74 72 69 00  .ring;..ng.Stri.</span><br><span class="line">77bd8610e0  00 00 00 00 00 00 00 00 6c 2a b1 ff 07 00 00 00  ........l*......</span><br></pre></td></tr></table></figure><p>看到参数1和参数2了。这两个根据上一个例子的经验。kanxue_imyang___就是key和iv了。但是参数3应该是明文。但是结果却是16个00加上16个0x10并不是我们的明文。暂时先不管这段明文怎么来的。我们先验证一下结果对不对</p><p><img src="/2021/01/27/zuoye8/image-20210127221158903.png" alt="image-20210127221158903"></p><p>这里结果可以看到。虽然长度不对。但是前面已经对的上了。说明里面应该是分割了之后。只保留前面的64个字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;之前日志中的记录</span><br><span class="line">input: ZUKZKXAJ output: FF9314F66ACB16596546183E91989D09776013E072D330921D4CE13D47B1D091</span><br><span class="line">&#x2F;&#x2F;我们的aes加密结果</span><br><span class="line">ff9314f66acb16596546183e91989d09776013e072d330921d4ce13d47b1d091  e71526567e0ed0abd725d4941d5ab617</span><br></pre></td></tr></table></figure><p>这里直接就看到结果都在这个里面了。最后我们只要知道怎么从明文数据转换成16个0x0和16个0x10。就可以完成了。搜索16个0x10最早先出现的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">call,0x1846c,arg0:,             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">7fcd649dd8  31 00 00 00 00 00 00 00 20 00 00 00 00 00 00 00  1....... .......</span><br><span class="line">7fcd649de8  b0 10 86 bd 77 00 00 00 10 5a 55 4b 5a 4b 58 41  ....w....ZUKZKXA</span><br><span class="line">7fcd649df8  4a 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  J...............</span><br><span class="line">7fcd649e08  23 d3 eb 22 f2 f5 9e 79 a0 ea 8b d5 77 00 00 00  #..&quot;...y....w...</span><br><span class="line">,arg1:,0x57505bf4</span><br><span class="line">,arg2:,0xea90a458</span><br><span class="line">,arg3:,           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">2fc91a41  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">2fc91a51  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">2fc91a61  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">2fc91a71  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">,arg4:,0xc8f899d0</span><br><span class="line">,arg5:,0xea90a459</span><br><span class="line">,arg0 leave:,             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">7fcd649dd8  31 00 00 00 00 00 00 00 20 00 00 00 00 00 00 00  1....... .......</span><br><span class="line">7fcd649de8  b0 10 86 bd 77 00 00 00 10 5a 55 4b 5a 4b 58 41  ....w....ZUKZKXA</span><br><span class="line">7fcd649df8  4a 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  J...............</span><br><span class="line">7fcd649e08  23 d3 eb 22 f2 f5 9e 79 a0 ea 8b d5 77 00 00 00  #..&quot;...y....w...</span><br><span class="line">,arg1 leave:,0x57505bf4</span><br><span class="line">,arg2 leave:,0xea90a458</span><br><span class="line">,arg3 leave:,           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">2fc91a41  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">2fc91a51  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">2fc91a61  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">2fc91a71  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">,arg4 leave:,0xc8f899d0</span><br><span class="line">,arg5 leave:,0xea90a459</span><br><span class="line">,retval leave:,             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">77bd8610b0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">77bd8610c0  10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10  ................</span><br><span class="line">77bd8610d0  00 72 69 6e 67 3b 00 00 6e 67 2e 53 74 72 69 00  .ring;..ng.Stri.</span><br><span class="line">77bd8610e0  00 00 00 00 00 00 00 00 6c 2a b1 ff 07 00 00 00  ........l*......</span><br></pre></td></tr></table></figure><p>这里我们锁定到了0x1846c这个函数将明文转换成了用来加密的数据。先用frida再针对这一个函数来hook一下。把参数1里面的指针打印下看看</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_native_2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> base_add=Module.getBaseAddress(<span class="string">&quot;libnative-lib.so&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> sub_1846c=base_add.add(<span class="number">0x1846c</span>);</span><br><span class="line">    Interceptor.attach(sub_1846c,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;onenter sub_1846c&quot;</span>)</span><br><span class="line">            <span class="built_in">console</span>.log(Thread.backtrace(<span class="built_in">this</span>.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join(<span class="string">&#x27;\n&#x27;</span>) + <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(args[<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">console</span>.log(hexdumpMem(args[<span class="number">0</span>].add(<span class="number">0x10</span>).readPointer()));</span><br><span class="line"></span><br><span class="line">        &#125;,<span class="attr">onLeave</span>:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;onenter onleave&quot;</span>)</span><br><span class="line">            <span class="built_in">console</span>.log(hexdumpMem(retval));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果发现果然并不是在这里面计算的。其中某一次调用的时候传了这个结果进来。可能只是在这里转存。我们根据打印的堆栈找到encodeFromJni_171+0x4b8的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">onenter sub_1846c</span><br><span class="line">0x77be9b4b6c libnative-lib.so!Java_com_kanxue_algorithmbase_MainActivity_encodeFromJni_171+0x4b8</span><br><span class="line">0x77bec190cc base.odex!oatexec+0xcc</span><br><span class="line"></span><br><span class="line">0x57505bf4</span><br><span class="line">             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">77bd861f50  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">77bd861f60  10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10  ................</span><br><span class="line">77bd861f70  00 72 69 6e 67 3b 00 00 6e 67 2e 53 74 72 69 00  .ring;..ng.Stri.</span><br><span class="line">77bd861f80  61 6e 64 72 6f 69 64 2e 76 69 65 77 2e 52 65 6e  android.view.Ren</span><br><span class="line"></span><br><span class="line">onenter onleave</span><br><span class="line">             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">77bd861f50  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">77bd861f60  10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10  ................</span><br><span class="line">77bd861f70  00 72 69 6e 67 3b 00 00 6e 67 2e 53 74 72 69 00  .ring;..ng.Stri.</span><br><span class="line">77bd861f80  61 6e 64 72 6f 69 64 2e 76 69 65 77 2e 52 65 6e  android.view.Ren</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>找到这里之后。接着就找参数1的值是走过哪些函数。</p><p><img src="/2021/01/27/zuoye8/image-20210127225602919.png" alt="image-20210127225602919"></p><p>我们从sub_15DA4开始。挨个hook一次。看看是哪个函数里面计算出来的这个结果。只要打印参数0的指针数据就可以看出来了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_native_2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> base_add=Module.getBaseAddress(<span class="string">&quot;libnative-lib.so&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> sub_15DA4=base_add.add(<span class="number">0x15DA4</span>);</span><br><span class="line">    Interceptor.attach(sub_15DA4,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;onenter sub_15DA4&quot;</span>)</span><br><span class="line">            <span class="built_in">this</span>.arg0=args[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">console</span>.log(Thread.backtrace(<span class="built_in">this</span>.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join(<span class="string">&#x27;\n&#x27;</span>) + <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(hexdumpMem(<span class="built_in">this</span>.arg0.add(<span class="number">0x10</span>).readPointer()));</span><br><span class="line"></span><br><span class="line">        &#125;,<span class="attr">onLeave</span>:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;onleave sub_15DA4&quot;</span>)</span><br><span class="line">            <span class="built_in">console</span>.log(hexdumpMem(<span class="built_in">this</span>.arg0.add(<span class="number">0x10</span>).readPointer()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后看下输出结果。确定就是在这个里面计算出的结果。我们继续追踪。看看里面的哪个函数计算的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">onenter sub_15DA4</span><br><span class="line">0x77be9b4b18 libnative-lib.so!Java_com_kanxue_algorithmbase_MainActivity_encodeFromJni_171+0x464</span><br><span class="line">0x77bec190cc base.odex!oatexec+0xcc</span><br><span class="line"></span><br><span class="line">             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">77d58a0000  c0 ff 89 d5 77 00 00 00 6e 74 61 4c 54 47 90 8a  ....w...ntaLTG..</span><br><span class="line">77d58a0010  6e 74 61 4c 54 47 90 8a 00 00 00 00 00 00 00 00  ntaLTG..........</span><br><span class="line">77d58a0020  80 d8 89 d5 77 00 00 00 6e 74 61 4c 43 45 90 9a  ....w...ntaLCE..</span><br><span class="line">77d58a0030  6e 74 61 4c 43 45 90 9a 00 00 00 00 00 00 00 00  ntaLCE..........</span><br><span class="line"></span><br><span class="line">onleave sub_15DA4</span><br><span class="line">             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">77bd862d30  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">77bd862d40  10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10  ................</span><br><span class="line">77bd862d50  00 72 69 6e 67 3b 00 00 6e 67 2e 53 74 72 69 00  .ring;..ng.Stri.</span><br><span class="line">77bd862d60  49 6e 63 72 65 61 73 69 6e 67 20 63 6f 64 65 20  Increasing code </span><br></pre></td></tr></table></figure><p>再往里面找。就有很多函数传递这个参数了。我们可以选择优化那个stalker或者是直接用unidbg的内存写入监控来找。我先找到sub_15DA4这个函数的结束位置0x163E8。然后unidbg给这里打个断点。然后查下r0的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lianxi71</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        lianxi71 lianxi = <span class="keyword">new</span> lianxi71();</span><br><span class="line">        lianxi.Call_EncodeFromJni_71();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AndroidEmulator emulator;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> VM vm;</span><br><span class="line">    <span class="keyword">private</span> DvmClass Clazz;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">lianxi71</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        emulator = <span class="keyword">new</span> AndroidARM64Emulator();</span><br><span class="line">        Memory memory = emulator.getMemory();</span><br><span class="line">        LibraryResolver resolver = <span class="keyword">new</span> AndroidResolver(<span class="number">23</span>);</span><br><span class="line">        memory.setLibraryResolver(resolver);</span><br><span class="line">        vm = emulator.createDalvikVM(<span class="keyword">null</span>);</span><br><span class="line">        vm.setVerbose(<span class="keyword">false</span>);</span><br><span class="line">        DalvikModule dm = vm.loadLibrary(<span class="keyword">new</span> File(<span class="string">&quot;unidbg-android/src/test/resources/example_binaries/lianxi71/libnative-lib.so&quot;</span>), <span class="keyword">false</span>);</span><br><span class="line">        dm.callJNI_OnLoad(emulator);</span><br><span class="line">        Clazz = vm.resolveClass(<span class="string">&quot;com/kanxue/algorithmbase/MainActivity&quot;</span>);</span><br><span class="line">        Debugger dbg= emulator.attach();</span><br><span class="line">        dbg.addBreakPoint(<span class="number">0x400163E8</span>);</span><br><span class="line">        dbg.debug();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Call_EncodeFromJni_71</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String res=Clazz.callStaticJniMethodObject(emulator,<span class="string">&quot;encodeFromJni_171(Ljava/lang/String;)Ljava/lang/String;&quot;</span>,<span class="string">&quot;ZUKZKXAJ&quot;</span>).toString();</span><br><span class="line">        System.out.print(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里查到r0的值。然后取0x10字节的指针打印一下。确定是16个0和16个0x10的那段之后。我们就加个内存写入监控</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">emulator.getBackend().hook_add_new(<span class="keyword">new</span> WriteHook() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hook</span><span class="params">(Backend backend, <span class="keyword">long</span> address, <span class="keyword">int</span> size, <span class="keyword">long</span> value, Object user)</span> </span>&#123;</span><br><span class="line">                RegisterContext context = emulator.getContext();</span><br><span class="line">                UnidbgPointer lr = context.getLRPointer();</span><br><span class="line">                UnidbgPointer pc = context.getPCPointer();</span><br><span class="line">                System.out.println(String.format(<span class="string">&quot;write mem address:0x%x value:%x lr=%s pc=%s&quot;</span>,address,value,lr,pc));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">0x403d3060</span>,<span class="number">0x403d3060</span>+<span class="number">0x20</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>然后结果如下。成功找到计算的位置了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">write mem address:0x403d3060 value:0 size:8 lr&#x3D;RX@0x4001a050[libnative-lib.so]0x1a050 pc&#x3D;RX@0x4020b188[libc.so]0x1c188</span><br><span class="line">write mem address:0x403d3068 value:0 size:8 lr&#x3D;RX@0x4001a050[libnative-lib.so]0x1a050 pc&#x3D;RX@0x4020b188[libc.so]0x1c188</span><br><span class="line">write mem address:0x403d3070 value:1010101010101010 size:8 lr&#x3D;RX@0x40016248[libnative-lib.so]0x16248 pc&#x3D;RX@0x4020b640[libc.so]0x1c640</span><br><span class="line">write mem address:0x403d3078 value:1010101010101010 size:8 lr&#x3D;RX@0x40016248[libnative-lib.so]0x16248 pc&#x3D;RX@0x4020b640[libc.so]0x1c640</span><br><span class="line">write mem address:0x403d3070 value:1010101010101010 size:8 lr&#x3D;RX@0x40016248[libnative-lib.so]0x16248 pc&#x3D;RX@0x4020b640[libc.so]0x1c640</span><br><span class="line">write mem address:0x403d3078 value:1010101010101010 size:8 lr&#x3D;RX@0x40016248[libnative-lib.so]0x16248 pc&#x3D;RX@0x4020b640[libc.so]0x1c640</span><br><span class="line">write mem address:0x403d3080 value:0 size:1 lr&#x3D;RX@0x400163a4[libnative-lib.so]0x163a4 pc&#x3D;RX@0x40015e60[libnative-lib.so]0x15e60</span><br><span class="line">write mem address:0x403d3060 value:5916cb6af61493ff size:8 lr&#x3D;RX@0x4004f204[libnative-lib.so]0x4f204 pc&#x3D;RX@0x4004f204[libnative-lib.so]0x4f204</span><br><span class="line">write mem address:0x403d3068 value:99d98913e184665 size:8 lr&#x3D;RX@0x4004f204[libnative-lib.so]0x4f204 pc&#x3D;RX@0x4004f204[libnative-lib.so]0x4f204</span><br><span class="line">write mem address:0x403d3070 value:9230d372e0136077 size:8 lr&#x3D;RX@0x4004f204[libnative-lib.so]0x4f204 pc&#x3D;RX@0x4004f204[libnative-lib.so]0x4f204</span><br><span class="line">write mem address:0x403d3078 value:91d0b1473de14c1d size:8 lr&#x3D;RX@0x4004f204[libnative-lib.so]0x4f204 pc&#x3D;RX@0x4004f204[libnative-lib.so]0x4f204</span><br><span class="line">&quot;FF9314F66ACB16596546183E91989D09776013E072D330921D4CE13D47B1D091&quot;</span><br></pre></td></tr></table></figure><p>这里我们看到写了两次8字节的0和2次8字节的10。很明显这里就是我们想要的了。找到0x1a050。这里是个memcpy。我们需要搞清楚x1和x2是什么值</p><p><img src="/2021/01/27/zuoye8/image-20210127235306220.png" alt="image-20210127235306220"></p><p>我测试调用了多次。发现x1指向的数据始终都是0。那么关键就是x2，决定前面这里写入几个0。锁定x2数据的来源。然后同样对内存进行监控。然后找到写入0x10长度的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write mem address:0xbffff470 value:10 size:8 lr&#x3D;RX@0x400162e8[libnative-lib.so]0x162e8 pc&#x3D;RX@0x40019290[libnative-lib.so]0x19290</span><br></pre></td></tr></table></figure><p>找下下面写入的代码。0x10来自于x4。而x4又是函数的参数。所以必须继续向上找。找到第四个参数是怎么赋值的。一值向上找。最终找到0x10638这里计算出来的。hook一下看看。结果再hook的时候看到一条关键数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">onenter sub_10638</span><br><span class="line">0x77be9b5314 libnative-lib.so!0x16314</span><br><span class="line">0x77be9b6a24 libnative-lib.so!0x17a24</span><br><span class="line">0x77be9b4acc libnative-lib.so!Java_com_kanxue_algorithmbase_MainActivity_encodeFromJni_171+0x418</span><br><span class="line">0x77bec190cc base.odex!oatexec+0xcc</span><br><span class="line"></span><br><span class="line">             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">77d58a6e80  78 9c 8b 0a f5 8e f2 8e 70 f4 02 00 0b af 02 83  x.......p.......</span><br><span class="line">77d58a6e90  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">77d58a6ea0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">77d58a6eb0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line"></span><br><span class="line">0x60f29f24</span><br><span class="line">onleave sub_10638</span><br><span class="line">arg0:              0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">77d58a6e80  78 9c 8b 0a f5 8e f2 8e 70 f4 02 00 0b af 02 83  x.......p.......</span><br><span class="line">77d58a6e90  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">77d58a6ea0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">77d58a6eb0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br></pre></td></tr></table></figure><p>这个数据明显是zlib压缩的。我们测试一下发现这个值就是明文的zlib压缩。那么大胆猜测一下。0x10个0是不是指的是zlib的长度呢。</p><p><img src="/2021/01/27/zuoye8/image-20210128001355525.png" alt="image-20210128001355525"></p><p>修改一下明文。然后查下0的长度是否会发生变化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">input: ZUKZKXAJJ output: FF9314F66ACB16596546183E91989D0985B7861EBCBEC8C1D2FE94B1B1F070FF</span><br><span class="line">aes明文</span><br><span class="line">00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">00 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f</span><br><span class="line">aes密文</span><br><span class="line">ff9314f66acb16596546183e91989d0985b7861ebcbec8c1d2fe94b1b1f070ff  2f2a5a7bee9760cc4ee94111128e6924</span><br><span class="line">0的长度 0x11</span><br><span class="line">明文的zlib</span><br><span class="line">78 9c 8b 0a f5 8e f2 8e 70 f4 f2 02 00 0e 7c 02 cd</span><br><span class="line">zlib的长度 0x11</span><br></pre></td></tr></table></figure><p>如此看来。0的长度确实是和zlib的长度挂钩。但是又有另外一个问题。如果zlib的长度大于0x20会怎么样呢？测试一下看看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">input: ZUKZKXAJJABCDEFGHIJKabcsdd output: FF9314F66ACB16596546183E91989D09D78F7E38D8970BDA322E791AD1718B6C4AE85C0F5817CE451A6F98F26808E29F</span><br><span class="line">aes明文</span><br><span class="line">00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 0e 0e 0e 0e 0e 0e 0e 0e 0e 0e 0e 0e 0e 0e</span><br><span class="line">aes密文</span><br><span class="line">ff9314f66acb16596546183e91989d09d78f7e38d8970bda322e791ad1718b6c4ae85c0f5817ce451a6f98f26808e29f a95ad4f41ff1e4851cbd5df68fe03b64</span><br><span class="line">0的长度0x22</span><br><span class="line">明文的zlib</span><br><span class="line">78 9c 8b 0a f5 8e f2 8e 70 f4 f2 72 74 72 76 71 </span><br><span class="line">75 73 f7 f0 f4 f2 4e 4c 4a 2e 4e 49 01 00 6a 04 </span><br><span class="line">08 30 </span><br><span class="line">zlib的长度0x22</span><br></pre></td></tr></table></figure><p>到这里第一段就出来了。0是固定的。长度是根据明文的zlib计算的。然后后面的部分我们也可以推测出来长度是填充到满16的倍数字节。接下来找怎么得到的0xe的。根据之前找的写入监控的线索。知道是在0x16248这个位置写入的。找到那里的代码。发现调用的是memset。</p><p><img src="/2021/01/27/zuoye8/image-20210128003614078.png" alt="image-20210128003614078"></p><p>然后unidbg断点到那里。看看x0 x1 x2的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x0&#x3D;0x40437022 x1&#x3D;0xe x2&#x3D;0xe</span><br></pre></td></tr></table></figure><p>这就巧合了。后面补充0x10个字节的时候就是0x10。补充0xe个字节的时候。补充的值就是0xe。上面另外一个例子是0xf。也是补充0xf个字节。那么这里就能确定出来这个值是如何算出来的了。</p><p>我们最后最后确定一下。如果是0x20长度的zlib数据。是否会补充到0x30。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">明文:ZUKZKXAJJABCDEFGHIJKabcs</span><br><span class="line">zlib:</span><br><span class="line">78 9c 8b 0a f5 8e f2 8e 70 f4 f2 72 74 72 76 71 </span><br><span class="line">75 73 f7 f0 f4 f2 4e 4c 4a 2e 06 00 5a 08 07 68 </span><br><span class="line">aes加密的数据</span><br><span class="line">77ca663f40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">77ca663f50  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">77ca663f60  10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10  ................</span><br></pre></td></tr></table></figure><p>分析完毕。最后贴上还原代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct,zlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b2hex</span>(<span class="params">bins</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([<span class="string">&quot;%02X&quot;</span> % x <span class="keyword">for</span> x <span class="keyword">in</span> bins]).strip().lower()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zlib_compress</span>(<span class="params">zlib_data</span>):</span></span><br><span class="line">    data = zlib_data.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    outData = zlib.compress(data)</span><br><span class="line">    <span class="keyword">return</span> outData</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pad</span>(<span class="params">s</span>):</span> <span class="keyword">return</span> s + bytes([<span class="number">16</span> - len(s) % <span class="number">16</span>] * (<span class="number">16</span> - len(s) % <span class="number">16</span>))</span><br><span class="line"><span class="comment"># 加密函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cbc_encrypt</span>(<span class="params">key,iv,data</span>):</span></span><br><span class="line">    mode = AES.MODE_CBC</span><br><span class="line">    cryptos = AES.new(key, mode, iv)</span><br><span class="line">    cipher_text = cryptos.encrypt(pad(data))</span><br><span class="line">    <span class="comment"># 因为AES加密后的字符串不一定是ascii字符集的，输出保存可能存在问题，所以这里转为16进制字符串</span></span><br><span class="line">    <span class="keyword">return</span> cipher_text</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_71</span>(<span class="params">inputdata</span>):</span></span><br><span class="line">    zlibdata=zlib_compress(inputdata)</span><br><span class="line">    zliblen=len(zlibdata)</span><br><span class="line">    <span class="comment"># print(&quot;zliblen:%x&quot;%zliblen)</span></span><br><span class="line">    outdata=bytes([<span class="number">0x0</span>]*zliblen)</span><br><span class="line">    <span class="keyword">if</span> zliblen%<span class="number">0x10</span>==<span class="number">0</span>:</span><br><span class="line">        outdata+=bytes([<span class="number">0x10</span>]*<span class="number">0x10</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mo=<span class="number">0x10</span>-zliblen%<span class="number">0x10</span></span><br><span class="line">        mobytes=struct.pack(<span class="string">&quot;B&quot;</span>,mo)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(mo):</span><br><span class="line">            outdata+=mobytes</span><br><span class="line">        <span class="comment"># print(outdata)</span></span><br><span class="line">    key=<span class="string">&quot;kanxue_imyang___&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    iv=<span class="string">&quot;kanxue_imyang___&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    res=cbc_encrypt(key,iv,outdata)</span><br><span class="line">    res=res[<span class="number">0</span>:len(outdata)]</span><br><span class="line">    <span class="keyword">return</span> b2hex(res)</span><br><span class="line"></span><br><span class="line">print(calc_71(<span class="string">&quot;0000&quot;</span>))</span><br><span class="line">print(calc_71(<span class="string">&quot;00000000&quot;</span>))</span><br><span class="line">print(calc_71(<span class="string">&quot;0000000000000000&quot;</span>))</span><br><span class="line">print(calc_71(<span class="string">&quot;00000000000000000000&quot;</span>))</span><br><span class="line">print(calc_71(<span class="string">&quot;00000000000000000000000000000000000000000000&quot;</span>))</span><br><span class="line">print(calc_71(<span class="string">&quot;PPZOJXVYlPosRUmYAEFvDaaGyxfqIqaLKHnE&quot;</span>))</span><br><span class="line">print(calc_71(<span class="string">&quot;ZUKZKXAJ&quot;</span>))</span><br><span class="line">print(calc_71(<span class="string">&quot;ZUKZKXAJJABCDEFGHIJKabcsdd&quot;</span>))</span><br></pre></td></tr></table></figure><p>然后贴上对比结果。和上面的都一致。搞定睡觉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0000: 290be933fc53a33bb5da56800bbce79c</span><br><span class="line">00000000: 5e88221adfe7ac9ec43b51d6547d697b</span><br><span class="line">0000000000000000: 5e88221adfe7ac9ec43b51d6547d697b</span><br><span class="line">00000000000000000000: 5e88221adfe7ac9ec43b51d6547d697b</span><br><span class="line">00000000000000000000000000000000000000000000: 290be933fc53a33bb5da56800bbce79c</span><br><span class="line">PPZOJXVYlPosRUmYAEFvDaaGyxfqIqaLKHnE: ff9314f66acb16596546183e91989d09d78f7e38d8970bda322e791ad1718b6c793c4c09f2b1f01bfc56474603ff6112</span><br><span class="line">ZUKZKXAJ: ff9314f66acb16596546183e91989d09776013e072d330921d4ce13d47b1d091</span><br><span class="line">ZUKZKXAJJABCDEFGHIJKabcsdd: ff9314f66acb16596546183e91989d09d78f7e38d8970bda322e791ad1718b6c4ae85c0f5817ce451a6f98f26808e29f</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法还原实战7</title>
      <link href="/2021/01/25/zuoye7/"/>
      <url>/2021/01/25/zuoye7/</url>
      
        <content type="html"><![CDATA[<p>分析样例下载：链接: <a href="https://pan.baidu.com/s/13iMgWwFattwNS6PmEA16Bg">https://pan.baidu.com/s/13iMgWwFattwNS6PmEA16Bg</a>  密码: avtb</p><p>练习algorithmbase_70.apk</p><p>老样子直接ida打开libnative-lib.so然后frida打印一下输入和输出</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_java</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> native_lib=Java.use(<span class="string">&quot;com.kanxue.algorithmbase.MainActivity&quot;</span>);</span><br><span class="line">        native_lib.encodeFromJni_70.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">input</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> res=<span class="built_in">this</span>.encodeFromJni_70(input);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;input:&quot;</span>,input,<span class="string">&quot;output:&quot;</span>,res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    hook_java();</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></table></figure><p>下面是打印的结果。加密的结果的长度是96。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input: dIQoDwUgEuDPctWyFTlCGoenlVCGJWsQkazyUtgkP output: 4EAE672D1C1F5CDB05A90C4D5AEAA417057BF6D0E0082777EEB83F15DD591F54303BF937B7E5F298266D412BAE430DC0</span><br></pre></td></tr></table></figure><p>然后我们修改一下这个字符串的特征。例如长度修改一下看看加密的结果有什么不同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input: 000000                                     output: 1B0F4D1A2743DAC43AE630208005759B</span><br><span class="line">input: 000000000000                         output: D19C887F85B85FA7718D07ACE365762F</span><br><span class="line">input: 000000000000000000000000 output: 559CFDDC0EFB9178E92DEFAD02ACA99DECB4EB6F7C6A3C2AF24E34BE3615498A</span><br></pre></td></tr></table></figure><p>测试了一下后。发现特征。当长度不超过0x10时。加密结果的长度不会变。当长度超过0x10时。则长度发生变化。这个特征和aes、rc2的特征非常像。我们用aes和rc2的加密随便测试一下看看特征</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#rc2</span><br><span class="line">input: 000000                                        output: 6d31ec02d637b158</span><br><span class="line">input: 000000000000                         output: 28c39f84769cabe1df0cbae8524aba1b</span><br><span class="line">input: 000000000000000000000000 output: 28c39f84769cabe1c82b75ff9fd684274ab4dcbf91c63296c4e12ee98c721fc7</span><br><span class="line">#aes</span><br><span class="line">input: 000000                                        output: a2ddb2109958049280e4b4f1da0ed884</span><br><span class="line">input: 000000000000                         output: e4a62440cf35c675a2afc6c0373c526e</span><br><span class="line">input: 000000000000000000000000 output: 7f81b6fe31ddef2804cd2430b950d124523f6f448be52698c1986b956fd26ea2</span><br></pre></td></tr></table></figure><p>从特征上面看。这个可能是aes加密。这个时候就要继续静态分析找更多的特征来确定是aes。</p><p>先从返回值设置的地方向上找。一路找到sub_177F8函数。然后我们frida来打印下这个函数的参数和返回值。然后发现这个函数最后一次调用的时候。返回值是我们看到的加密结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">onLeave sub_177F8</span><br><span class="line">             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">77be7952e0  35 35 39 43 46 44 44 43 30 45 46 42 39 31 37 38  559CFDDC0EFB9178</span><br><span class="line">77be7952f0  45 39 32 44 45 46 41 44 30 32 41 43 41 39 39 44  E92DEFAD02ACA99D</span><br><span class="line">77be795300  45 43 42 34 45 42 36 46 37 43 36 41 33 43 32 41  ECB4EB6F7C6A3C2A</span><br><span class="line">input: 000000000000000000000000 output: 559CFDDC0EFB9178E92DEFAD02ACA99DECB4EB6F7C6A3C2AF24E34BE3615498A</span><br></pre></td></tr></table></figure><p>然后为了确定是这个函数计算出来的。还是说只是刚好这个时机是有结果的。我们改造一下frida脚本。打印堆栈。并且在入参的指针里面找到同一块内存的位置。在函数进入前就hexdump看下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_native</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> base_addr=Module.getBaseAddress(<span class="string">&quot;libnative-lib.so&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> sub_177F8=base_addr.add(<span class="number">0x177F8</span>);</span><br><span class="line">    Interceptor.attach(sub_177F8,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;onEnter sub_177F8&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.arg0=args[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">console</span>.log(hexdump(<span class="built_in">this</span>.arg0.add(<span class="number">0x10</span>).readPointer(),&#123;<span class="attr">length</span>:<span class="number">0x30</span>&#125;))</span><br><span class="line">            <span class="built_in">console</span>.log(Thread.backtrace(<span class="built_in">this</span>.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join(<span class="string">&#x27;\n&#x27;</span>) + <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125;,<span class="attr">onLeave</span>:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;onLeave sub_177F8&quot;</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(hexdump(ptr(retval),&#123;<span class="attr">length</span>:<span class="number">0x30</span>&#125;))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后打印的结果可以看到。这个函数进入前。结果就已经有值了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">onEnter sub_177F8</span><br><span class="line">             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">77be7952e0  35 35 39 43 46 44 44 43 30 45 46 42 39 31 37 38  559CFDDC0EFB9178</span><br><span class="line">77be7952f0  45 39 32 44 45 46 41 44 30 32 41 43 41 39 39 44  E92DEFAD02ACA99D</span><br><span class="line">77be795300  45 43 42 34 45 42 36 46 37 43 36 41 33 43 32 41  ECB4EB6F7C6A3C2A</span><br><span class="line">0x77bea02098 libnative-lib.so!Java_com_kanxue_algorithmbase_MainActivity_encodeFromJni_170+0x278</span><br><span class="line">0x77bec1e0cc base.odex!oatexec+0xcc</span><br><span class="line"></span><br><span class="line">onLeave sub_177F8</span><br><span class="line">             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">77be7952e0  35 35 39 43 46 44 44 43 30 45 46 42 39 31 37 38  559CFDDC0EFB9178</span><br><span class="line">77be7952f0  45 39 32 44 45 46 41 44 30 32 41 43 41 39 39 44  E92DEFAD02ACA99D</span><br><span class="line">77be795300  45 43 42 34 45 42 36 46 37 43 36 41 33 43 32 41  ECB4EB6F7C6A3C2A</span><br><span class="line">input: 000000000000000000000000 output: 559CFDDC0EFB9178E92DEFAD02ACA99DECB4EB6F7C6A3C2AF24E34BE3615498A</span><br></pre></td></tr></table></figure><p>不过这里同时也看到了调用堆栈。并且也知道了结果值修改估计是通过第一个参数来修改的。因为第一个参数指向的内存里面是有加密结果的指针。所以接着找关于第一个参数v18的使用的地方。接着找到函数sub_12580。继续frida分析一下先。下面贴上frida的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sub_12580=base_addr.add(<span class="number">0x12580</span>);</span><br><span class="line">    Interceptor.attach(sub_12580,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;onEnter sub_12580&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.arg0=args[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">this</span>.arg1=args[<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">console</span>.log(hexdump(<span class="built_in">this</span>.arg0.add(<span class="number">0x10</span>).readPointer(),&#123;<span class="attr">length</span>:<span class="number">0x40</span>&#125;));</span><br><span class="line">        &#125;,<span class="attr">onLeave</span>:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;onLeave sub_12580&quot;</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(hexdump(<span class="built_in">this</span>.arg0.add(<span class="number">0x10</span>).readPointer(),&#123;<span class="attr">length</span>:<span class="number">0x40</span>&#125;));</span><br><span class="line">            <span class="built_in">console</span>.log(hexdump(retval.add(<span class="number">0x10</span>).readPointer(),&#123;<span class="attr">length</span>:<span class="number">0x40</span>&#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>然后输出结果如下。可这里猜测第一个参数可能是一个0x20长度的key。然后返回值是加密结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">onEnter sub_12580</span><br><span class="line">             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">77be3bb740  55 9c fd dc 0e fb 91 78 e9 2d ef ad 02 ac a9 9d  U......x.-......</span><br><span class="line">77be3bb750  ec b4 eb 6f 7c 6a 3c 2a f2 4e 34 be 36 15 49 8a  ...o|j&lt;*.N4.6.I.</span><br><span class="line">77be3bb760  00 6f 6d 55 74 69 6c 73 2e 6e 65 78 74 49 6e 74  .omUtils.nextInt</span><br><span class="line">77be3bb770  28 69 6e 74 2c 20 69 6e 74 29 00 6c 65 28 29 00  (int, int).le().</span><br><span class="line">             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">77be7a6f00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">77be7a6f10  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">77be7a6f20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">77be7a6f30  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">onLeave sub_12580</span><br><span class="line">             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">77be3bb740  55 9c fd dc 0e fb 91 78 e9 2d ef ad 02 ac a9 9d  U......x.-......</span><br><span class="line">77be3bb750  ec b4 eb 6f 7c 6a 3c 2a f2 4e 34 be 36 15 49 8a  ...o|j&lt;*.N4.6.I.</span><br><span class="line">77be3bb760  00 6f 6d 55 74 69 6c 73 2e 6e 65 78 74 49 6e 74  .omUtils.nextInt</span><br><span class="line">77be3bb770  28 69 6e 74 2c 20 69 6e 74 29 00 6c 65 28 29 00  (int, int).le().</span><br><span class="line">             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">77d583f120  35 35 39 43 46 44 44 43 30 45 46 42 39 31 37 38  559CFDDC0EFB9178</span><br><span class="line">77d583f130  45 39 32 44 45 46 41 44 30 32 41 43 41 39 39 44  E92DEFAD02ACA99D</span><br><span class="line">77d583f140  45 43 42 34 45 42 36 46 37 43 36 41 33 43 32 41  ECB4EB6F7C6A3C2A</span><br><span class="line">77d583f150  46 32 34 45 33 34 42 45 33 36 31 35 34 39 38 41  F24E34BE3615498A</span><br><span class="line">input: 000000000000000000000000 output: 559CFDDC0EFB9178E92DEFAD02ACA99DECB4EB6F7C6A3C2AF24E34BE3615498A</span><br></pre></td></tr></table></figure><p>然后继续分析上一个函数sub_57514。这里可能是生成key的地方。先hook分析参数和返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sub_57514=base_addr.add(<span class="number">0x57514</span>);</span><br><span class="line">    Interceptor.attach(sub_57514,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;onEnter sub_57514&quot;</span>);</span><br><span class="line">              hexdumpMem(args[<span class="number">0</span>])</span><br><span class="line">            hexdumpMem(args[<span class="number">1</span>])</span><br><span class="line">            hexdumpMem(args[<span class="number">2</span>])</span><br><span class="line">        &#125;,<span class="attr">onLeave</span>:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;onLeave sub_57514&quot;</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(retval);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>然后贴上结果。看到了另外一串kanxue_imyang___字符串。并且发现我们加密的结果后面填充到了0x20的长度。尾数是08</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">onEnter sub_57514</span><br><span class="line">             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">77bea70080  6b 61 6e 78 75 65 5f 69 6d 79 61 6e 67 5f 5f 5f  kanxue_imyang___</span><br><span class="line">77bea70090  00 00 00 00 00 00 00 00 62 61 73 69 63 5f 73 74  ........basic_st</span><br><span class="line">77bea700a0  72 69 6e 67 00 00 00 00 00 00 00 00 00 00 00 00  ring............</span><br><span class="line">77bea700b0  61 6c 6c 6f 63 61 74 6f 72 3c 54 3e 3a 3a 61 6c  allocator&lt;T&gt;::al</span><br><span class="line">             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">77bea70080  6b 61 6e 78 75 65 5f 69 6d 79 61 6e 67 5f 5f 5f  kanxue_imyang___</span><br><span class="line">77bea70090  00 00 00 00 00 00 00 00 62 61 73 69 63 5f 73 74  ........basic_st</span><br><span class="line">77bea700a0  72 69 6e 67 00 00 00 00 00 00 00 00 00 00 00 00  ring............</span><br><span class="line">77bea700b0  61 6c 6c 6f 63 61 74 6f 72 3c 54 3e 3a 3a 61 6c  allocator&lt;T&gt;::al</span><br><span class="line">             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">77ca65b240  30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30  0000000000000000</span><br><span class="line">77ca65b250  30 30 30 30 30 30 30 30 08 08 08 08 08 08 08 08  00000000........</span><br><span class="line">77ca65b260  00 6f 6d 55 74 69 6c 73 2e 6e 65 78 74 49 6e 74  .omUtils.nextInt</span><br><span class="line">77ca65b270  28 69 6e 74 2c 20 69 6e 74 29 00 6c 65 28 29 00  (int, int).le().</span><br><span class="line">onLeave sub_57514</span><br><span class="line">0x0</span><br><span class="line">input: 000000000000000000000000 output: 559CFDDC0EFB9178E92DEFAD02ACA99DECB4EB6F7C6A3C2AF24E34BE3615498A</span><br></pre></td></tr></table></figure><p>这个函数就很明显像是加密函数了。正好和我们猜测的aes需要的字段相近。参数1应该是key。参数2应该是iv。参数3是输入数据。那么验证一下看看。结果和上面的能对上了。搞定了。</p><p><img src="/2021/01/25/zuoye7/image-20210126224654619.png" alt="image-20210126224654619"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法还原实战练习6</title>
      <link href="/2021/01/19/zuoye6/"/>
      <url>/2021/01/19/zuoye6/</url>
      
        <content type="html"><![CDATA[<p>分析样例下载：链接: <a href="https://pan.baidu.com/s/1Df_8OhozSEE17MIuIigvhg">https://pan.baidu.com/s/1Df_8OhozSEE17MIuIigvhg</a>  密码: 4tgi</p><p>练习algorithmbase_60.apk</p><p>老样子ida打开libnative-lib.so找到encodeFromJni_160。然后看到了有个byte_2F050字符串加密处理了。unidbg跑一下解开看看字符串是什么</p><p><img src="/2021/01/19/zuoye6/image-20210119215422863.png" alt="image-20210119215422863"></p><p>然后打开这个使用了加密字符串的函数。发现里面是ollvm混淆过了的</p><p>这里我先静态分析一下。把每个函数打开大致的浏览下里面的内容。然后发现了两个比较特殊的函数sub_121DC和sub_C29C。这两个函数里面直接就有疑似算法部分的代码。特别是sub_C29C函数中直接看到了有base64的特征。</p><p><img src="/2021/01/19/zuoye6/image-20210119222948239.png" alt="image-20210119222948239"></p><p>接下来静态分析一下sub_121DC的参数。发现第一个参数应该是一个大小为258字节的数据。可能是用来加密的表。</p><a id="more"></a><p><img src="/2021/01/19/zuoye6/image-20210119224123191.png" alt="image-20210119224123191"></p><p>然后frida来hook一下。观察参数的意义。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_native</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> base_addr=Module.getBaseAddress(<span class="string">&quot;libnative-lib.so&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> sub_121DC=base_addr.add(<span class="number">0x121DC</span>+<span class="number">1</span>);</span><br><span class="line">    Interceptor.attach(sub_121DC,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;onEnter sub_121DC&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.args2=args[<span class="number">2</span>]</span><br><span class="line">            <span class="built_in">console</span>.log(hexdump(args[<span class="number">0</span>],&#123;<span class="attr">length</span>:<span class="number">258</span>&#125;));</span><br><span class="line">            <span class="built_in">console</span>.log(args[<span class="number">1</span>].readCString());</span><br><span class="line">            <span class="built_in">this</span>.args3=args[<span class="number">3</span>];</span><br><span class="line">        &#125;,<span class="attr">onLeave</span>:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;onLeave sub_121DC&quot;</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(hexdump(<span class="built_in">this</span>.args2,&#123;<span class="attr">length</span>:<span class="built_in">this</span>.args3.toInt32()&#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">var</span> sub_C29C=base_addr.add(<span class="number">0xC29C</span>+<span class="number">1</span>);</span><br><span class="line">    Interceptor.attach(sub_C29C,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;onEnter sub_C29C&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.arg0=args[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">console</span>.log(hexdump(args[<span class="number">1</span>],&#123;<span class="attr">length</span>:args[<span class="number">2</span>].toInt32()&#125;));</span><br><span class="line">            <span class="built_in">console</span>.log(args[<span class="number">2</span>]);</span><br><span class="line">        &#125;,<span class="attr">onLeave</span>:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;onLeave sub_C29C&quot;</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(retval);</span><br><span class="line">            <span class="built_in">console</span>.log(hexdump(<span class="built_in">this</span>.arg0,&#123;<span class="attr">length</span>:<span class="number">0x30</span>&#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据下面的输出结果。可以确定</p><p>sub_121DC参数1是258字节的表。参数2是输入参数。参数3是输出参数。参数4是长度</p><p>sub_C29C参数1是输出，也就是最后加密的结果。参数2是sub_121DC最后的输出结果（就是sub_121DC执行完后的参数2）。参数3是参数2的长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> onEnter sub_121DC</span><br><span class="line">           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">ff87d218  ee a4 3d 85 31 ce 6b 76 90 67 d2 7e be 8f 6a b2  ..&#x3D;.1.kv.g.~..j.</span><br><span class="line">ff87d228  28 16 c5 c4 2e a8 1d 9d 2d 21 27 b0 11 15 fb 0b  (.......-!&#39;.....</span><br><span class="line">ff87d238  d6 26 36 79 1a 38 58 aa 47 44 49 c2 4d e1 05 18  .&amp;6y.8X.GDI.M...</span><br><span class="line">ff87d248  f4 2f 14 0c e9 cd 56 2c db 8d b3 d1 f9 60 eb df  .&#x2F;....V,.....&#96;..</span><br><span class="line">ff87d258  ab 9b b5 c7 0d d3 78 e3 45 99 63 01 5f c0 af 6c  ......x.E.c._..l</span><br><span class="line">ff87d268  3f 12 75 ac f0 e4 59 4e 84 37 9a 19 17 8a 7b 6e  ?.u...YN.7....&#123;n</span><br><span class="line">ff87d278  3b 68 cf 87 d5 f7 ef 8c dc 07 7a 7c 5d bc 72 c1  ;h........z|].r.</span><br><span class="line">ff87d288  0f d4 51 00 e8 2b 97 77 65 13 a1 04 94 1f a6 5b  ..Q..+.we......[</span><br><span class="line">ff87d298  82 98 b9 83 b6 b8 ca 91 4b 62 e0 f6 f2 c3 3e 2a  ........Kb....&gt;*</span><br><span class="line">ff87d2a8  e5 ec 40 96 f1 46 bf 6f 73 95 29 bb e6 ba 70 d7  ..@..F.os.)...p.</span><br><span class="line">ff87d2b8  5e 1b 7d 86 b7 c6 4c 55 5a 33 53 4a 25 cc d8 8b  ^.&#125;...LUZ3SJ%...</span><br><span class="line">ff87d2c8  dd 66 ad b4 c8 61 10 35 ea 89 93 1c a9 20 92 cb  .f...a.5..... ..</span><br><span class="line">ff87d2d8  8e 42 e7 d9 1e 54 a5 a2 c9 da f8 71 34 f3 57 88  .B...T.....q4.W.</span><br><span class="line">ff87d2e8  23 64 a3 a7 9f 48 6d fa 43 e2 de 30 ff ed 4f 03  #d...Hm.C..0..O.</span><br><span class="line">ff87d2f8  39 22 b1 fc 81 50 80 08 ae 09 5c 02 0e a0 06 bd  9&quot;...P....\.....</span><br><span class="line">ff87d308  24 52 f5 69 9c 7f 41 fe 3c 74 0a fd 3a d0 32 9e  $R.i..A.&lt;t..:.2.</span><br><span class="line">ff87d318  00 00                                            ..</span><br><span class="line">dtYeKUzFKTZnVLYSNZxSbrE</span><br><span class="line">onLeave sub_121DC</span><br><span class="line">           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">d6bd5e80  7d 1a b1 3b 1f 6b 7c 96 e9 e2 c1 a5 ea 3b e4 97  &#125;..;.k|......;..</span><br><span class="line">d6bd5e90  6d da 1e 01 75 92 e2                             m...u..</span><br><span class="line">onEnter sub_C29C</span><br><span class="line">           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">d6bd5e80  7d 1a b1 3b 1f 6b 7c 96 e9 e2 c1 a5 ea 3b e4 97  &#125;..;.k|......;..</span><br><span class="line">d6bd5e90  6d da 1e 01 75 92 e2                             m...u..</span><br><span class="line">0x17</span><br><span class="line">onLeave sub_C29C</span><br><span class="line">0x21</span><br><span class="line">           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">e53beac0  74 7c 75 3c 68 3c 78 61 74 65 42 74 4f 60 33 50  t|u&lt;h&lt;xateBtO&#96;3P</span><br><span class="line">e53bead0  51 20 4e 2f 47 79 6f 7a 49 42 32 4f 2f 75 5d 3d  Q N&#x2F;GyozIB2O&#x2F;u]&#x3D;</span><br><span class="line">e53beae0  00 00 76 69 74 79 3b 00 6e 63 65 00 29 00 01 00  ..vity;.nce.)...</span><br></pre></td></tr></table></figure><p>有了以上的一些记录。我们就可以锁定这两个就是关键加密函数了。接下来我们看看sub_121DC的结果是怎么计算出来的。这里由于是ollvm的。不方便静态分析。所以我直接用unidbg来模拟执行。并且trace这个函数的代码。看看是如何计算的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lianxi60</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        lianxi60 lianxi = <span class="keyword">new</span> lianxi60();</span><br><span class="line">        lianxi.Call_EncodeFromJni_60();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AndroidEmulator emulator;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> VM vm;</span><br><span class="line">    <span class="keyword">private</span> DvmClass Clazz;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">lianxi60</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        emulator = <span class="keyword">new</span> AndroidARMEmulator();</span><br><span class="line">        Memory memory = emulator.getMemory();</span><br><span class="line">        LibraryResolver resolver = <span class="keyword">new</span> AndroidResolver(<span class="number">23</span>);</span><br><span class="line">        memory.setLibraryResolver(resolver);</span><br><span class="line">        vm = emulator.createDalvikVM(<span class="keyword">null</span>);</span><br><span class="line">        vm.setVerbose(<span class="keyword">false</span>);</span><br><span class="line">        DalvikModule dm = vm.loadLibrary(<span class="keyword">new</span> File(<span class="string">&quot;unidbg-android/src/test/resources/example_binaries/lianxi60/libnative-lib.so&quot;</span>), <span class="keyword">false</span>);</span><br><span class="line">        dm.callJNI_OnLoad(emulator);</span><br><span class="line">        Clazz = vm.resolveClass(<span class="string">&quot;com/kanxue/algorithmbase/MainActivity&quot;</span>);</span><br><span class="line">        KingTrace trace=<span class="keyword">new</span> KingTrace(emulator);</span><br><span class="line">        <span class="keyword">long</span> start=<span class="number">0x400121DC</span>;     </span><br><span class="line">        <span class="keyword">long</span> end=<span class="number">0x40012326</span>;</span><br><span class="line">        trace.initialize(start,end,<span class="keyword">null</span>);</span><br><span class="line">        emulator.getBackend().hook_add_new(trace,start,end,emulator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Call_EncodeFromJni_60</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String res=Clazz.callStaticJniMethodObject(emulator,<span class="string">&quot;encodeFromJni_160(Ljava/lang/String;)Ljava/lang/String;&quot;</span>,<span class="string">&quot;dtYeKUzFKTZnVLYSNZxSbrE&quot;</span>).toString();</span><br><span class="line">        System.out.print(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行成功后。得到了完整的汇编执行的记录。然后我们分别搜索0x7d 0x1a 0xb1。发现结果都是在0x122a0这行计算出来的。然后我们直接搜索0x122a0。然后就看到了这个函数计算的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&quot;[libnative-lib.so] [0x122a0] [       18 43 ] 0x400122a0: orrs r0, r3-----r0&#x3D;0x64    r3&#x3D;0x19        &#x2F;&#x2F;r0&#x3D;0x7d&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x122a0] [       18 43 ] 0x400122a0: orrs r0, r3-----r0&#x3D;0x10    r3&#x3D;0xa        &#x2F;&#x2F;r0&#x3D;0x1a&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x122a0] [       18 43 ] 0x400122a0: orrs r0, r3-----r0&#x3D;0x11    r3&#x3D;0xa0        &#x2F;&#x2F;r0&#x3D;0xb1&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x122a0] [       18 43 ] 0x400122a0: orrs r0, r3-----r0&#x3D;0x21    r3&#x3D;0x1a        &#x2F;&#x2F;r0&#x3D;0x3b&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x122a0] [       18 43 ] 0x400122a0: orrs r0, r3-----r0&#x3D;0xb    r3&#x3D;0x14        &#x2F;&#x2F;r0&#x3D;0x1f&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x122a0] [       18 43 ] 0x400122a0: orrs r0, r3-----r0&#x3D;0x41    r3&#x3D;0x2a        &#x2F;&#x2F;r0&#x3D;0x6b&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x122a0] [       18 43 ] 0x400122a0: orrs r0, r3-----r0&#x3D;0x78    r3&#x3D;0x4        &#x2F;&#x2F;r0&#x3D;0x7c&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x122a0] [       18 43 ] 0x400122a0: orrs r0, r3-----r0&#x3D;0x6    r3&#x3D;0x90        &#x2F;&#x2F;r0&#x3D;0x96&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x122a0] [       18 43 ] 0x400122a0: orrs r0, r3-----r0&#x3D;0x49    r3&#x3D;0xa0        &#x2F;&#x2F;r0&#x3D;0xe9&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x122a0] [       18 43 ] 0x400122a0: orrs r0, r3-----r0&#x3D;0x40    r3&#x3D;0xa2        &#x2F;&#x2F;r0&#x3D;0xe2&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x122a0] [       18 43 ] 0x400122a0: orrs r0, r3-----r0&#x3D;0x40    r3&#x3D;0x81        &#x2F;&#x2F;r0&#x3D;0xc1&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x122a0] [       18 43 ] 0x400122a0: orrs r0, r3-----r0&#x3D;0x24    r3&#x3D;0x81        &#x2F;&#x2F;r0&#x3D;0xa5&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x122a0] [       18 43 ] 0x400122a0: orrs r0, r3-----r0&#x3D;0x42    r3&#x3D;0xa8        &#x2F;&#x2F;r0&#x3D;0xea&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x122a0] [       18 43 ] 0x400122a0: orrs r0, r3-----r0&#x3D;0x8    r3&#x3D;0x33        &#x2F;&#x2F;r0&#x3D;0x3b&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x122a0] [       18 43 ] 0x400122a0: orrs r0, r3-----r0&#x3D;0x40    r3&#x3D;0xa4        &#x2F;&#x2F;r0&#x3D;0xe4&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x122a0] [       18 43 ] 0x400122a0: orrs r0, r3-----r0&#x3D;0x13    r3&#x3D;0x84        &#x2F;&#x2F;r0&#x3D;0x97&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x122a0] [       18 43 ] 0x400122a0: orrs r0, r3-----r0&#x3D;0x4c    r3&#x3D;0x21        &#x2F;&#x2F;r0&#x3D;0x6d&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x122a0] [       18 43 ] 0x400122a0: orrs r0, r3-----r0&#x3D;0x5a    r3&#x3D;0x80        &#x2F;&#x2F;r0&#x3D;0xda&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x122a0] [       18 43 ] 0x400122a0: orrs r0, r3-----r0&#x3D;0x18    r3&#x3D;0x6        &#x2F;&#x2F;r0&#x3D;0x1e&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x122a0] [       18 43 ] 0x400122a0: orrs r0, r3-----r0&#x3D;0x1    r3&#x3D;0x0        &#x2F;&#x2F;r0&#x3D;0x1&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x122a0] [       18 43 ] 0x400122a0: orrs r0, r3-----r0&#x3D;0x60    r3&#x3D;0x15        &#x2F;&#x2F;r0&#x3D;0x75&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x122a0] [       18 43 ] 0x400122a0: orrs r0, r3-----r0&#x3D;0x12    r3&#x3D;0x80        &#x2F;&#x2F;r0&#x3D;0x92&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x122a0] [       18 43 ] 0x400122a0: orrs r0, r3-----r0&#x3D;0x40    r3&#x3D;0xa2        &#x2F;&#x2F;r0&#x3D;0xe2&quot;</span><br></pre></td></tr></table></figure><p>然后开始分析第一个7d的计算汇编。下面列出相关的日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xa4                        ;debug 0xbffff771[0]&#x3D;0xa4</span><br><span class="line">0x4001227c: ldrb r0, [r1, r0]-----r0&#x3D;0x1    r1&#x3D;0xbffff670    r0&#x3D;0x1        &#x2F;&#x2F;r0&#x3D;0xb7            ;debug 0xbffff670[0x1]&#x3D;0xb7</span><br><span class="line">0x40012284: ldrb r1, [r2, r1]-----r1&#x3D;0xa4    r2&#x3D;0xbffff670    r1&#x3D;0xa4        &#x2F;&#x2F;r1&#x3D;0xa4            ;debug 0xbffff670[0xa4]&#x3D;0xa4</span><br><span class="line">0x4001228a: add r0, r1-----r0&#x3D;0xb7    r1&#x3D;0xa4        &#x2F;&#x2F;r0&#x3D;0x15b                                                ;debug 0xb7+0xa4&#x3D;0x15b</span><br><span class="line">0x4001228e: uxtb r0, r0-----r0&#x3D;0x15b    r0&#x3D;0x15b        &#x2F;&#x2F;r0&#x3D;0x5b                                            ;debug 0x15b&amp;0xff&#x3D;0x5b</span><br><span class="line">0x4001228c: ldrb r2, [r3, r2]-----r2&#x3D;0x0    r3&#x3D;0x40212000    r2&#x3D;0x0        &#x2F;&#x2F;r2&#x3D;0x64            ;debug 0x40212000[0x0]&#x3D;0x64   input src</span><br><span class="line">0x40012292: ldrb r0, [r3, r0]-----r0&#x3D;0x5b    r3&#x3D;0xbffff670    r0&#x3D;0x5b        &#x2F;&#x2F;r0&#x3D;0x19            ;debug 0xbffff670[0x5b]&#x3D;0x19</span><br><span class="line">0x40012296: bic.w r3, r0, r2-----r3&#x3D;0xbffff670    r0&#x3D;0x19    r2&#x3D;0x64        &#x2F;&#x2F;r3&#x3D;0x19            ;debug 0x19 &amp;~ 0x64 &#x3D; 0x19</span><br><span class="line">0x4001229a: bic.w r0, r2, r0-----r0&#x3D;0x19    r2&#x3D;0x64    r0&#x3D;0x19        &#x2F;&#x2F;r0&#x3D;0x64                        ;debug 0x64 &amp;~ 0x19 &#x3D; 0x64</span><br><span class="line">0x400122a0: orrs r0, r3-----r0&#x3D;0x64    r3&#x3D;0x19        &#x2F;&#x2F;r0&#x3D;0x7d                                                    ;debug 0x64|0x19&#x3D;0x7d</span><br></pre></td></tr></table></figure><p>这里的重点就是ldrb取到的数据到底是什么数据。首先我们断点在0x121dd的位置。也就是函数的入口位置。</p><p><img src="/2021/01/19/zuoye6/image-20210123224352059.png" alt="image-20210123224352059"></p><p>然后看0xbffff670实际上就是函数的参数1。而0x40212000是函数的参数2。根据我们上面frida查到的。参数1就是258大小的一个字节数组。而参数2就是输入参数。因此我们可以根据trace的记录。来查一下和前面打印的字节数组是否对的上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">前面frida获取到的字节数组如下</span><br><span class="line">           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">ff87d218  ee a4 3d 85 31 ce 6b 76 90 67 d2 7e be 8f 6a b2  ..&#x3D;.1.kv.g.~..j.</span><br><span class="line">ff87d228  28 16 c5 c4 2e a8 1d 9d 2d 21 27 b0 11 15 fb 0b  (.......-!&#39;.....</span><br><span class="line">ff87d238  d6 26 36 79 1a 38 58 aa 47 44 49 c2 4d e1 05 18  .&amp;6y.8X.GDI.M...</span><br><span class="line">ff87d248  f4 2f 14 0c e9 cd 56 2c db 8d b3 d1 f9 60 eb df  .&#x2F;....V,.....&#96;..</span><br><span class="line">ff87d258  ab 9b b5 c7 0d d3 78 e3 45 99 63 01 5f c0 af 6c  ......x.E.c._..l</span><br><span class="line">ff87d268  3f 12 75 ac f0 e4 59 4e 84 37 9a 19 17 8a 7b 6e  ?.u...YN.7....&#123;n</span><br><span class="line">ff87d278  3b 68 cf 87 d5 f7 ef 8c dc 07 7a 7c 5d bc 72 c1  ;h........z|].r.</span><br><span class="line">ff87d288  0f d4 51 00 e8 2b 97 77 65 13 a1 04 94 1f a6 5b  ..Q..+.we......[</span><br><span class="line">ff87d298  82 98 b9 83 b6 b8 ca 91 4b 62 e0 f6 f2 c3 3e 2a  ........Kb....&gt;*</span><br><span class="line">ff87d2a8  e5 ec 40 96 f1 46 bf 6f 73 95 29 bb e6 ba 70 d7  ..@..F.os.)...p.</span><br><span class="line">ff87d2b8  5e 1b 7d 86 b7 c6 4c 55 5a 33 53 4a 25 cc d8 8b  ^.&#125;...LUZ3SJ%...</span><br><span class="line">ff87d2c8  dd 66 ad b4 c8 61 10 35 ea 89 93 1c a9 20 92 cb  .f...a.5..... ..</span><br><span class="line">ff87d2d8  8e 42 e7 d9 1e 54 a5 a2 c9 da f8 71 34 f3 57 88  .B...T.....q4.W.</span><br><span class="line">ff87d2e8  23 64 a3 a7 9f 48 6d fa 43 e2 de 30 ff ed 4f 03  #d...Hm.C..0..O.</span><br><span class="line">ff87d2f8  39 22 b1 fc 81 50 80 08 ae 09 5c 02 0e a0 06 bd  9&quot;...P....\.....</span><br><span class="line">ff87d308  24 52 f5 69 9c 7f 41 fe 3c 74 0a fd 3a d0 32 9e  $R.i..A.&lt;t..:.2.</span><br><span class="line">ff87d318  00 00                                            ..</span><br><span class="line"></span><br><span class="line">0x4001227c: ldrb r0, [r1, r0]-----r0&#x3D;0x1    r1&#x3D;0xbffff670    r0&#x3D;0x1        &#x2F;&#x2F;r0&#x3D;0xb7            ;debug 0xbffff670[0x1]&#x3D;0xb7</span><br><span class="line">0x40012284: ldrb r1, [r2, r1]-----r1&#x3D;0xa4    r2&#x3D;0xbffff670    r1&#x3D;0xa4        &#x2F;&#x2F;r1&#x3D;0xa4            ;debug 0xbffff670[0xa4]&#x3D;0xa4</span><br><span class="line">然后找上面数组对应的0x1和0xa4位置的数据</span><br><span class="line">0xbffff670[0x1]&#x3D;0xa4</span><br><span class="line">0xbffff670[0xa4]&#x3D;0xb7</span><br></pre></td></tr></table></figure><p>结果发现两个都对不上。但是按上面的逻辑来说。读取的确实是这个内存的数据。那么真相只有一个。那就是这段内存数据在函数开始时确实是这样的。但是执行到达这里进行计算前。将这段内存的数据进行了修改。所以和我们开始看到的内存数据不同了。然后为了拿到完整的被修改过的这个字节数据。我在函数最后结束的地方打一个断点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Debugger dbg= emulator.attach();</span><br><span class="line">dbg.addBreakPoint(<span class="number">0x40012326</span>);</span><br><span class="line">dbg.debug();</span><br></pre></td></tr></table></figure><p>然后输入m0xbffff670 258 将这块内存打印出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[libnative-lib.so] [0x12322] [ bd e8 00 0f ] 0x40012322: pop.w &#123;r8, sb, sl, fp&#125;-----r8&#x3D;0x3077af8a        &#x2F;&#x2F;r8&#x3D;0xfffe0a50</span><br><span class="line">debugger break at: 0x40012326</span><br><span class="line">&gt;&gt;&gt; r0&#x3D;0x713d41d5 r1&#x3D;0x55db7bae r2&#x3D;0xd822dfc5 r3&#x3D;0xfe9855a1 r4&#x3D;0xad19d0c2 r5&#x3D;0x55db7bae r6&#x3D;0x882e73ec r7&#x3D;0xbffff640 r8&#x3D;0xfffe0a50 sb&#x3D;0x40149ec0 sl&#x3D;0x0 fp&#x3D;0x0 ip&#x3D;0x20 SP&#x3D;0xbffff634 LR&#x3D;RX@0x40012277[libnative-lib.so]0x12277 PC&#x3D;RX@0x40012326[libnative-lib.so]0x12326 cpsr: N&#x3D;0, Z&#x3D;1, C&#x3D;1, V&#x3D;0, T&#x3D;1, mode&#x3D;0b10000</span><br><span class="line">&#x3D;&gt; *[libnative-lib.so]*[0x12327]*[*      f0 bd ]*0x40012326:*pop &#123;r4, r5, r6, r7, pc&#125;</span><br><span class="line">    [libnative-lib.so] [0x12329] [       a1 55 ] 0x40012328: strb r1, [r4, r6]</span><br><span class="line">    [libnative-lib.so] [0x1232b] [ 98 fe ec 73 ] 0x4001232a: cdp2 p3, #9, c7, c8, c12, #7</span><br><span class="line">    [libnative-lib.so] [0x1232f] [       2e 88 ] 0x4001232e: ldrh r6, [r5]</span><br><span class="line">    [libnative-lib.so] [0x12331] [       c2 d0 ] 0x40012330: beq #0x400122b8</span><br><span class="line">    [libnative-lib.so] [0x12333] [       19 ad ] 0x40012332: add r5, sp, #0x64</span><br><span class="line">    [libnative-lib.so] [0x12335] [       c5 df ] 0x40012334: svc #0xc5</span><br><span class="line">    [libnative-lib.so] [0x12337] [       22 d8 ] 0x40012336: bhi #0x4001237e</span><br><span class="line">    [libnative-lib.so] [0x12339] [       8a af ] 0x40012338: add r7, sp, #0x228</span><br><span class="line">    [libnative-lib.so] [0x1233b] [       77 30 ] 0x4001233a: adds r0, #0x77</span><br><span class="line">    [libnative-lib.so] [0x1233d] [       ba 25 ] 0x4001233c: movs r5, #0xba</span><br><span class="line">    [libnative-lib.so] [0x1233f] [       2a 62 ] 0x4001233e: str r2, [r5, #0x20]</span><br><span class="line">    [libnative-lib.so] [0x12341] [       5d 53 ] 0x40012340: strh r5, [r3, r5]</span><br><span class="line">    [libnative-lib.so] [0x12343] [       37 65 ] 0x40012342: str r7, [r6, #0x50]</span><br><span class="line">    [libnative-lib.so] [0x12345] [       d5 41 ] 0x40012344: rors r5, r2</span><br><span class="line">    [libnative-lib.so] [0x12347] [       3d 71 ] 0x40012346: strb r5, [r7, #4]</span><br><span class="line"></span><br><span class="line">m0xbffff670 258</span><br><span class="line"></span><br><span class="line">&gt;-----------------------------------------------------------------------------&lt;</span><br><span class="line">[23:05:14 396]unidbg@0xbffff670, md5&#x3D;44e110548f78d20dc6f2df3b306e45a3, hex&#x3D;eeb722ef6ff723786d60b22efbde0d1deb1521edc5b4b80b6cc3d1023af00136a0269d791a3858aa474449c24de10518f42f140ce9cd562cdb8db327f96728dfab9bb5c76ad376e3459963be5fc0af2d3f1275ac16e4594e84379a19178a7b6e3b68cf87d5ce858cdc077a7c5dbc72c10fd45100e82b97776513a104941fa65b8298b983b6d2ca914b62e0f6f27e3e2ae5ec4096f146bf31739529bbe6ba70d75e1b7d86a4c64c555a33534a25ccd88bdd66ada8c8611035ea89931ca92092cb8e42e7d91e54a5a2c9daf87134f357886b64a3a79f4890fa43e28f30ffc44f03393db1fc81508008ae095cb00ed606bd2452f5699c7f41fe3c740afd11d0329e20ed</span><br><span class="line">size: 258</span><br><span class="line">0000: EE B7 22 EF 6F F7 23 78 6D 60 B2 2E FB DE 0D 1D    ..&quot;.o.#xm&#96;......</span><br><span class="line">0010: EB 15 21 ED C5 B4 B8 0B 6C C3 D1 02 3A F0 01 36    ..!.....l...:..6</span><br><span class="line">0020: A0 26 9D 79 1A 38 58 AA 47 44 49 C2 4D E1 05 18    .&amp;.y.8X.GDI.M...</span><br><span class="line">0030: F4 2F 14 0C E9 CD 56 2C DB 8D B3 27 F9 67 28 DF    .&#x2F;....V,...&#39;.g(.</span><br><span class="line">0040: AB 9B B5 C7 6A D3 76 E3 45 99 63 BE 5F C0 AF 2D    ....j.v.E.c._..-</span><br><span class="line">0050: 3F 12 75 AC 16 E4 59 4E 84 37 9A 19 17 8A 7B 6E    ?.u...YN.7....&#123;n</span><br><span class="line">0060: 3B 68 CF 87 D5 CE 85 8C DC 07 7A 7C 5D BC 72 C1    ;h........z|].r.</span><br><span class="line">0070: 0F D4 51 00 E8 2B 97 77 65 13 A1 04 94 1F A6 5B    ..Q..+.we......[</span><br><span class="line">0080: 82 98 B9 83 B6 D2 CA 91 4B 62 E0 F6 F2 7E 3E 2A    ........Kb...~&gt;*</span><br><span class="line">0090: E5 EC 40 96 F1 46 BF 31 73 95 29 BB E6 BA 70 D7    ..@..F.1s.)...p.</span><br><span class="line">00A0: 5E 1B 7D 86 A4 C6 4C 55 5A 33 53 4A 25 CC D8 8B    ^.&#125;...LUZ3SJ%...</span><br><span class="line">00B0: DD 66 AD A8 C8 61 10 35 EA 89 93 1C A9 20 92 CB    .f...a.5..... ..</span><br><span class="line">00C0: 8E 42 E7 D9 1E 54 A5 A2 C9 DA F8 71 34 F3 57 88    .B...T.....q4.W.</span><br><span class="line">00D0: 6B 64 A3 A7 9F 48 90 FA 43 E2 8F 30 FF C4 4F 03    kd...H..C..0..O.</span><br><span class="line">00E0: 39 3D B1 FC 81 50 80 08 AE 09 5C B0 0E D6 06 BD    9&#x3D;...P....\.....</span><br><span class="line">00F0: 24 52 F5 69 9C 7F 41 FE 3C 74 0A FD 11 D0 32 9E    $R.i..A.&lt;t....2.</span><br><span class="line">0100: 20 ED                                               .</span><br><span class="line">^-----------------------------------------------------------------------------^</span><br></pre></td></tr></table></figure><p>这里我们再拿trace的记录对比。就发现能对的上了。现在这块内存就是算法计算时所使用的数据了。但是我们得搞清楚这个table是怎么计算变化的。先查看另外一个ldr的数据来源。然后看看他们之间是否有点什么关联</p><p>另一个内存0xbffff771。我们搜索一下使用到的位置是0x40012280。搜索一下这行的代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xa4&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xe1&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x66&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x97&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x65&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xd0&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x46&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xd6&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x3d&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xf&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x8d&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x4b&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xda&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x44&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x16&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x3e&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x54&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x19&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xdd&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xb&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xb3&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x85&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x22&quot;</span><br></pre></td></tr></table></figure><p>然后发现这个数据每次都是从同一个位置读取的。这里我注意到了这个数据的长度似乎和input的长度一致。不知道input变动这里是否会改变。我们尝试输入两个32位的input来对比下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Call_EncodeFromJni_60</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String res=Clazz.callStaticJniMethodObject(emulator,<span class="string">&quot;encodeFromJni_160(Ljava/lang/String;)Ljava/lang/String;&quot;</span>,<span class="string">&quot;1234567890abcdefghgklmnoqrstuvwx&quot;</span>).toString();</span><br><span class="line">        System.out.print(res);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对应的0xbffff771数据如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xa4&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xe1&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x66&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x97&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x65&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xd0&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x46&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xd6&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x3d&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xf&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x8d&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x4b&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xda&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x44&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x16&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x3e&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x54&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x19&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xdd&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xb&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xb3&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x85&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x22&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x4f&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x14&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x3b&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xeb&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xfc&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x11&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xc&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x17&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xed&quot;</span><br></pre></td></tr></table></figure><p>然后再修改一下输入参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Call_EncodeFromJni_60</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String res=Clazz.callStaticJniMethodObject(emulator,<span class="string">&quot;encodeFromJni_160(Ljava/lang/String;)Ljava/lang/String;&quot;</span>,<span class="string">&quot;9876543210gqrstuklmnovwxabfghcde&quot;</span>).toString();</span><br><span class="line">        System.out.print(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应内存的输出结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xa4&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xe1&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x66&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x97&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x65&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xd0&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x46&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xd6&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x3d&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xf&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x8d&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x4b&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xda&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x44&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x16&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x3e&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x54&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x19&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xdd&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xb&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xb3&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x85&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x22&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x4f&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x14&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x3b&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xeb&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xfc&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x11&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xc&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0x17&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x12280] [       09 78 ] 0x40012280: ldrb r1, [r1]-----r1&#x3D;0xbffff771    r1&#x3D;0xbffff771        &#x2F;&#x2F;r1&#x3D;0xed&quot;</span><br></pre></td></tr></table></figure><p>那么这里可以看出来这串数据也是固定的。那么这个数据是否和第一个参数有什么关联呢。我们下面贴上原始的258字节的参数1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0000: EE A4 3D 85 31 CE 6B 76 90 67 D2 7E BE 8F 6A B2    ..&#x3D;.1.kv.g.~..j.</span><br><span class="line">0010: 28 16 C5 C4 2E A8 1D 9D 2D 21 27 B0 11 15 FB 0B    (.......-!&#39;.....</span><br><span class="line">0020: D6 26 36 79 1A 38 58 AA 47 44 49 C2 4D E1 05 18    .&amp;6y.8X.GDI.M...</span><br><span class="line">0030: F4 2F 14 0C E9 CD 56 2C DB 8D B3 D1 F9 60 EB DF    .&#x2F;....V,.....&#96;..</span><br><span class="line">0040: AB 9B B5 C7 0D D3 78 E3 45 99 63 01 5F C0 AF 6C    ......x.E.c._..l</span><br><span class="line">0050: 3F 12 75 AC F0 E4 59 4E 84 37 9A 19 17 8A 7B 6E    ?.u...YN.7....&#123;n</span><br><span class="line">0060: 3B 68 CF 87 D5 F7 EF 8C DC 07 7A 7C 5D BC 72 C1    ;h........z|].r.</span><br><span class="line">0070: 0F D4 51 00 E8 2B 97 77 65 13 A1 04 94 1F A6 5B    ..Q..+.we......[</span><br><span class="line">0080: 82 98 B9 83 B6 B8 CA 91 4B 62 E0 F6 F2 C3 3E 2A    ........Kb....&gt;*</span><br><span class="line">0090: E5 EC 40 96 F1 46 BF 6F 73 95 29 BB E6 BA 70 D7    ..@..F.os.)...p.</span><br><span class="line">00A0: 5E 1B 7D 86 B7 C6 4C 55 5A 33 53 4A 25 CC D8 8B    ^.&#125;...LUZ3SJ%...</span><br><span class="line">00B0: DD 66 AD B4 C8 61 10 35 EA 89 93 1C A9 20 92 CB    .f...a.5..... ..</span><br><span class="line">00C0: 8E 42 E7 D9 1E 54 A5 A2 C9 DA F8 71 34 F3 57 88    .B...T.....q4.W.</span><br><span class="line">00D0: 23 64 A3 A7 9F 48 6D FA 43 E2 DE 30 FF ED 4F 03    #d...Hm.C..0..O.</span><br><span class="line">00E0: 39 22 B1 FC 81 50 80 08 AE 09 5C 02 0E A0 06 BD    9&quot;...P....\.....</span><br><span class="line">00F0: 24 52 F5 69 9C 7F 41 FE 3C 74 0A FD 3A D0 32 9E    $R.i..A.&lt;t..:.2.</span><br></pre></td></tr></table></figure><p>然后继续列出第二个固定的计算数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a4 e1 66 97 65 d0 46 d6 3d 0f 8d 4b da 44 16 3e 54 19 dd 0b b3 85 22 4f 14 3b eb fc 11 0c 17 ed</span><br></pre></td></tr></table></figure><p>接着我们列出trace里面每次从内存里面取到的两个数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&quot;[libnative-lib.so] [0x1228a] [       08 44 ] 0x4001228a: add r0, r1-----r0&#x3D;0xb7    r1&#x3D;0xa4        &#x2F;&#x2F;r0&#x3D;0x15b&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1228a] [       08 44 ] 0x4001228a: add r0, r1-----r0&#x3D;0x22    r1&#x3D;0x3d        &#x2F;&#x2F;r0&#x3D;0x5f&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1228a] [       08 44 ] 0x4001228a: add r0, r1-----r0&#x3D;0xef    r1&#x3D;0x85        &#x2F;&#x2F;r0&#x3D;0x174&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1228a] [       08 44 ] 0x4001228a: add r0, r1-----r0&#x3D;0x6f    r1&#x3D;0x31        &#x2F;&#x2F;r0&#x3D;0xa0&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1228a] [       08 44 ] 0x4001228a: add r0, r1-----r0&#x3D;0xf7    r1&#x3D;0xce        &#x2F;&#x2F;r0&#x3D;0x1c5&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1228a] [       08 44 ] 0x4001228a: add r0, r1-----r0&#x3D;0x23    r1&#x3D;0x6b        &#x2F;&#x2F;r0&#x3D;0x8e&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1228a] [       08 44 ] 0x4001228a: add r0, r1-----r0&#x3D;0x78    r1&#x3D;0x76        &#x2F;&#x2F;r0&#x3D;0xee&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1228a] [       08 44 ] 0x4001228a: add r0, r1-----r0&#x3D;0x6d    r1&#x3D;0x90        &#x2F;&#x2F;r0&#x3D;0xfd&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1228a] [       08 44 ] 0x4001228a: add r0, r1-----r0&#x3D;0x60    r1&#x3D;0x67        &#x2F;&#x2F;r0&#x3D;0xc7&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1228a] [       08 44 ] 0x4001228a: add r0, r1-----r0&#x3D;0xb2    r1&#x3D;0xd2        &#x2F;&#x2F;r0&#x3D;0x184&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1228a] [       08 44 ] 0x4001228a: add r0, r1-----r0&#x3D;0xc3    r1&#x3D;0x7e        &#x2F;&#x2F;r0&#x3D;0x141&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1228a] [       08 44 ] 0x4001228a: add r0, r1-----r0&#x3D;0x1    r1&#x3D;0xbe        &#x2F;&#x2F;r0&#x3D;0xbf&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1228a] [       08 44 ] 0x4001228a: add r0, r1-----r0&#x3D;0xde    r1&#x3D;0x8f        &#x2F;&#x2F;r0&#x3D;0x16d&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1228a] [       08 44 ] 0x4001228a: add r0, r1-----r0&#x3D;0xd    r1&#x3D;0x6a        &#x2F;&#x2F;r0&#x3D;0x77&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1228a] [       08 44 ] 0x4001228a: add r0, r1-----r0&#x3D;0x1d    r1&#x3D;0xd2        &#x2F;&#x2F;r0&#x3D;0xef&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1228a] [       08 44 ] 0x4001228a: add r0, r1-----r0&#x3D;0xeb    r1&#x3D;0x28        &#x2F;&#x2F;r0&#x3D;0x113&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1228a] [       08 44 ] 0x4001228a: add r0, r1-----r0&#x3D;0xf0    r1&#x3D;0x16        &#x2F;&#x2F;r0&#x3D;0x106&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1228a] [       08 44 ] 0x4001228a: add r0, r1-----r0&#x3D;0x21    r1&#x3D;0xc5        &#x2F;&#x2F;r0&#x3D;0xe6&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1228a] [       08 44 ] 0x4001228a: add r0, r1-----r0&#x3D;0xed    r1&#x3D;0xc4        &#x2F;&#x2F;r0&#x3D;0x1b1&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1228a] [       08 44 ] 0x4001228a: add r0, r1-----r0&#x3D;0xc3    r1&#x3D;0x2e        &#x2F;&#x2F;r0&#x3D;0xf1&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1228a] [       08 44 ] 0x4001228a: add r0, r1-----r0&#x3D;0xb4    r1&#x3D;0xa8        &#x2F;&#x2F;r0&#x3D;0x15c&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1228a] [       08 44 ] 0x4001228a: add r0, r1-----r0&#x3D;0xb8    r1&#x3D;0xd2        &#x2F;&#x2F;r0&#x3D;0x18a&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1228a] [       08 44 ] 0x4001228a: add r0, r1-----r0&#x3D;0x36    r1&#x3D;0x9d        &#x2F;&#x2F;r0&#x3D;0xd3&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>似乎看起来没有什么关联。然后我们看下每次相加的两个值是否都在那个table里面。并且他们的索引是多少。我简单整理几个看一下有没什么关联</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data:0xb7 idx:0xa4        data:0xa4 idx:0x1</span><br><span class="line">data:0x22 idx:0xe1        data:0x3d idx:0x2</span><br><span class="line">data:0xef idx:0x66        data:0x85    idx:0x3</span><br><span class="line">data:0x6f idx:0x97        data:0x31 idx:0x4</span><br></pre></td></tr></table></figure><p>那这就相当巧了。因为我们在两个idx中都看到了熟悉的东西。第一个idx是我们那个固定字节数组。第二个idx直接就是索引。如此我们就知道了这个table是怎么变化的了。每次迭代进行计算的时候。先把固定key的数据和当前计算的下一个索引的值进行交换。然后以此类推。下面贴上py的还原代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re,struct</span><br><span class="line"></span><br><span class="line">tbkeyStr=<span class="string">&quot;&quot;&quot;ee a4 3d 85 31 ce 6b 76 90 67 d2 7e be 8f 6a b2 28 16 c5 c4 2e a8 1d 9d 2d 21 27 b0 11 15 fb 0b d6 26 36 79 1a 38 58 aa 47 44 49 c2 4d e1 05 18 f4 2f 14 0c e9 cd 56 2c db 8d b3 d1 f9 60 eb df ab 9b b5 c7 0d d3 78 e3 45 99 63 01 5f c0 af 6c 3f 12 75 ac f0 e4 59 4e 84 37 9a 19 17 8a 7b 6e 3b 68 cf 87 d5 f7 ef 8c dc 07 7a 7c 5d bc 72 c1 0f d4 51 00 e8 2b 97 77 65 13 a1 04 94 1f a6 5b 82 98 b9 83 b6 b8 ca 91 4b 62 e0 f6 f2 c3 3e 2a e5 ec 40 96 f1 46 bf 6f 73 95 29 bb e6 ba 70 d7 5e 1b 7d 86 b7 c6 4c 55 5a 33 53 4a 25 cc d8 8b dd 66 ad b4 c8 61 10 35 ea 89 93 1c a9 20 92 cb 8e 42 e7 d9 1e 54 a5 a2 c9 da f8 71 34 f3 57 88 23 64 a3 a7 9f 48 6d fa 43 e2 de 30 ff ed 4f 03 39 22 b1 fc 81 50 80 08 ae 09 5c 02 0e a0 06 bd 24 52 f5 69 9c 7f 41 fe 3c 74 0a fd 3a d0 32 9e&quot;&quot;&quot;</span></span><br><span class="line">tb2keyStr=<span class="string">&quot;&quot;&quot;a4 e1 66 97 65 d0 46 d6 3d 0f 8d 4b da 44 16 3e 54 19 dd 0b b3 85 22 4f 14 3b eb fc 11 0c 17 ed&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b2hex</span>(<span class="params">bins</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join([<span class="string">&quot;%02X&quot;</span> % x <span class="keyword">for</span> x <span class="keyword">in</span> bins]).strip()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">StrToHexSplit</span>(<span class="params">str</span>):</span></span><br><span class="line">    buf = bytes(<span class="number">0</span>)</span><br><span class="line">    lines = re.split (<span class="string">r&#x27;[\r\n ]&#x27;</span>,str)</span><br><span class="line">    <span class="keyword">for</span> code <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">if</span> len (code) &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        num = int (code,<span class="number">16</span>)</span><br><span class="line">        bnum = struct.pack (<span class="string">&#x27;B&#x27;</span>,num)</span><br><span class="line">        buf += bnum</span><br><span class="line">    <span class="keyword">return</span> buf</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_data</span>(<span class="params">input</span>):</span></span><br><span class="line">    tbkey = bytearray(StrToHexSplit(tbkeyStr))</span><br><span class="line">    tb2key = bytearray(StrToHexSplit(tb2keyStr))</span><br><span class="line">    res=bytes(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(input)):</span><br><span class="line">        tb2value=tb2key[i]</span><br><span class="line">        tmp=tbkey[i+<span class="number">1</span>]</span><br><span class="line">        tbkey[i+<span class="number">1</span>]=tbkey[tb2key[i]]</span><br><span class="line">        tbkey[tb2key[i]]=tmp</span><br><span class="line">        tbvalue1 = tbkey[i + <span class="number">1</span>]</span><br><span class="line">        tbvalue2=tbkey[tb2value]</span><br><span class="line">        tbvalue=tbvalue1+tbvalue2</span><br><span class="line">        tbvalue=tbvalue&amp;<span class="number">0xff</span></span><br><span class="line">        chdata=ord(input[i])</span><br><span class="line">        tbres=tbkey[tbvalue]</span><br><span class="line">        cdata=(tbres&amp;~chdata)|(chdata&amp;~tbres)</span><br><span class="line">        res+=struct.pack(<span class="string">&quot;B&quot;</span>,cdata)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    res=calc_data(<span class="string">&quot;dtYeKUzFKTZnVLYSNZxSbrE&quot;</span>)</span><br><span class="line">    print(b2hex(res))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结算的结果如下。和我们之前frida抓到的第一个加密函数的结果对的上了。接下来就开始处理第二个加密函数。有点像base64的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7D 1A B1 3B 1F 6B 7C 96 E9 E2 C1 A5 EA 3B E4 97 6D DA 1E 01 75 92 E2</span><br></pre></td></tr></table></figure><p>我们再回头看看加密的明文和结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input: TjHWtazVgwyqzLAuIoPtjuYvsyjCi output: t|u&lt;h&lt;xateBtO&#96;3PQ N&#x2F;GyozIB2O&#x2F;u]&#x3D;</span><br></pre></td></tr></table></figure><p>首先我们能够直接确定肯定不是标准的base64的结果。因为标准的是不会有那些特殊字符的。那么base64的table必然经过修改了。用ida打开看一下</p><p><img src="/2021/01/19/zuoye6/image-20210124192319165.png" alt="image-20210124192319165"></p><p>ida中显示的这个table也和结果不符。因为结果中有|和]这两个特殊字符。所以这个table必然是经过动态修改了的。那么我们用ida翻一下。看看是否有什么地方直接对这个数据进行修改的。</p><p><img src="/2021/01/19/zuoye6/image-20210124192746077.png" alt="image-20210124192746077"></p><p>找到修改的位置之后。然后我们需要查一下这里赋值的到底是什么。那么先看下汇编的表示</p><p><img src="/2021/01/19/zuoye6/image-20210124192907313.png" alt="image-20210124192907313"></p><p>我们需要hook到0xc1b4行。打印一下r0和r1的值是多少。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sub_C1B4=base_addr.add(<span class="number">0xC1B4</span>+<span class="number">1</span>);</span><br><span class="line">    Interceptor.attach(sub_C1B4,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.context.r0,<span class="built_in">this</span>.context.r1)</span><br><span class="line">        &#125;,<span class="attr">onLeave</span>:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>然后看到打印结果如下。r1固定是0x17。而这个0x17刚刚好是我们输入参数的长度。</p><p>r0转换成ascii码就是我们之前看到的AYZpq23IJrTFfghijklCDE1KLMmBdestU5678GHz0cuvwabN9+/VWXnoOPQRSxy4</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">0x41 0x17</span><br><span class="line">0x59 0x17</span><br><span class="line">0x5a 0x17</span><br><span class="line">0x70 0x17</span><br><span class="line">0x71 0x17</span><br><span class="line">0x32 0x17</span><br><span class="line">0x33 0x17</span><br><span class="line">0x49 0x17</span><br><span class="line">0x4a 0x17</span><br><span class="line">0x72 0x17</span><br><span class="line">0x54 0x17</span><br><span class="line">0x46 0x17</span><br><span class="line">0x66 0x17</span><br><span class="line">0x67 0x17</span><br><span class="line">0x68 0x17</span><br><span class="line">0x69 0x17</span><br><span class="line">0x6a 0x17</span><br><span class="line">0x6b 0x17</span><br><span class="line">0x6c 0x17</span><br><span class="line">0x43 0x17</span><br><span class="line">0x44 0x17</span><br><span class="line">0x45 0x17</span><br><span class="line">0x31 0x17</span><br><span class="line">0x4b 0x17</span><br><span class="line">0x4c 0x17</span><br><span class="line">0x4d 0x17</span><br><span class="line">0x6d 0x17</span><br><span class="line">0x42 0x17</span><br><span class="line">0x64 0x17</span><br><span class="line">0x65 0x17</span><br><span class="line">0x73 0x17</span><br><span class="line">0x74 0x17</span><br><span class="line">0x55 0x17</span><br><span class="line">0x35 0x17</span><br><span class="line">0x36 0x17</span><br><span class="line">0x37 0x17</span><br><span class="line">0x38 0x17</span><br><span class="line">0x47 0x17</span><br><span class="line">0x48 0x17</span><br><span class="line">0x7a 0x17</span><br><span class="line">0x30 0x17</span><br><span class="line">0x63 0x17</span><br><span class="line">0x75 0x17</span><br><span class="line">0x76 0x17</span><br><span class="line">0x77 0x17</span><br><span class="line">0x61 0x17</span><br><span class="line">0x62 0x17</span><br><span class="line">0x4e 0x17</span><br><span class="line">0x39 0x17</span><br><span class="line">0x2b 0x17</span><br><span class="line">0x2f 0x17</span><br><span class="line">0x56 0x17</span><br><span class="line">0x57 0x17</span><br><span class="line">0x58 0x17</span><br><span class="line">0x6e 0x17</span><br><span class="line">0x6f 0x17</span><br><span class="line">0x4f 0x17</span><br><span class="line">0x50 0x17</span><br><span class="line">0x51 0x17</span><br><span class="line">0x52 0x17</span><br><span class="line">0x53 0x17</span><br><span class="line">0x78 0x17</span><br><span class="line">0x79 0x17</span><br><span class="line">0x34 0x17</span><br></pre></td></tr></table></figure><p>那么知道了这个table怎么变化之后。我们开始实现一下py的版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re,struct</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getKey</span>(<span class="params">cnt</span>):</span></span><br><span class="line">    bkey = <span class="string">&quot;AYZpq23IJrTFfghijklCDE1KLMmBdestU5678GHz0cuvwabN9+/VWXnoOPQRSxy4&quot;</span></span><br><span class="line">    bkey_bytes=bytes(bkey,<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    res=bytearray()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(bkey)):</span><br><span class="line">        res.append((bkey_bytes[i] &amp;~ cnt)|(cnt &amp;~ bkey_bytes[i]))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">base64Encode</span>(<span class="params">bkey,input</span>):</span></span><br><span class="line">    cnt=len(input)</span><br><span class="line">    cntpre=cnt<span class="number">-2</span></span><br><span class="line">    cnt1=cnt</span><br><span class="line">    output=bytes(<span class="number">0</span>)</span><br><span class="line">    input_bytes=input</span><br><span class="line">    v6=<span class="number">0</span></span><br><span class="line">    v7=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> v7 &gt;= cntpre:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        v9 = v7</span><br><span class="line">        v6 += <span class="number">4</span></span><br><span class="line">        output+=struct.pack(<span class="string">&quot;B&quot;</span>,bkey[input_bytes[v7] &gt;&gt; <span class="number">2</span>])</span><br><span class="line">        v28_0 = (cnt &amp; ~v6) | (v6 &amp; ~ cnt)</span><br><span class="line">        output += struct.pack(<span class="string">&quot;B&quot;</span>, v28_0)</span><br><span class="line"></span><br><span class="line">        v10=input_bytes[v7+<span class="number">1</span>]</span><br><span class="line">        v11=input_bytes[v7]</span><br><span class="line">        v7+=<span class="number">3</span></span><br><span class="line">        output +=struct.pack(<span class="string">&quot;B&quot;</span>,bkey[(v10 &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xFFFFFFCF</span> | <span class="number">16</span> * (v11 &amp; <span class="number">3</span>)])</span><br><span class="line">        output +=struct.pack(<span class="string">&quot;B&quot;</span>,bkey[((input_bytes[v9 + <span class="number">2</span>] &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0xFFFFFFC3</span>) | (<span class="number">4</span> * (input_bytes[v9 + <span class="number">1</span>] &amp; <span class="number">0xF</span>))])</span><br><span class="line">        output +=struct.pack(<span class="string">&quot;B&quot;</span>,bkey[(input_bytes[v9 + <span class="number">2</span>])&amp;<span class="number">0x3f</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> v7 &lt; cnt1 :</span><br><span class="line">        output +=struct.pack(<span class="string">&quot;B&quot;</span>,bkey[input_bytes[v7] &gt;&gt; <span class="number">2</span>])</span><br><span class="line">        v12 = <span class="number">16</span> * input_bytes[v7] &amp; <span class="number">0x30</span></span><br><span class="line">        <span class="keyword">if</span> cnt1 - <span class="number">1</span> == v7:</span><br><span class="line">            v13 = <span class="string">&#x27;=&#x27;</span></span><br><span class="line">            output+=bkey[v12]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            output+=struct.pack(<span class="string">&quot;B&quot;</span>,bkey[v12 | (input_bytes[v7+<span class="number">1</span>] &gt;&gt; <span class="number">4</span>)])</span><br><span class="line">            v13=struct.pack(<span class="string">&quot;B&quot;</span>,bkey[<span class="number">4</span> * (input_bytes[v7+<span class="number">1</span>] &amp; <span class="number">0xF</span>)])</span><br><span class="line">        output+=bytes([<span class="number">0x3d</span>])</span><br><span class="line">        output+=v13</span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">StrToHexSplit</span>(<span class="params">str</span>):</span></span><br><span class="line">    buf = bytes(<span class="number">0</span>)</span><br><span class="line">    lines = re.split (<span class="string">r&#x27;[\r\n ]&#x27;</span>,str)</span><br><span class="line">    <span class="keyword">for</span> code <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">if</span> len (code) &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        num = int (code,<span class="number">16</span>)</span><br><span class="line">        bnum = struct.pack (<span class="string">&#x27;B&#x27;</span>,num)</span><br><span class="line">        buf += bnum</span><br><span class="line">    <span class="keyword">return</span> buf</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b2hex</span>(<span class="params">bins</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join([<span class="string">&quot;%02X&quot;</span> % x <span class="keyword">for</span> x <span class="keyword">in</span> bins]).strip()</span><br><span class="line"></span><br><span class="line">input=<span class="string">&quot;&quot;&quot;7D 1A B1 3B 1F 6B 7C 96 E9 E2 C1 A5 EA 3B E4 97 6D DA 1E 01 75 92 E2&quot;&quot;&quot;</span></span><br><span class="line">input_bytes=StrToHexSplit(input)</span><br><span class="line">bkey=getKey(len(input_bytes))</span><br><span class="line">print(<span class="string">&quot;bkey:&quot;</span>,b2hex(bkey))</span><br><span class="line">res=base64Encode(bkey,input_bytes)</span><br><span class="line">print(<span class="string">&quot;res:&quot;</span>,b2hex(res))</span><br></pre></td></tr></table></figure><p>然后py的输出结果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bkey: 56 4E 4D 67 66 25 24 5E 5D 65 43 51 71 70 7F 7E 7D 7C 7B 54 53 52 26 5C 5B 5A 7A 55 73 72 64 63 42 22 21 20 2F 50 5F 6D 27 74 62 61 60 76 75 59 2E 3C 38 41 40 4F 79 78 58 47 46 45 44 6F 6E 23</span><br><span class="line">res: 63 13 7C 62 3C 7F 1F 3C 6F 61 63 1B 65 55 74 58 07 60 24 50 46 03 20 59 2F 50 0F 79 78 7A 5E 0B 42 25 4F 2F 75 3D 5D</span><br></pre></td></tr></table></figure><p>先验证一下key生成的是否正确。用frida取一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addr_key=base_addr.add(<span class="number">0x2F0B4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(hexdump(addr_key,&#123;<span class="attr">length</span>:<span class="number">64</span>&#125;))</span><br></pre></td></tr></table></figure><p>结果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">d6c7a0b4  56 4e 4d 67 66 25 24 5e 5d 65 43 51 71 70 7f 7e  VNMgf%$^]eCQqp.~</span><br><span class="line">d6c7a0c4  7d 7c 7b 54 53 52 26 5c 5b 5a 7a 55 73 72 64 63  &#125;|&#123;TSR&amp;\[ZzUsrdc</span><br><span class="line">d6c7a0d4  42 22 21 20 2f 50 5f 6d 27 74 62 61 60 76 75 59  B&quot;! &#x2F;P_m&#39;tba&#96;vuY</span><br><span class="line">d6c7a0e4  2e 3c 38 41 40 4f 79 78 58 47 46 45 44 6f 6e 23  .&lt;8A@OyxXGFEDon#</span><br></pre></td></tr></table></figure><p>这里就知道key是计算正确的了。然后看看加密结果是否和之前对的上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#py计算的</span><br><span class="line">63 13 7C 62 3C 7F 1F 3C 6F 61 63 1B 65 55 74 58 07 60 24 50 46 03 20 59 2F 50 0F 79 78 7A 5E 0B 42 25 4F 2F 75 3D 5D</span><br><span class="line">#frida的结果转成16进制的</span><br><span class="line">t|u&lt;h&lt;xateBtO&#96;3PQ N&#x2F;GyozIB2O&#x2F;u]&#x3D;</span><br><span class="line">74 7C 75 3C 68 3C 78 61 74 65 42 74 4F 60 33 50 51 20 4E 2F 47 79 6F 7A 49 42 32 4F 2F 75 5D 3D</span><br></pre></td></tr></table></figure><p>明显和我们看到的结果不一致。说明可能不单单是table修改了。可能连base64算法都修改了。先找到之前看到的base64算法处。把关键的几行代码贴在下面</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v6 = aAyzpq23ijrtffg[((v14 &gt;&gt; <span class="number">2</span>) ^ <span class="number">0x3FFFFFC0</span>) &amp; (v14 &gt;&gt; <span class="number">2</span>)];</span><br><span class="line">                                *v28 = a3 &amp; ~v6 | v6 &amp; ~(_BYTE)a3;</span><br><span class="line">                                v15 = v28 + <span class="number">2</span>;</span><br><span class="line">                                v28[<span class="number">1</span>] = aAyzpq23ijrtffg[(<span class="keyword">unsigned</span> __int8)((<span class="number">16</span> * *v13 ^ <span class="number">0xC0</span>) &amp; <span class="number">16</span> * *v13 | (*(_BYTE *)(a2 + v29 + <span class="number">1</span>) &gt;&gt; <span class="number">4</span>))];</span><br><span class="line">                                v16 = (_BYTE *)(v29 + <span class="number">2</span> + a2);</span><br><span class="line">                                v17 = (((~(<span class="number">4</span> * *(<span class="keyword">unsigned</span> __int8 *)(a2 + v29 + <span class="number">1</span>)) | <span class="number">0xFFFFFFC3</span>) &amp; <span class="number">0xFFFFFFF6</span>)</span><br><span class="line">                                     + (~(~(<span class="number">4</span> * *(<span class="keyword">unsigned</span> __int8 *)(a2 + v29 + <span class="number">1</span>)) | <span class="number">0xFFFFFFC3</span>) &amp; <span class="number">8</span>)) ^ ((((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="keyword">unsigned</span> __int8)*v16 &gt;&gt; <span class="number">6</span>) &amp; <span class="number">1</span>) + (~((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="keyword">unsigned</span> __int8)*v16 &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0xFFFFFFF6</span>)</span><br></pre></td></tr></table></figure><p>然后我们找个base64的标准的算法看一下是什么样子的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*v4 = aAbcdefghijklmn[v6 &gt;&gt; <span class="number">2</span>];</span><br><span class="line">      v4[<span class="number">1</span>] = aAbcdefghijklmn[<span class="number">16</span> * (<span class="keyword">unsigned</span> <span class="keyword">int</span>)*v5 &amp; <span class="number">0x30</span>LL | ((<span class="keyword">unsigned</span> __int64)v5[<span class="number">1</span>] &gt;&gt; <span class="number">4</span>)];</span><br><span class="line">      v4[<span class="number">2</span>] = aAbcdefghijklmn[<span class="number">4</span> * (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v5[<span class="number">1</span>] &amp; <span class="number">0x3C</span>LL | ((<span class="keyword">unsigned</span> __int64)v5[<span class="number">2</span>] &gt;&gt; <span class="number">6</span>)];</span><br><span class="line">      LOBYTE(v6) = aAbcdefghijklmn[v5[<span class="number">2</span>] &amp; <span class="number">0x3F</span>];</span><br></pre></td></tr></table></figure><p>然后再看看我们的py代码的关键计算处</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">output+=struct.pack(<span class="string">&quot;B&quot;</span>,bkey[input_bytes[v7] &gt;&gt; <span class="number">2</span>])</span><br><span class="line">v10=input_bytes[v7+<span class="number">1</span>]</span><br><span class="line">v11=input_bytes[v7]</span><br><span class="line">v7+=<span class="number">3</span></span><br><span class="line">output +=struct.pack(<span class="string">&quot;B&quot;</span>,bkey[(v10 &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xFFFFFFCF</span> | <span class="number">16</span> * (v11 &amp; <span class="number">3</span>)])</span><br><span class="line">output +=struct.pack(<span class="string">&quot;B&quot;</span>,bkey[((input_bytes[v9 + <span class="number">2</span>] &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0xFFFFFFC3</span>) | (<span class="number">4</span> * (input_bytes[v9 + <span class="number">1</span>] &amp; <span class="number">0xF</span>))])</span><br><span class="line">output +=struct.pack(<span class="string">&quot;B&quot;</span>,bkey[(input_bytes[v9 + <span class="number">2</span>])&amp;<span class="number">0x3f</span>])</span><br></pre></td></tr></table></figure><p>那就看出来了。总共是有4个字节要赋值。那么根据这个特征。我们能看到那个v28就是主要用来存放4个字节计算的。那么我们先整理一下v28的赋值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">v6 = aAyzpq23ijrtffg[((v14 &gt;&gt; <span class="number">2</span>) ^ <span class="number">0x3FFFFFC0</span>) &amp; (v14 &gt;&gt; <span class="number">2</span>)];</span><br><span class="line">*v28 = a3 &amp; ~v6 | v6 &amp; ~(_BYTE)a3;</span><br><span class="line">v28[<span class="number">1</span>] = aAyzpq23ijrtffg[(<span class="keyword">unsigned</span> __int8)((<span class="number">16</span> * *v13 ^ <span class="number">0xC0</span>) &amp; <span class="number">16</span> * *v13 | (*(_BYTE *)(a2 + v29 + <span class="number">1</span>) &gt;&gt; <span class="number">4</span>))];</span><br><span class="line">v15 = v28 + <span class="number">2</span>;</span><br><span class="line">v18 = v15 + <span class="number">1</span>;</span><br><span class="line">v17 = (((~(<span class="number">4</span> * *(<span class="keyword">unsigned</span> __int8 *)(a2 + v29 + <span class="number">1</span>)) | <span class="number">0xFFFFFFC3</span>) &amp; <span class="number">0xFFFFFFF6</span>)</span><br><span class="line">                                     + (~(~(<span class="number">4</span> * *(<span class="keyword">unsigned</span> __int8 *)(a2 + v29 + <span class="number">1</span>)) | <span class="number">0xFFFFFFC3</span>) &amp; <span class="number">8</span>)) ^ ((((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="keyword">unsigned</span> __int8)*v16 &gt;&gt; <span class="number">6</span>) &amp; <span class="number">1</span>) + (~((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="keyword">unsigned</span> __int8)*v16 &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0xFFFFFFF6</span>));</span><br><span class="line">*v15 = a3 &amp; ~aAyzpq23ijrtffg[v17] | aAyzpq23ijrtffg[v17] &amp; ~(_BYTE)a3;</span><br><span class="line">*v18 = aAyzpq23ijrtffg[v19];</span><br></pre></td></tr></table></figure><p>然后第一个字节我们对应的修改成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># output+=struct.pack(&quot;B&quot;,bkey[input_bytes[v7] &gt;&gt; 2])       第一个字节生成规则修改了                     </span></span><br><span class="line">v6 = bkey[((input_bytes[v7] &gt;&gt; <span class="number">2</span>) ^ <span class="number">0x3FFFFFC0</span>) &amp; (input_bytes[v7] &gt;&gt; <span class="number">2</span>)]                                              </span><br><span class="line">v28_0 = (cnt &amp; ~v6) | (v6 &amp; ~ cnt)                                                                                     </span><br><span class="line">output += struct.pack(<span class="string">&quot;B&quot;</span>, v28_0)                                                                                      </span><br><span class="line">                                                                                                                       </span><br><span class="line">v10=input_bytes[v7+<span class="number">1</span>]                                                                                                  </span><br><span class="line">v11=input_bytes[v7]                                                                                                    </span><br><span class="line">v7+=<span class="number">3</span>                                                                                                                  </span><br><span class="line"><span class="comment"># output +=struct.pack(&quot;B&quot;,bkey[(v10 &gt;&gt; 4) &amp; 0xFFFFFFCF | 16 * (v11 &amp; 3)])      第二个字节生成规则修改了</span></span><br><span class="line">output +=struct.pack(<span class="string">&quot;B&quot;</span>,bkey[ ((<span class="number">16</span> * v11 ^ <span class="number">0xC0</span>) &amp; <span class="number">16</span> * v11 | (v10 &gt;&gt; <span class="number">4</span>))&amp;<span class="number">0xff</span>])                                      </span><br><span class="line"><span class="comment"># output +=struct.pack(&quot;B&quot;,bkey[((input_bytes[v9 + 2] &gt;&gt; 6) &amp; 0xFFFFFFC3) | (4 * (input_bytes[v9 + 1] &amp; 0xF))])  第三个规则也修改</span></span><br><span class="line">v17= ((input_bytes[v9 + <span class="number">2</span>] &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0xFFFFFFC3</span>) | (<span class="number">4</span> * (input_bytes[v9 + <span class="number">1</span>] &amp; <span class="number">0xF</span>))                                     </span><br><span class="line">output +=struct.pack(<span class="string">&quot;B&quot;</span>,(cnt &amp;~ bkey[v17])|(bkey[v17] &amp;~ cnt))                                                        </span><br><span class="line">output +=struct.pack(<span class="string">&quot;B&quot;</span>,bkey[(input_bytes[v9 + <span class="number">2</span>])&amp;<span class="number">0x3f</span>])                                                             </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>依照c++的代码把每个计算部分都修改完成后。下面贴上完整的py代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re,struct</span><br><span class="line"></span><br><span class="line">tbkeyStr=<span class="string">&quot;&quot;&quot;ee a4 3d 85 31 ce 6b 76 90 67 d2 7e be 8f 6a b2 28 16 c5 c4 2e a8 1d 9d 2d 21 27 b0 11 15 fb 0b d6 26 36 79 1a 38 58 aa 47 44 49 c2 4d e1 05 18 f4 2f 14 0c e9 cd 56 2c db 8d b3 d1 f9 60 eb df ab 9b b5 c7 0d d3 78 e3 45 99 63 01 5f c0 af 6c 3f 12 75 ac f0 e4 59 4e 84 37 9a 19 17 8a 7b 6e 3b 68 cf 87 d5 f7 ef 8c dc 07 7a 7c 5d bc 72 c1 0f d4 51 00 e8 2b 97 77 65 13 a1 04 94 1f a6 5b 82 98 b9 83 b6 b8 ca 91 4b 62 e0 f6 f2 c3 3e 2a e5 ec 40 96 f1 46 bf 6f 73 95 29 bb e6 ba 70 d7 5e 1b 7d 86 b7 c6 4c 55 5a 33 53 4a 25 cc d8 8b dd 66 ad b4 c8 61 10 35 ea 89 93 1c a9 20 92 cb 8e 42 e7 d9 1e 54 a5 a2 c9 da f8 71 34 f3 57 88 23 64 a3 a7 9f 48 6d fa 43 e2 de 30 ff ed 4f 03 39 22 b1 fc 81 50 80 08 ae 09 5c 02 0e a0 06 bd 24 52 f5 69 9c 7f 41 fe 3c 74 0a fd 3a d0 32 9e&quot;&quot;&quot;</span></span><br><span class="line">tb2keyStr=<span class="string">&quot;&quot;&quot;a4 e1 66 97 65 d0 46 d6 3d 0f 8d 4b da 44 16 3e 54 19 dd 0b b3 85 22 4f 14 3b eb fc 11 0c 17 ed&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b2hex</span>(<span class="params">bins</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join([<span class="string">&quot;%02X&quot;</span> % x <span class="keyword">for</span> x <span class="keyword">in</span> bins]).strip()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">StrToHexSplit</span>(<span class="params">str</span>):</span></span><br><span class="line">    buf = bytes(<span class="number">0</span>)</span><br><span class="line">    lines = re.split (<span class="string">r&#x27;[\r\n ]&#x27;</span>,str)</span><br><span class="line">    <span class="keyword">for</span> code <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">if</span> len (code) &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        num = int (code,<span class="number">16</span>)</span><br><span class="line">        bnum = struct.pack (<span class="string">&#x27;B&#x27;</span>,num)</span><br><span class="line">        buf += bnum</span><br><span class="line">    <span class="keyword">return</span> buf</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改key</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getKey</span>(<span class="params">cnt</span>):</span></span><br><span class="line">    bkey = <span class="string">&quot;AYZpq23IJrTFfghijklCDE1KLMmBdestU5678GHz0cuvwabN9+/VWXnoOPQRSxy4&quot;</span></span><br><span class="line">    bkey_bytes=bytes(bkey,<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    res=bytearray()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(bkey)):</span><br><span class="line">        res.append((bkey_bytes[i] &amp;~ cnt)|(cnt &amp;~ bkey_bytes[i]))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改的base64算法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">base64Encode</span>(<span class="params">bkey,input</span>):</span></span><br><span class="line">    cnt=len(input)</span><br><span class="line">    cntpre=cnt<span class="number">-2</span></span><br><span class="line">    cnt1=cnt</span><br><span class="line">    output=bytes(<span class="number">0</span>)</span><br><span class="line">    input_bytes=input</span><br><span class="line">    v6=<span class="number">0</span></span><br><span class="line">    v7=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> v7 &gt;= cntpre:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        v9 = v7</span><br><span class="line">        v6 += <span class="number">4</span></span><br><span class="line">        <span class="comment"># output+=struct.pack(&quot;B&quot;,bkey[input_bytes[v7] &gt;&gt; 2])</span></span><br><span class="line">        v6 = bkey[((input_bytes[v7] &gt;&gt; <span class="number">2</span>) ^ <span class="number">0x3FFFFFC0</span>) &amp; (input_bytes[v7] &gt;&gt; <span class="number">2</span>)]</span><br><span class="line">        v28_0 = (cnt &amp; ~v6) | (v6 &amp; ~ cnt)</span><br><span class="line">        output += struct.pack(<span class="string">&quot;B&quot;</span>, v28_0)</span><br><span class="line"></span><br><span class="line">        v10=input_bytes[v7+<span class="number">1</span>]</span><br><span class="line">        v11=input_bytes[v7]</span><br><span class="line">        v7+=<span class="number">3</span></span><br><span class="line">        <span class="comment"># output +=struct.pack(&quot;B&quot;,bkey[(v10 &gt;&gt; 4) &amp; 0xFFFFFFCF | 16 * (v11 &amp; 3)])</span></span><br><span class="line">        output +=struct.pack(<span class="string">&quot;B&quot;</span>,bkey[ ((<span class="number">16</span> * v11 ^ <span class="number">0xC0</span>) &amp; <span class="number">16</span> * v11 | (v10 &gt;&gt; <span class="number">4</span>))&amp;<span class="number">0xff</span>])</span><br><span class="line">        <span class="comment"># output +=struct.pack(&quot;B&quot;,bkey[((input_bytes[v9 + 2] &gt;&gt; 6) &amp; 0xFFFFFFC3) | (4 * (input_bytes[v9 + 1] &amp; 0xF))])</span></span><br><span class="line">        v17= ((input_bytes[v9 + <span class="number">2</span>] &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0xFFFFFFC3</span>) | (<span class="number">4</span> * (input_bytes[v9 + <span class="number">1</span>] &amp; <span class="number">0xF</span>))</span><br><span class="line">        output +=struct.pack(<span class="string">&quot;B&quot;</span>,(cnt &amp;~ bkey[v17])|(bkey[v17] &amp;~ cnt))</span><br><span class="line">        output +=struct.pack(<span class="string">&quot;B&quot;</span>,bkey[(input_bytes[v9 + <span class="number">2</span>])&amp;<span class="number">0x3f</span>])</span><br><span class="line">    <span class="keyword">if</span> v7 &lt; cnt1 :</span><br><span class="line">        output +=struct.pack(<span class="string">&quot;B&quot;</span>,bkey[input_bytes[v7] &gt;&gt; <span class="number">2</span>])</span><br><span class="line">        v12 = <span class="number">16</span> * input_bytes[v7] &amp; <span class="number">0x30</span></span><br><span class="line">        <span class="keyword">if</span> cnt1 - <span class="number">1</span> == v7:</span><br><span class="line">            v13 = <span class="string">&#x27;=&#x27;</span></span><br><span class="line">            output+=bkey[v12]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            output+=struct.pack(<span class="string">&quot;B&quot;</span>,bkey[v12 | (input_bytes[v7+<span class="number">1</span>] &gt;&gt; <span class="number">4</span>)])</span><br><span class="line">            v13=struct.pack(<span class="string">&quot;B&quot;</span>,bkey[<span class="number">4</span> * (input_bytes[v7+<span class="number">1</span>] &amp; <span class="number">0xF</span>)])</span><br><span class="line">        output+=bytes([<span class="number">0x3d</span>])</span><br><span class="line">        output+=v13</span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="comment">#加密算法1.把明文先加密一遍</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_data</span>(<span class="params">input</span>):</span></span><br><span class="line">    tbkey = bytearray(StrToHexSplit(tbkeyStr))</span><br><span class="line">    tb2key = bytearray(StrToHexSplit(tb2keyStr))</span><br><span class="line">    res=bytes(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(input)):</span><br><span class="line">        tb2value=tb2key[i]</span><br><span class="line">        tmp=tbkey[i+<span class="number">1</span>]</span><br><span class="line">        tbkey[i+<span class="number">1</span>]=tbkey[tb2key[i]]</span><br><span class="line">        tbkey[tb2key[i]]=tmp</span><br><span class="line">        tbvalue1 = tbkey[i + <span class="number">1</span>]</span><br><span class="line">        tbvalue2=tbkey[tb2value]</span><br><span class="line">        tbvalue=tbvalue1+tbvalue2</span><br><span class="line">        tbvalue=tbvalue&amp;<span class="number">0xff</span></span><br><span class="line">        chdata=ord(input[i])</span><br><span class="line">        tbres=tbkey[tbvalue]</span><br><span class="line">        cdata=(tbres&amp;~chdata)|(chdata&amp;~tbres)</span><br><span class="line">        res+=struct.pack(<span class="string">&quot;B&quot;</span>,cdata)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    res=calc_data(<span class="string">&quot;dtYeKUzFKTZnVLYSNZxSbrE&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;data:&quot;</span>,b2hex(res))</span><br><span class="line">    bkey = getKey(len(res))</span><br><span class="line">    print(<span class="string">&quot;bkey:&quot;</span>, b2hex(bkey))</span><br><span class="line">    res = base64Encode(bkey, res)</span><br><span class="line">    print(<span class="string">&quot;res:&quot;</span>, b2hex(res))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果。对比上面frida抓到的完全一致。到这里做完了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data: 7D 1A B1 3B 1F 6B 7C 96 E9 E2 C1 A5 EA 3B E4 97 6D DA 1E 01 75 92 E2</span><br><span class="line">bkey: 56 4E 4D 67 66 25 24 5E 5D 65 43 51 71 70 7F 7E 7D 7C 7B 54 53 52 26 5C 5B 5A 7A 55 73 72 64 63 42 22 21 20 2F 50 5F 6D 27 74 62 61 60 76 75 59 2E 3C 38 41 40 4F 79 78 58 47 46 45 44 6F 6E 23</span><br><span class="line">res: 74 7C 75 3C 68 3C 78 61 74 65 42 74 4F 60 33 50 51 20 4E 2F 47 79 6F 7A 49 42 32 4F 2F 75 3D 5D</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法还原实战练习5</title>
      <link href="/2021/01/14/zuoye5/"/>
      <url>/2021/01/14/zuoye5/</url>
      
        <content type="html"><![CDATA[<p>分析样例下载：链接: <a href="https://pan.baidu.com/s/1TErQmcjNbLG54yJbD31mLg">https://pan.baidu.com/s/1TErQmcjNbLG54yJbD31mLg</a>  密码: j455</p><p>练习1、algorithmbase_50.apk</p><p>老样子直接ida分析libnative-lib.so。根据返回值处理找到关键函数sub_B9F4</p><p><img src="/2021/01/14/zuoye5/image-20210114220409205.png" alt="image-20210114220409205"></p><p>写个frida来查一下看看参数都是些什么</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_native</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> base_addr=Module.getBaseAddress(<span class="string">&quot;libnative-lib.so&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> sub_B9F4=base_addr.add(<span class="number">0xB9F4</span>+<span class="number">1</span>);</span><br><span class="line">    Interceptor.attach(sub_B9F4,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;onEnter sub_B9F4&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.arg4=args[<span class="number">4</span>];</span><br><span class="line">            <span class="built_in">console</span>.log(hexdump(args[<span class="number">0</span>],&#123;<span class="attr">length</span>:args[<span class="number">1</span>].toInt32()&#125;));</span><br><span class="line">            <span class="built_in">console</span>.log(hexdump(args[<span class="number">2</span>],&#123;<span class="attr">length</span>:args[<span class="number">3</span>].toInt32()&#125;));</span><br><span class="line"></span><br><span class="line">        &#125;,<span class="attr">onLeave</span>:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;onLeave sub_B9F4&quot;</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(hexdump(<span class="built_in">this</span>.arg4,&#123;<span class="attr">length</span>:<span class="number">0x10</span>&#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_java</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> native_lib=Java.use(<span class="string">&quot;com.kanxue.algorithmbase.MainActivity&quot;</span>);</span><br><span class="line">        native_lib.encodeFromJni_50.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">input</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> res=<span class="built_in">this</span>.encodeFromJni_50(input);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;input:&quot;</span>,input,<span class="string">&quot;output:&quot;</span>,res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    hook_java();</span><br><span class="line">    hook_native();</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></table></figure><p>然后根据输出结果把字段的意义标注好。分别是input，input_size，kanxue_imyang，13，output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">onEnter sub_B9F4</span><br><span class="line">           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">d6bcde40  4d 44 45 77 71 70 57 42 71 43 45 57 49 6d 58 4a  MDEwqpWBqCEWImXJ</span><br><span class="line">d6bcde50  4d 7a 6a 56 63 76 6f 6f 72 78 63 77 47           MzjVcvoorxcwG</span><br><span class="line">           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">d6c66b01  6b 61 6e 78 75 65 5f 69 6d 79 61 6e 67           kanxue_imyang</span><br><span class="line">onLeave sub_B9F4</span><br><span class="line">           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">ff87d308  2f 49 e7 d6 89 c2 41 77 87 25 5d 18 6d 60 21 47  &#x2F;I....Aw.%].m&#96;!G</span><br><span class="line">input: MDEwqpWBqCEWImXJMzjVcvoorxcwG output: 2f49e7d689c2417787255d186d602147</span><br></pre></td></tr></table></figure><p>然后继续进去看函数。</p><p><img src="/2021/01/14/zuoye5/image-20210114222053217.png" alt="image-20210114222053217"></p><p>这里看到了几个熟悉的常量。看起来是和MD5相关的函数。但是又不完全是md5的算法。然后hoo一下sub_AF84</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sub_AF84=base_addr.add(<span class="number">0xAF84</span>+<span class="number">1</span>);</span><br><span class="line">    Interceptor.attach(sub_AF84,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;onEnter sub_AF84&quot;</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(hexdump(args[<span class="number">0</span>],&#123;<span class="attr">length</span>:<span class="number">0x30</span>&#125;));</span><br><span class="line">            <span class="built_in">console</span>.log(hexdump(args[<span class="number">1</span>],&#123;<span class="attr">length</span>:<span class="number">0x30</span>&#125;));</span><br><span class="line">        &#125;,<span class="attr">onLeave</span>:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;onLeave sub_AF84&quot;</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(retval);</span><br><span class="line">            <span class="built_in">console</span>.log(hexdump(retval,&#123;<span class="attr">length</span>:<span class="number">0x30</span>&#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>输出结果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">onEnter sub_AF84</span><br><span class="line">           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">ff87d258  85 b8 ae dd 3b 59 c5 59 4e 35 62 17 9c 92 d8 d7  ....;Y.YN5b.....</span><br><span class="line">ff87d268  00 02 00 00 00 00 00 00 5d 57 58 4e 43 53 69 5f  ........]WXNCSi_</span><br><span class="line">ff87d278  5b 4f 57 58 51 36 36 36 36 36 36 36 36 36 36 36  [OWXQ66666666666</span><br><span class="line">           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">e3ad3280  6c 4b 58 42 71 77 6b 41 67 79 75 50 6c 61 72 6f  lKXBqwkAgyuPlaro</span><br><span class="line">e3ad3290  6a 58 76 4a 63 00 65 72 4e 61 74 69 76 65 3a 00  jXvJc.erNative:.</span><br><span class="line">e3ad32a0  00 82 2b d7 00 82 2b d7 00 82 2b d7 00 82 2b d7  ..+...+...+...+.</span><br><span class="line">onLeave sub_AF84</span><br><span class="line">           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">ff87d285  36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36  6666666666666666</span><br><span class="line">ff87d295  36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36  6666666666666666</span><br><span class="line">ff87d2a5  36 36 36 36 36 36 36 36 36 36 36 cb 8f 68 7c dc  66666666666..h|.</span><br><span class="line">onEnter sub_AF84</span><br><span class="line">           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">ff87d258  01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10  .#Eg........vT2.</span><br><span class="line">ff87d268  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">ff87d278  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">ff87d1d6  37 3d 32 24 29 39 03 35 31 25 3d 32 3b 5c 5c 5c  7&#x3D;2$)9.51%&#x3D;2;\\\</span><br><span class="line">ff87d1e6  5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c  \\\\\\\\\\\\\\\\</span><br><span class="line">ff87d1f6  5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c  \\\\\\\\\\\\\\\\</span><br></pre></td></tr></table></figure><p>这种将后面空白部分填充为0x5c的特征是hmac的。我们翻一翻网上的hmac的源码看看函数定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hmac_sha256</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *data, <span class="keyword">size_t</span> len, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">int</span> len_key, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out)</span></span></span><br></pre></td></tr></table></figure><p>上面这个例子虽然是hmac+sha256的。但是定义都是差不多。然后发现我们之前hook看到的函数定义和这个基本一样的。那么kanxue_imyang多半就是key了。</p><p>这个很可能是hmac+MD5的组合。接下来可以验证一下结果。是正确的。第一题搞定</p><p><img src="/2021/01/14/zuoye5/image-20210114225845426.png" alt="image-20210114225845426"></p><p>========================================================================================</p><p>练习2、algorithmbase_51.apk</p><p>老样子。直接看ida的加密函数encodeFromJni_151。然后发现和上面的例子差不多。</p><p><img src="/2021/01/14/zuoye5/image-20210114230109335.png" alt="image-20210114230109335"></p><p>发现那个key被字符串加密了。用unidbg来跑下解密字符串</p><p><img src="/2021/01/14/zuoye5/image-20210114230210551.png" alt="image-20210114230210551"></p><p>然后看到这个key依然没有变。还是kanxue_imyang</p><p><img src="/2021/01/14/zuoye5/image-20210114230240424.png" alt="image-20210114230240424"></p><p>然后打印一下结果输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input: iUmDZItFtGUbYQNFHYyRIIBAuvfBx output: 518688644d0e0551da5d4c9883cdcb4e</span><br></pre></td></tr></table></figure><p>我们确定出了key。但是还得确定组合算法是不是MD5。先拿MD5的几个常量搜索一下0x28955B88、0x242070DB、0x173848AA</p><p>随便搜索几个之后。就发现有些能搜索到。有些搜索不到。那么这个可能是一个改了table的MD5。那么先跑一下trace。然后查一下看看有多少个常量被修改了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lianxi51</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        lianxi51 lianxi = <span class="keyword">new</span> lianxi51();</span><br><span class="line">        lianxi.Call_EncodeFromJni_32();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AndroidEmulator emulator;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> VM vm;</span><br><span class="line">    <span class="keyword">private</span> DvmClass Clazz;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">lianxi51</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        emulator = <span class="keyword">new</span> AndroidARMEmulator();</span><br><span class="line">        Memory memory = emulator.getMemory();</span><br><span class="line">        LibraryResolver resolver = <span class="keyword">new</span> AndroidResolver(<span class="number">23</span>);</span><br><span class="line">        memory.setLibraryResolver(resolver);</span><br><span class="line">        vm = emulator.createDalvikVM(<span class="keyword">null</span>);</span><br><span class="line">        vm.setVerbose(<span class="keyword">false</span>);</span><br><span class="line">        DalvikModule dm = vm.loadLibrary(<span class="keyword">new</span> File(<span class="string">&quot;unidbg-android/src/test/resources/example_binaries/lianxi51/libnative-lib.so&quot;</span>), <span class="keyword">false</span>);</span><br><span class="line">        dm.callJNI_OnLoad(emulator);</span><br><span class="line">        Clazz = vm.resolveClass(<span class="string">&quot;com/kanxue/algorithmbase/MainActivity&quot;</span>);</span><br><span class="line">        KingTrace trace=<span class="keyword">new</span> KingTrace(emulator);</span><br><span class="line">        <span class="keyword">long</span> start=<span class="number">0x400121B8</span>;      <span class="comment">//0x196c8  0x3bb4</span></span><br><span class="line">        <span class="keyword">long</span> end=<span class="number">0x400121B8</span>+<span class="number">0x1c1e</span>;</span><br><span class="line">        trace.initialize(start,end,<span class="keyword">null</span>);</span><br><span class="line">        emulator.getBackend().hook_add_new(trace,start,end,emulator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Call_EncodeFromJni_32</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String res=Clazz.callStaticJniMethodObject(emulator,<span class="string">&quot;encodeFromJni_151(Ljava/lang/String;)Ljava/lang/String;&quot;</span>,<span class="string">&quot;iUmDZItFtGUbYQNFHYyRIIBAuvfBx&quot;</span>).toString();</span><br><span class="line">        System.out.print(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后拿跑出来的日志筛了一下MD5的常量列表。结果都在里面。然后搜索MD5的常量找到关键函数sub_121b8。hook一下看看init的key是不是有修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> base_addr=Module.getBaseAddress(<span class="string">&quot;libnative-lib.so&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> sub_121b8=base_addr.add(<span class="number">0x121b8</span>+<span class="number">1</span>);</span><br><span class="line">    Interceptor.attach(sub_121b8,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;onEnter sub_121b8&quot;</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(hexdump(args[<span class="number">0</span>],&#123;<span class="attr">length</span>:<span class="number">0x30</span>&#125;));</span><br><span class="line">            <span class="built_in">console</span>.log(hexdump(args[<span class="number">1</span>],&#123;<span class="attr">length</span>:<span class="number">0x30</span>&#125;));</span><br><span class="line"></span><br><span class="line">        &#125;,<span class="attr">onLeave</span>:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;onLeave sub_121b8&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>输出结果可以看到是MD5的init没有修改的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">onEnter sub_121b8</span><br><span class="line">           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">ff87d258  01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10  .#Eg........vT2.</span><br><span class="line">ff87d268  00 02 00 00 00 00 00 00 e3 e9 e6 f0 fd ed d7 e1  ................</span><br><span class="line">ff87d278  e5 f1 e9 e6 ef 88 88 88 88 88 88 88 88 88 88 88  ................</span><br><span class="line">           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">ff87d270  e3 e9 e6 f0 fd ed d7 e1 e5 f1 e9 e6 ef 88 88 88  ................</span><br><span class="line">ff87d280  88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88  ................</span><br><span class="line">ff87d290  88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88  ................</span><br></pre></td></tr></table></figure><p>既然MD5没有修改。那就只能是hmac发生了变化。找一下hmac中的计算关键处。发现很有可能就是hmac发生了修改</p><p><img src="/2021/01/14/zuoye5/image-20210114232846271.png" alt="image-20210114232846271"></p><p>虽然这里看着好像是要修改0x36和0x5c为0x25和0xc。但是上面看着好像经过了复杂的运算。最终结果不一定。这里我们可以留意到。之前第一题的时候。我们hook了sub_AF84函数。后面会补充36和5c。正好就是这里异或的。所以这个例子我们只要找到和之前sub_AF84相同的函数。然后hook一下。看看后面补充的是什么。就直接修改即可。根据最后一个参数为0x40。可以很快找到对应的函数sub_11DF0。下面贴上hook代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">onEnter sub_11DF0</span><br><span class="line">           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">ff87d258  01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10  .#Eg........vT2.</span><br><span class="line">ff87d268  00 00 00 00 00 00 00 00 98 d2 87 ff 9d 12 0d d7  ................</span><br><span class="line">ff87d278  a1 43 27 ec dc d2 87 ff dc d2 87 ff dc d2 87 ff  .C&#39;.............</span><br><span class="line">           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">ff87d217  e3 e9 e6 f0 fd ed d7 e1 e5 f1 e9 e6 ef 88 88 88  ................</span><br><span class="line">ff87d227  88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88  ................</span><br><span class="line">ff87d237  88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88  ................</span><br><span class="line">onEnter sub_11DF0</span><br><span class="line">           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">ff87d258  01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10  .#Eg........vT2.</span><br><span class="line">ff87d268  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">ff87d278  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">ff87d1d6  0d 07 08 1e 13 03 39 0f 0b 1f 07 08 01 66 66 66  ......9......fff</span><br><span class="line">ff87d1e6  66 66 66 66 66 66 66 66 66 66 66 66 66 66 66 66  ffffffffffffffff</span><br><span class="line">ff87d1f6  66 66 66 66 66 66 66 66 66 66 66 66 66 66 66 66  ffffffffffffffff</span><br></pre></td></tr></table></figure><p>那么就可以验证试一下了。首先放上我整理好的连接<a href="https://github.com/dqzg12300/hmac_md5">https://github.com/dqzg12300/hmac_md5</a></p><p>然后简单贴一部分相关代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hmac-md5.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* input=<span class="string">&quot;iUmDZItFtGUbYQNFHYyRIIBAuvfBx&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span>* key=<span class="string">&quot;kanxue_imyang&quot;</span>;</span><br><span class="line">    <span class="keyword">md5_digest_t</span> out=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    hmac_md5(input,<span class="built_in">strlen</span>(input),key,<span class="built_in">strlen</span>(key),out);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">sizeof</span>(out);i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%x &quot;</span>,out[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有修改了hmac部分的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">64</span>; i++) &#123;</span><br><span class="line">        k_ipad[i] ^= <span class="number">0x88</span>;      <span class="comment">//36</span></span><br><span class="line">        k_opad[i] ^= <span class="number">0x66</span>;      <span class="comment">//5c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后贴上成功的测试结果。和抓到的结果一致。第二题搞定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">51 86 88 64 4d e 5 51 da 5d 4c 98 83 cd cb 4e </span><br></pre></td></tr></table></figure><p>========================================================================================</p><p>练习三algorithmbase_52.apk</p><p>ida打开encodeFromJni_152函数就看到了字符串加密</p><p><img src="/2021/01/14/zuoye5/image-20210115000818798.png" alt="image-20210115000818798"></p><p>然后用unidbg解密后得到key</p><p><img src="/2021/01/14/zuoye5/image-20210115000841545.png" alt="image-20210115000841545"></p><p>然后我们先输出一下看看结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input: TlmFvaUqfZaBROIZwzMTCa output: 1a03845278e8f101ec41e041e7cb6896b2d58268805045322488cb1685380083</span><br></pre></td></tr></table></figure><p>发现这个输出比较长了。估计不是MD5算法了。但是从前面的代码来看。依然还是hmac的。根据输出结果判断。这个有可能是hmac+sha256。我们在网上随便再找找sha256的常量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var K = [</span><br><span class="line">            <span class="number">0x428a2f98</span>, <span class="number">0x71374491</span>, <span class="number">0xb5c0fbcf</span>, <span class="number">0xe9b5dba5</span>, <span class="number">0x3956c25b</span>, <span class="number">0x59f111f1</span>, <span class="number">0x923f82a4</span>, <span class="number">0xab1c5ed5</span>,</span><br><span class="line">            <span class="number">0xd807aa98</span>, <span class="number">0x12835b01</span>, <span class="number">0x243185be</span>, <span class="number">0x550c7dc3</span>, <span class="number">0x72be5d74</span>, <span class="number">0x80deb1fe</span>, <span class="number">0x9bdc06a7</span>, <span class="number">0xc19bf174</span>,</span><br><span class="line">            <span class="number">0xe49b69c1</span>, <span class="number">0xefbe4786</span>, <span class="number">0x0fc19dc6</span>, <span class="number">0x240ca1cc</span>, <span class="number">0x2de92c6f</span>, <span class="number">0x4a7484aa</span>, <span class="number">0x5cb0a9dc</span>, <span class="number">0x76f988da</span>,</span><br><span class="line">            <span class="number">0x983e5152</span>, <span class="number">0xa831c66d</span>, <span class="number">0xb00327c8</span>, <span class="number">0xbf597fc7</span>, <span class="number">0xc6e00bf3</span>, <span class="number">0xd5a79147</span>, <span class="number">0x06ca6351</span>, <span class="number">0x14292967</span>,</span><br><span class="line">            <span class="number">0x27b70a85</span>, <span class="number">0x2e1b2138</span>, <span class="number">0x4d2c6dfc</span>, <span class="number">0x53380d13</span>, <span class="number">0x650a7354</span>, <span class="number">0x766a0abb</span>, <span class="number">0x81c2c92e</span>, <span class="number">0x92722c85</span>,</span><br><span class="line">            <span class="number">0xa2bfe8a1</span>, <span class="number">0xa81a664b</span>, <span class="number">0xc24b8b70</span>, <span class="number">0xc76c51a3</span>, <span class="number">0xd192e819</span>, <span class="number">0xd6990624</span>, <span class="number">0xf40e3585</span>, <span class="number">0x106aa070</span>,</span><br><span class="line">            <span class="number">0x19a4c116</span>, <span class="number">0x1e376c08</span>, <span class="number">0x2748774c</span>, <span class="number">0x34b0bcb5</span>, <span class="number">0x391c0cb3</span>, <span class="number">0x4ed8aa4a</span>, <span class="number">0x5b9cca4f</span>, <span class="number">0x682e6ff3</span>,</span><br><span class="line">            <span class="number">0x748f82ee</span>, <span class="number">0x78a5636f</span>, <span class="number">0x84c87814</span>, <span class="number">0x8cc70208</span>, <span class="number">0x90befffa</span>, <span class="number">0xa4506ceb</span>, <span class="number">0xbef9a3f7</span>, <span class="number">0xc67178f2</span> ];</span><br><span class="line">        <span class="comment">// initial hash value [§5.3.1]</span></span><br><span class="line">        var H = [</span><br><span class="line">            <span class="number">0x6a09e667</span>, <span class="number">0xbb67ae85</span>, <span class="number">0x3c6ef372</span>, <span class="number">0xa54ff53a</span>, <span class="number">0x510e527f</span>, <span class="number">0x9b05688c</span>, <span class="number">0x1f83d9ab</span>, <span class="number">0x5be0cd19</span> ];</span><br></pre></td></tr></table></figure><p>然后用ida搜索一下。搜了好几个结果都是有找到的。我就只贴一个示意图了</p><p><img src="/2021/01/14/zuoye5/image-20210115002128274.png" alt="image-20210115002128274"></p><p>那么验证一下结果看看。结果和上面对的上了。第三题搞定</p><p><img src="/2021/01/14/zuoye5/image-20210115002254506.png" alt="image-20210115002254506"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法还原实战练习4</title>
      <link href="/2021/01/12/zuoye4/"/>
      <url>/2021/01/12/zuoye4/</url>
      
        <content type="html"><![CDATA[<p>分析样例下载：链接: <a href="https://pan.baidu.com/s/1Mb6U4D24SlG_K6n1dxszOQ">https://pan.baidu.com/s/1Mb6U4D24SlG_K6n1dxszOQ</a>  密码: ikpe</p><p>第一题algorithmbase_40.apk</p><p>直接ida打开libnative-lib.so。找到Java_com_kanxue_algorithmbase_MainActivity_encodeFromJni_140。然后根据返回值看来源。最后v15是返回的。然后v8=&amp;v15。然后v8的值是v17逐个字节赋值的。所以关键在于v17。关键函数直接定位出来在sub_AB90.另外看v16的值。和MD5的算法有点像。可能也是一个hash算法。</p><p><img src="/2021/01/12/zuoye4/image-20210112223827223.png" alt="image-20210112223827223"></p><p>接着看到里面只有一个函数sub_9AFC。直接进去看看。</p><a id="more"></a><p><img src="/2021/01/12/zuoye4/image-20210112224210157.png" alt="image-20210112224210157"></p><p>进去后也只有一个函数sub_9BA4。继续进去看看是不是算法的部分</p><p><img src="/2021/01/12/zuoye4/image-20210112224302944.png" alt="image-20210112224302944"></p><p>果然看到熟悉的算法部分。搜索一下常量看看有啥收获不</p><p><img src="/2021/01/12/zuoye4/image-20210112224400383.png" alt="image-20210112224400383"></p><p>看到直接就是sha1的关键常量。我们验证下看看</p><p><img src="/2021/01/12/zuoye4/image-20210112224455289.png" alt="image-20210112224455289"></p><p>先frida抓一下计算的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input: cKGiDKZnhktnzCxsXzGP output: ec048f770484aee853187e413d1dd4f478ce842e</span><br></pre></td></tr></table></figure><p>然后验证一下kanxue_imyang_40_cKGiDKZnhktnzCxsXzGP的sha1值是否和结果一致。第一题搞定</p><p><img src="/2021/01/12/zuoye4/image-20210112224911512.png" alt="image-20210112224911512"></p><p>==========================================================================================</p><p>第二题algorithmbase_41.apk</p><p>先ida简单看下关键函数处</p><p><img src="/2021/01/12/zuoye4/image-20210113204338119.png" alt="image-20210113204338119"></p><p>然后frida打印一下结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input: fgfPLREXkGWWzfVPvtSjGxkkBsFP output: d58aa1c17830271e523dcc59808ec75e1f6660ad</span><br></pre></td></tr></table></figure><p>然后再用sha1标准的计算一下kanxue_imyang_41_fgfPLREXkGWWzfVPvtSjGxkkBsFP的结果是b5d3a0ebffb5eb1048e19455bcea310068833c0e</p><p>说明可能是sha1算法是经过修改的或者是input值还有其他的拼接。先排查下sha1标准算法的常量是否被修改了。</p><p>然后用ida在sub_9BA4函数中挨个搜索一遍。然后发现0x8f1bbcdc和0xca62c1d6搜索不到。估计是被修改了。在ida中找0x6ed9eba1的下一个常量是0x70E44324。再下一个常量是0x359D3E2A。发现这个变动后。我们找个sha1的算法来修改常量测试一下结果。我随便找个项目测试下<a href="https://github.com/vog/sha1.git">https://github.com/vog/sha1.git</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> <span class="comment">/* argc */</span>, <span class="keyword">const</span> <span class="keyword">char</span> ** <span class="comment">/* argv */</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">string</span> input = <span class="string">&quot;kanxue_imyang_41_fgfPLREXkGWWzfVPvtSjGxkkBsFP&quot;</span>;</span><br><span class="line">    SHA1 checksum;</span><br><span class="line">    checksum.update(input);</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">string</span> hash = checksum.<span class="keyword">final</span>();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;input:&quot;</span> &lt;&lt; input &lt;&lt; <span class="string">&quot; output:&quot;</span> &lt;&lt; hash &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出和标准的一样。确定人家这个sha1算法没问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input:kanxue_imyang_41_fgfPLREXkGWWzfVPvtSjGxkkBsFP output:b5d3a0ebffb5eb1048e19455bcea310068833c0e</span><br></pre></td></tr></table></figure><p>继续找几个常量是否发生了变动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">digest[0] &#x3D; 0x67452301;</span><br><span class="line">digest[1] &#x3D; 0xefcdab89;</span><br><span class="line">digest[2] &#x3D; 0x98badcfe;</span><br><span class="line">digest[3] &#x3D; 0x10325476;</span><br><span class="line">digest[4] &#x3D; 0xc3d2e1f0;</span><br></pre></td></tr></table></figure><p>然后ida搜索一下</p><p><img src="/2021/01/12/zuoye4/image-20210113211935026.png" alt="image-20210113211935026"></p><p>果然发生了变动。按照对应的值修改一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">uint32_t</span> digest[], <span class="built_in">std</span>::<span class="built_in">string</span> &amp;<span class="built_in">buffer</span>, <span class="keyword">uint64_t</span> &amp;transforms)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* SHA1 initialization constants */</span></span><br><span class="line">    digest[<span class="number">0</span>] = <span class="number">0x45670123</span>;</span><br><span class="line">    digest[<span class="number">1</span>] = <span class="number">0xCDEF89AB</span>;</span><br><span class="line">    digest[<span class="number">2</span>] = <span class="number">0xBA98FEDC</span>;</span><br><span class="line">    digest[<span class="number">3</span>] = <span class="number">0x32107654</span>;</span><br><span class="line">    digest[<span class="number">4</span>] = <span class="number">0xD2C3F0E1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Reset counters */</span></span><br><span class="line">    <span class="built_in">buffer</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    transforms = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input:kanxue_imyang_41_fgfPLREXkGWWzfVPvtSjGxkkBsFP output:d58aa1c17830271e523dcc59808ec75e1f6660ad</span><br></pre></td></tr></table></figure><p>=============================================================================</p><p>第三题algorithmbase_42.apk</p><p>直接ida先检查下常量是否正确。然后init里面的常量是没有修改的。我们再看看算法内部用来计算的常量是否一致</p><p><img src="/2021/01/12/zuoye4/image-20210113220511030.png" alt="image-20210113220511030"></p><p>对比后发现不单单值发生了变化。并且也从+变成了-。</p><p>用frida来取一个计算结果先</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input: FbeBTeatDdikDjhyV output: c603885c6817b5e15919d9b50d6d951eb1fd11fc</span><br></pre></td></tr></table></figure><p>然后参考ida的4个常量的值修改一下sha1的代码。留意第一个和第二个的运算要改成减号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">R0</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint32_t</span> block[BLOCK_INTS], <span class="keyword">const</span> <span class="keyword">uint32_t</span> v, <span class="keyword">uint32_t</span> &amp;w, <span class="keyword">const</span> <span class="keyword">uint32_t</span> x, <span class="keyword">const</span> <span class="keyword">uint32_t</span> y, <span class="keyword">uint32_t</span> &amp;z, <span class="keyword">const</span> <span class="keyword">size_t</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    z += ((w&amp;(x^y))^y) + block[i] -  <span class="number">0x7DA56687</span> + rol(v, <span class="number">5</span>);</span><br><span class="line">    w = rol(w, <span class="number">30</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">R1</span><span class="params">(<span class="keyword">uint32_t</span> block[BLOCK_INTS], <span class="keyword">const</span> <span class="keyword">uint32_t</span> v, <span class="keyword">uint32_t</span> &amp;w, <span class="keyword">const</span> <span class="keyword">uint32_t</span> x, <span class="keyword">const</span> <span class="keyword">uint32_t</span> y, <span class="keyword">uint32_t</span> &amp;z, <span class="keyword">const</span> <span class="keyword">size_t</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    block[i] = blk(block, i);</span><br><span class="line">    z += ((w&amp;(x^y))^y) + block[i] - <span class="number">0x7DA56687</span> + rol(v, <span class="number">5</span>);</span><br><span class="line">    w = rol(w, <span class="number">30</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">R2</span><span class="params">(<span class="keyword">uint32_t</span> block[BLOCK_INTS], <span class="keyword">const</span> <span class="keyword">uint32_t</span> v, <span class="keyword">uint32_t</span> &amp;w, <span class="keyword">const</span> <span class="keyword">uint32_t</span> x, <span class="keyword">const</span> <span class="keyword">uint32_t</span> y, <span class="keyword">uint32_t</span> &amp;z, <span class="keyword">const</span> <span class="keyword">size_t</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    block[i] = blk(block, i);</span><br><span class="line">    z += (w^x^y) + block[i] - <span class="number">0x26915E15</span> + rol(v, <span class="number">5</span>);</span><br><span class="line">    w = rol(w, <span class="number">30</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">R3</span><span class="params">(<span class="keyword">uint32_t</span> block[BLOCK_INTS], <span class="keyword">const</span> <span class="keyword">uint32_t</span> v, <span class="keyword">uint32_t</span> &amp;w, <span class="keyword">const</span> <span class="keyword">uint32_t</span> x, <span class="keyword">const</span> <span class="keyword">uint32_t</span> y, <span class="keyword">uint32_t</span> &amp;z, <span class="keyword">const</span> <span class="keyword">size_t</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    block[i] = blk(block, i);</span><br><span class="line">    z += (((w|x)&amp;y)|(w&amp;x)) + block[i] + <span class="number">0x1B8FDCBC</span> + rol(v, <span class="number">5</span>);</span><br><span class="line">    w = rol(w, <span class="number">30</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">R4</span><span class="params">(<span class="keyword">uint32_t</span> block[BLOCK_INTS], <span class="keyword">const</span> <span class="keyword">uint32_t</span> v, <span class="keyword">uint32_t</span> &amp;w, <span class="keyword">const</span> <span class="keyword">uint32_t</span> x, <span class="keyword">const</span> <span class="keyword">uint32_t</span> y, <span class="keyword">uint32_t</span> &amp;z, <span class="keyword">const</span> <span class="keyword">size_t</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    block[i] = blk(block, i);</span><br><span class="line">    z += (w^x^y) + block[i] + <span class="number">0x62CAD6C1</span> + rol(v, <span class="number">5</span>);</span><br><span class="line">    w = rol(w, <span class="number">30</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后计算结果一致。第三题搞定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input:kanxue_imyang_42_FbeBTeatDdikDjhyV output:c603885c6817b5e15919d9b50d6d951eb1fd11fc</span><br></pre></td></tr></table></figure><p>=============================================================================</p><p>第四题algorithmbase_43.apk</p><p>直接ida打开。结果发现字符串被加密了。没法直接看到前面固定加的字符串了。不要紧。先拿去用unidbg或者AndroidNativeEmu来生成一个解密的so</p><p><img src="/2021/01/12/zuoye4/image-20210113221844233.png" alt="image-20210113221844233"></p><p>下面贴上解密后的结果</p><p><img src="/2021/01/12/zuoye4/image-20210113221902907.png" alt="image-20210113221902907"></p><p>然后frida打印下输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input: gkoOrszvENhJEgIFcmnccPtUkAPG output: 4b3ed910435a1b7231cd01ff7b8ddab64926ee75</span><br></pre></td></tr></table></figure><p>先验证下sha1标准的对不对。结果是正确的。没有任何修改。第4题搞定</p><p><img src="/2021/01/12/zuoye4/image-20210113222120944.png" alt="image-20210113222120944"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法还原实战练习3</title>
      <link href="/2021/01/09/zuoye3/"/>
      <url>/2021/01/09/zuoye3/</url>
      
        <content type="html"><![CDATA[<p>分析样例下载：链接: <a href="https://pan.baidu.com/s/1qxkYqMovR8Fe6sO-Zr-8ow">https://pan.baidu.com/s/1qxkYqMovR8Fe6sO-Zr-8ow</a>  密码: dh7g</p><p>第一题algorithmbase_32</p><p>直接ida打开找到encodeFromJni_32函数。然后F5后。发现是ollvm混淆的。然后大概的分析一下。我的分析思路是。首先是大概的翻一下参数较多的那些函数，看看是否有什么比较眼熟的函数。果然很快锁定了一个函数sub_1D920。下面贴上交为眼熟的部分</p><p><img src="/2021/01/09/zuoye3/image-20210109220431469.png" alt="image-20210109220431469"></p><p>我圈出来的这几个特征和我们之前分析过的md5的特征高度的相似。v10的那些明显就是MD5的那个key。而下面是拼接的三段固定数据再加上我们的输入值。所以我们先看看那三段数据分别是什么</p><p><img src="/2021/01/09/zuoye3/image-20210109220926171.png" alt="image-20210109220926171"></p><p>点开后发现字符串被加密了。所以我们用之前研究的解ollvm字符串混淆的工具unidbg或者是AndroidNativeEmu来生成一个解密的so跑一下。下面贴上解完之后的结果</p><a id="more"></a><p><img src="/2021/01/09/zuoye3/image-20210109221223706.png" alt="image-20210109221223706"></p><p>然后点进去看看字符串。</p><p><img src="/2021/01/09/zuoye3/image-20210109221252596.png" alt="image-20210109221252596"></p><p>知道是什么值拼接的之后。然后就简单了。先看看输出和输出的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rRZrALoUFxTqxDCJHjT -&gt; ea8caf7e47b8404d81de797995d6c3cc</span><br></pre></td></tr></table></figure><p>然后我们拼接kanxue+imyang+ollvm_md5+输入数据来MD5看看是否一致</p><p><img src="/2021/01/09/zuoye3/image-20210109222044810.png" alt="image-20210109222044810"></p><p>结果和上面的一致。第一题搞定</p><p>=======================================================================================================</p><p>第二题algorithmbase_32_2</p><p>直接ida开始分析。找到encodeFromJni_32函数。由于上一个例子翻到了关键函数。直接找类似的函数。定位到了sub_1D48C。</p><p><img src="/2021/01/09/zuoye3/image-20210109222513629.png" alt="image-20210109222513629"></p><p>看着和之前的差不多的。然后看看前面固定拼接了些什么</p><p><img src="/2021/01/09/zuoye3/image-20210109222606117.png" alt="image-20210109222606117"></p><p>发现也是字符串混淆加密的。老办法。上unidbg或者是AndroidNativeEmu来生成一个解密的so。</p><p><img src="/2021/01/09/zuoye3/image-20210109222824334.png" alt="image-20210109222824334"></p><p>解密后看到依然还是这几个值。我们跑的测试一下看是否计算的值一致了。先获取一个手机上的输入和输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cPKpWAMuRxJVSJORW -&gt; ec184c0980693ef670486feb407b6031</span><br></pre></td></tr></table></figure><p>看下面的图。发现结果不是一致的</p><p><img src="/2021/01/09/zuoye3/image-20210109224758535.png" alt="image-20210109224758535"></p><p>所以我们还得检查。key是否发生了变化。静态分析上面看。是没有什么变化。我们需要动态调试的情况下看看拼接完数据后。最后调用sub_1CDFC函数的时候v11的值是否已经变了。为了方便调试。我先用unidbg成功把这个函数跑通</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lianxi32</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        lianxi32 lianxi = <span class="keyword">new</span> lianxi32();</span><br><span class="line">        lianxi.Call_EncodeFromJni_32();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AndroidEmulator emulator;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> VM vm;</span><br><span class="line">    <span class="keyword">private</span> DvmClass Clazz;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">lianxi32</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        emulator = <span class="keyword">new</span> AndroidARM64Emulator();</span><br><span class="line">        Memory memory = emulator.getMemory();</span><br><span class="line">        LibraryResolver resolver = <span class="keyword">new</span> AndroidResolver(<span class="number">23</span>);</span><br><span class="line">        memory.setLibraryResolver(resolver);</span><br><span class="line">        vm = emulator.createDalvikVM(<span class="keyword">null</span>);</span><br><span class="line">        vm.setVerbose(<span class="keyword">false</span>);</span><br><span class="line">        DalvikModule dm = vm.loadLibrary(<span class="keyword">new</span> File(<span class="string">&quot;unidbg-android/src/test/resources/example_binaries/lianxi32_2/libnative-lib.so&quot;</span>), <span class="keyword">false</span>);</span><br><span class="line">        dm.callJNI_OnLoad(emulator);</span><br><span class="line">        Clazz = vm.resolveClass(<span class="string">&quot;com/kanxue/algorithmbase/MainActivity&quot;</span>);</span><br><span class="line">        Debugger dbg = emulator.attach();</span><br><span class="line">        dbg.addBreakPoint(dm.getModule(), <span class="number">0x1D63C</span>);</span><br><span class="line">        dbg.debug();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Call_EncodeFromJni_32</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String res=Clazz.callStaticJniMethodObject(emulator,<span class="string">&quot;encodeFromJni_132(Ljava/lang/String;)Ljava/lang/String;&quot;</span>,<span class="string">&quot;cPKpWAMuRxJVSJORW&quot;</span>).toString();</span><br><span class="line">        System.out.print(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>断点的位置是函数调用的点。所以要查v11参数。直接打印X1的内存数据就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0000: 01 23 45 67 00 00 00 00 89 AB CD EF 00 00 00 00    .#Eg............</span><br><span class="line">0010: FE DC BA 98 00 00 00 00 76 54 32 10 00 00 00 00    ........vT2.....</span><br></pre></td></tr></table></figure><p>接着我再把上一个案例也跑一下。对比上一个案例的标准</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0000: 01 23 45 67 00 00 00 00 89 AB CD EF 00 00 00 00    .#Eg............</span><br><span class="line">0010: FE DC BA 98 00 00 00 00 76 54 32 10 00 00 00 00    ........vT2.....</span><br></pre></td></tr></table></figure><p>结果发现key没有啥区别。猜测可能是MD5的那个table表发生了变化又或者这不是一个MD5。先trace一份分析一下.下面的KingTrace使用了我自己封装的。贴一下相关的代码连接<a href="https://github.com/dqzg12300/unidbg.git">https://github.com/dqzg12300/unidbg.git</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lianxi32</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        lianxi32 lianxi = <span class="keyword">new</span> lianxi32();</span><br><span class="line">        lianxi.Call_EncodeFromJni_32();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AndroidEmulator emulator;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> VM vm;</span><br><span class="line">    <span class="keyword">private</span> DvmClass Clazz;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">lianxi32</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        emulator = <span class="keyword">new</span> AndroidARM64Emulator();</span><br><span class="line">        Memory memory = emulator.getMemory();</span><br><span class="line">        LibraryResolver resolver = <span class="keyword">new</span> AndroidResolver(<span class="number">23</span>);</span><br><span class="line">        memory.setLibraryResolver(resolver);</span><br><span class="line">        vm = emulator.createDalvikVM(<span class="keyword">null</span>);</span><br><span class="line">        vm.setVerbose(<span class="keyword">false</span>);</span><br><span class="line">        DalvikModule dm = vm.loadLibrary(<span class="keyword">new</span> File(<span class="string">&quot;unidbg-android/src/test/resources/example_binaries/lianxi32_2/libnative-lib.so&quot;</span>), <span class="keyword">false</span>);</span><br><span class="line">        dm.callJNI_OnLoad(emulator);</span><br><span class="line">        Clazz = vm.resolveClass(<span class="string">&quot;com/kanxue/algorithmbase/MainActivity&quot;</span>);</span><br><span class="line">        KingTrace trace=<span class="keyword">new</span> KingTrace(emulator);</span><br><span class="line">        <span class="keyword">long</span> start=<span class="number">0x400196c8</span>;      <span class="comment">//0x196c8  0x3bb4</span></span><br><span class="line">        <span class="keyword">long</span> end=<span class="number">0x400196c8</span>+<span class="number">0x3bb4</span>;</span><br><span class="line">        trace.initialize(start,end,<span class="keyword">null</span>);</span><br><span class="line">        emulator.getBackend().hook_add_new(trace,start,end,emulator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Call_EncodeFromJni_32</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String res=Clazz.callStaticJniMethodObject(emulator,<span class="string">&quot;encodeFromJni_132(Ljava/lang/String;)Ljava/lang/String;&quot;</span>,<span class="string">&quot;cPKpWAMuRxJVSJORW&quot;</span>).toString();</span><br><span class="line">        System.out.print(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们看一下我们之前github上拿的MD5项目的table表是有哪些数据。然后只保留table的值。去掉其他代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xd76aa478</span></span><br><span class="line"><span class="number">0xe8c7b756</span></span><br><span class="line"><span class="number">0x242070db</span></span><br><span class="line"><span class="number">0xc1bdceee</span></span><br><span class="line"><span class="number">0xf57c0faf</span></span><br><span class="line"><span class="number">0x4787c62a</span></span><br><span class="line"><span class="number">0xa8304613</span></span><br><span class="line"><span class="number">0xfd469501</span></span><br><span class="line"><span class="number">0x698098d8</span></span><br><span class="line"><span class="number">0x8b44f7af</span></span><br><span class="line"><span class="number">0xffff5bb1</span></span><br><span class="line"><span class="number">0x895cd7be</span></span><br><span class="line"><span class="number">0x6b901122</span></span><br><span class="line"><span class="number">0xfd987193</span></span><br><span class="line"><span class="number">0xa679438e</span></span><br><span class="line"><span class="number">0x49b40821</span></span><br><span class="line"><span class="number">0xf61e2562</span></span><br><span class="line"><span class="number">0xc040b340</span></span><br><span class="line"><span class="number">0x265e5a51</span></span><br><span class="line"><span class="number">0xe9b6c7aa</span></span><br><span class="line"><span class="number">0xd62f105d</span></span><br><span class="line"><span class="number">0x2441453</span></span><br><span class="line"><span class="number">0xd8a1e681</span></span><br><span class="line"><span class="number">0xe7d3fbc8</span></span><br><span class="line"><span class="number">0x21e1cde6</span></span><br><span class="line"><span class="number">0xc33707d6</span></span><br><span class="line"><span class="number">0xf4d50d87</span></span><br><span class="line"><span class="number">0x455a14ed</span></span><br><span class="line"><span class="number">0xa9e3e905</span></span><br><span class="line"><span class="number">0xfcefa3f8</span></span><br><span class="line"><span class="number">0x676f02d9</span></span><br><span class="line"><span class="number">0x8d2a4c8a</span></span><br><span class="line"><span class="number">0xfffa3942</span></span><br><span class="line"><span class="number">0x8771f681</span></span><br><span class="line"><span class="number">0x6d9d6122</span></span><br><span class="line"><span class="number">0xfde5380c</span></span><br><span class="line"><span class="number">0xa4beea44</span></span><br><span class="line"><span class="number">0x4bdecfa9</span></span><br><span class="line"><span class="number">0xf6bb4b60</span></span><br><span class="line"><span class="number">0xbebfbc70</span></span><br><span class="line"><span class="number">0x289b7ec6</span></span><br><span class="line"><span class="number">0xeaa127fa</span></span><br><span class="line"><span class="number">0xd4ef3085</span></span><br><span class="line"><span class="number">0x4881d05</span></span><br><span class="line"><span class="number">0xd9d4d039</span></span><br><span class="line"><span class="number">0xe6db99e5</span></span><br><span class="line"><span class="number">0x1fa27cf8</span></span><br><span class="line"><span class="number">0xc4ac5665</span></span><br><span class="line"><span class="number">0xf4292244</span></span><br><span class="line"><span class="number">0x432aff97</span></span><br><span class="line"><span class="number">0xab9423a7</span></span><br><span class="line"><span class="number">0xfc93a039</span></span><br><span class="line"><span class="number">0x655b59c3</span></span><br><span class="line"><span class="number">0x8f0ccc92</span></span><br><span class="line"><span class="number">0xffeff47d</span></span><br><span class="line"><span class="number">0x85845dd1</span></span><br><span class="line"><span class="number">0x6fa87e4f</span></span><br><span class="line"><span class="number">0xfe2ce6e0</span></span><br><span class="line"><span class="number">0xa3014314</span></span><br><span class="line"><span class="number">0x4e0811a1</span></span><br><span class="line"><span class="number">0xf7537e82</span></span><br><span class="line"><span class="number">0xbd3af235</span></span><br><span class="line"><span class="number">0x2ad7d2bb</span></span><br><span class="line"><span class="number">0xeb86d391</span></span><br></pre></td></tr></table></figure><p>在trace记录里面查询一下。能够找的值的索引说明没有被修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;[libnative-lib.so] [0x19fa8] [ 40 ed ba 72 ] 0x40019fa8: movk w0, #0xd76a, lsl #16-----w0&#x3D;0xa478        &#x2F;&#x2F;w0&#x3D;0xd76aa478&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x19fc4] [ e0 18 bd 72 ] 0x40019fc4: movk w0, #0xe8c7, lsl #16-----w0&#x3D;0xb756        &#x2F;&#x2F;w0&#x3D;0xe8c7b756&quot;</span><br></pre></td></tr></table></figure><p>写个简单的脚本检查一下trace中缺少了哪一个table的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&quot;./traces.log&quot;</span>, <span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> tracefile:</span><br><span class="line">        traces=tracefile.read()</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&quot;./md5table.txt&quot;</span>,<span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> md5file:</span><br><span class="line">        table= md5file.read()</span><br><span class="line">        tableSp=table.split(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(tableSp)):</span><br><span class="line">            <span class="keyword">if</span> tableSp[i] <span class="keyword">in</span> traces:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            print(tableSp[i])</span><br></pre></td></tr></table></figure><p>最后打印出下面的两个值。这两个被改动了。然后看看这两个的索引位置分别在9和26的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x698098d8</span><br><span class="line">0xc33707d6</span><br></pre></td></tr></table></figure><p>接下来把traces拿出来搜索一下movk w。过滤后然后在里面搜索到table中的索引8的值0xfd469501在哪里。然后把往后的30条记录全部拿出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&quot;[libnative-lib.so] [0x1a4ac] [ ca a8 bf 72 ] 0x4001a4ac: movk w10, #0xfd46, lsl #16-----w10&#x3D;0x9501        &#x2F;&#x2F;w10&#x3D;0xfd469501&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1a584] [ 0a 33 ad 72 ] 0x4001a584: movk w10, #0x6998, lsl #16-----w10&#x3D;0x80d8        &#x2F;&#x2F;w10&#x3D;0x699880d8&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1a670] [ 8e 68 b1 72 ] 0x4001a670: movk w14, #0x8b44, lsl #16-----w14&#x3D;0xf7af        &#x2F;&#x2F;w14&#x3D;0x8b44f7af&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1a6f8] [ fe 87 b3 72 ] 0x4001a6f8: movk w30, #0x9c3f, lsl #16-----w30&#x3D;0x4e9d        &#x2F;&#x2F;w30&#x3D;0x9c3f4e9d&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1a6fc] [ a6 23 b1 72 ] 0x4001a6fc: movk w6, #0x891d, lsl #16-----w6&#x3D;0xdfce        &#x2F;&#x2F;w6&#x3D;0x891ddfce&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1a700] [ e3 54 bb 72 ] 0x4001a700: movk w3, #0xdaa7, lsl #16-----w3&#x3D;0xe993        &#x2F;&#x2F;w3&#x3D;0xdaa7e993&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1a704] [ 59 8c b1 72 ] 0x4001a704: movk w25, #0x8c62, lsl #16-----w25&#x3D;0x3405        &#x2F;&#x2F;w25&#x3D;0x8c623405&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1a708] [ 82 8e be 72 ] 0x4001a708: movk w2, #0xf474, lsl #16-----w2&#x3D;0x1363        &#x2F;&#x2F;w2&#x3D;0xf4741363&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1a70c] [ 89 8e be 72 ] 0x4001a70c: movk w9, #0xf474, lsl #16-----w9&#x3D;0x1363        &#x2F;&#x2F;w9&#x3D;0xf4741363&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1aa84] [ 0a b3 bf 72 ] 0x4001aa84: movk w10, #0xfd98, lsl #16-----w10&#x3D;0x7193        &#x2F;&#x2F;w10&#x3D;0xfd987193&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1aa9c] [ 8a 2b b1 72 ] 0x4001aa9c: movk w10, #0x895c, lsl #16-----w10&#x3D;0xd7be        &#x2F;&#x2F;w10&#x3D;0x895cd7be&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1aae4] [ 0a 72 ad 72 ] 0x4001aae4: movk w10, #0x6b90, lsl #16-----w10&#x3D;0x1122        &#x2F;&#x2F;w10&#x3D;0x6b901122&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1ab9c] [ 2a cf b4 72 ] 0x4001ab9c: movk w10, #0xa679, lsl #16-----w10&#x3D;0x438e        &#x2F;&#x2F;w10&#x3D;0xa679438e&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1ac10] [ 89 36 a9 72 ] 0x4001ac10: movk w9, #0x49b4, lsl #16-----w9&#x3D;0x821        &#x2F;&#x2F;w9&#x3D;0x49b40821&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1ad04] [ c3 c3 be 72 ] 0x4001ad04: movk w3, #0xf61e, lsl #16-----w3&#x3D;0x2562        &#x2F;&#x2F;w3&#x3D;0xf61e2562&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1ae44] [ c0 cb a4 72 ] 0x4001ae44: movk w0, #0x265e, lsl #16-----w0&#x3D;0x5a51        &#x2F;&#x2F;w0&#x3D;0x265e5a51&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1ae58] [ 06 08 b8 72 ] 0x4001ae58: movk w6, #0xc040, lsl #16-----w6&#x3D;0xb340        &#x2F;&#x2F;w6&#x3D;0xc040b340&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1b02c] [ e0 c5 ba 72 ] 0x4001b02c: movk w0, #0xd62f, lsl #16-----w0&#x3D;0x105d        &#x2F;&#x2F;w0&#x3D;0xd62f105d&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1b0e8] [ c0 36 bd 72 ] 0x4001b0e8: movk w0, #0xe9b6, lsl #16-----w0&#x3D;0xc7aa        &#x2F;&#x2F;w0&#x3D;0xe9b6c7aa&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1b1b8] [ 2f 14 bb 72 ] 0x4001b1b8: movk w15, #0xd8a1, lsl #16-----w15&#x3D;0xe681        &#x2F;&#x2F;w15&#x3D;0xd8a1e681&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1b264] [ 8f 48 a0 72 ] 0x4001b264: movk w15, #0x244, lsl #16-----w15&#x3D;0x1453        &#x2F;&#x2F;w15&#x3D;0x2441453&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1b400] [ 6a fa bc 72 ] 0x4001b400: movk w10, #0xe7d3, lsl #16-----w10&#x3D;0xfbc8        &#x2F;&#x2F;w10&#x3D;0xe7d3fbc8&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1b440] [ ef 60 b8 72 ] 0x4001b440: movk w15, #0xc307, lsl #16-----w15&#x3D;0x37d6        &#x2F;&#x2F;w15&#x3D;0xc30737d6&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1b454] [ 2f 3c a4 72 ] 0x4001b454: movk w15, #0x21e1, lsl #16-----w15&#x3D;0xcde6        &#x2F;&#x2F;w15&#x3D;0x21e1cde6&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1b544] [ a8 9a be 72 ] 0x4001b544: movk w8, #0xf4d5, lsl #16-----w8&#x3D;0xd87        &#x2F;&#x2F;w8&#x3D;0xf4d50d87&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1b6f8] [ 4a ab a8 72 ] 0x4001b6f8: movk w10, #0x455a, lsl #16-----w10&#x3D;0x14ed        &#x2F;&#x2F;w10&#x3D;0x455a14ed&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1b828] [ 6a 3c b5 72 ] 0x4001b828: movk w10, #0xa9e3, lsl #16-----w10&#x3D;0xe905        &#x2F;&#x2F;w10&#x3D;0xa9e3e905&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1b8f4] [ ea 9d bf 72 ] 0x4001b8f4: movk w10, #0xfcef, lsl #16-----w10&#x3D;0xa3f8        &#x2F;&#x2F;w10&#x3D;0xfcefa3f8&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1ba48] [ ef ed ac 72 ] 0x4001ba48: movk w15, #0x676f, lsl #16-----w15&#x3D;0x2d9        &#x2F;&#x2F;w15&#x3D;0x676f02d9&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1bb30] [ 4a a5 b1 72 ] 0x4001bb30: movk w10, #0x8d2a, lsl #16-----w10&#x3D;0x4c8a        &#x2F;&#x2F;w10&#x3D;0x8d2a4c8a&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1bc58] [ 4a ff bf 72 ] 0x4001bc58: movk w10, #0xfffa, lsl #16-----w10&#x3D;0x3942        &#x2F;&#x2F;w10&#x3D;0xfffa3942&quot;</span><br></pre></td></tr></table></figure><p>接下来对比我们代码中的8 9 10索引的值和trace中的8 9 10的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;MD5代码中的</span><br><span class="line">0xfd469501</span><br><span class="line">0x698098d8</span><br><span class="line">0x8b44f7af</span><br><span class="line">&#x2F;&#x2F;trace记录中的</span><br><span class="line">&quot;[libnative-lib.so] [0x1a4ac] [ ca a8 bf 72 ] 0x4001a4ac: movk w10, #0xfd46, lsl #16-----w10&#x3D;0x9501        &#x2F;&#x2F;w10&#x3D;0xfd469501&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1a584] [ 0a 33 ad 72 ] 0x4001a584: movk w10, #0x6998, lsl #16-----w10&#x3D;0x80d8        &#x2F;&#x2F;w10&#x3D;0x699880d8&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1a670] [ 8e 68 b1 72 ] 0x4001a670: movk w14, #0x8b44, lsl #16-----w14&#x3D;0xf7af        &#x2F;&#x2F;w14&#x3D;0x8b44f7af&quot;</span><br></pre></td></tr></table></figure><p>对比出0x698098d8修改成了0x699880d8</p><p>继续再对比24 25 26 27 28和trace中的24 25 26 27 28</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;MD5代码中的</span><br><span class="line">0xe7d3fbc8</span><br><span class="line">0x21e1cde6</span><br><span class="line">0xc33707d6</span><br><span class="line">0xf4d50d87</span><br><span class="line">0x455a14ed</span><br><span class="line">&#x2F;&#x2F;trace记录中的</span><br><span class="line">&quot;[libnative-lib.so] [0x1b400] [ 6a fa bc 72 ] 0x4001b400: movk w10, #0xe7d3, lsl #16-----w10&#x3D;0xfbc8        &#x2F;&#x2F;w10&#x3D;0xe7d3fbc8&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1b440] [ ef 60 b8 72 ] 0x4001b440: movk w15, #0xc307, lsl #16-----w15&#x3D;0x37d6        &#x2F;&#x2F;w15&#x3D;0xc30737d6&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1b454] [ 2f 3c a4 72 ] 0x4001b454: movk w15, #0x21e1, lsl #16-----w15&#x3D;0xcde6        &#x2F;&#x2F;w15&#x3D;0x21e1cde6&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1b544] [ a8 9a be 72 ] 0x4001b544: movk w8, #0xf4d5, lsl #16-----w8&#x3D;0xd87        &#x2F;&#x2F;w8&#x3D;0xf4d50d87&quot;</span><br><span class="line">&quot;[libnative-lib.so] [0x1b6f8] [ 4a ab a8 72 ] 0x4001b6f8: movk w10, #0x455a, lsl #16-----w10&#x3D;0x14ed        &#x2F;&#x2F;w10&#x3D;0x455a14ed&quot;</span><br></pre></td></tr></table></figure><p>对比发现26应该是修改成了0xc30737d6。或者是25变成0xc30737d6，26变成原来的25值。剩下两种可能。我们测试一下看看结果</p><p>接下来修改MD5里面table的第9条为0x699880d8  第26条为0xc30737d6测试一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FF (a, b, c, d, x[ 8], s11, 0x699880d8);</span><br><span class="line">GG (d, a, b, c, x[14], s22, 0xc30737d6);</span><br></pre></td></tr></table></figure><p>测试结果正确。第二题搞定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5(&quot;kanxueimyangollvm_md5cPKpWAMuRxJVSJORW&quot;) &#x3D; ec184c0980693ef670486feb407b6031</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法还原实战练习2</title>
      <link href="/2021/01/07/zuoye2/"/>
      <url>/2021/01/07/zuoye2/</url>
      
        <content type="html"><![CDATA[<p>练习的例子</p><p>链接: <a href="https://pan.baidu.com/s/1BhKdDik8zOx_ioPNFdhQDg">https://pan.baidu.com/s/1BhKdDik8zOx_ioPNFdhQDg</a>  密码: 0npf</p><p>第一题algorithmbase_20.apk</p><p>先是jadx打开apk。然后找到入口页面的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle bundle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(bundle);</span><br><span class="line">        setContentView(C0575R.layout.activity_main);</span><br><span class="line">        <span class="keyword">final</span> TextView textView = (TextView) findViewById(C0575R.C0578id.sample_text);</span><br><span class="line">        ((Button) findViewById(C0575R.C0578id.button)).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="comment">/* class com.kanxue.algorithmbase.MainActivity.C05741 */</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                String randomAlphabetic = RandomStringUtils.randomAlphabetic(RandomUtils.nextInt(<span class="number">16</span>, <span class="number">32</span>));</span><br><span class="line">                String encodeFromJni_20 = MainActivity.encodeFromJni_20(randomAlphabetic);</span><br><span class="line">                Log.e(<span class="string">&quot;Kanxue&quot;</span>, randomAlphabetic + <span class="string">&quot; -&gt; &quot;</span> + encodeFromJni_20);</span><br><span class="line">                textView.setText(encodeFromJni_20);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后ida打开看encodeFromJni_20看到下面的c++代码，然后把第一个参数类型改下。把参数和返回值都修改下名字。代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">v3 = a1;</span><br><span class="line">  input_1 = input;</span><br><span class="line">  v5 = ((<span class="keyword">int</span> (__fastcall *)(JNIEnv *, <span class="keyword">int</span>, _DWORD))(*a1)-&gt;GetStringUTFChars)(a1, input, <span class="number">0</span>);</span><br><span class="line">  sub_87A4(&amp;v11, v5);</span><br><span class="line">  ((<span class="keyword">void</span> (__fastcall *)(JNIEnv *, <span class="keyword">int</span>, <span class="keyword">int</span>))(*v3)-&gt;ReleaseStringUTFChars)(v3, input_1, v5);</span><br><span class="line">  v6 = v14;</span><br><span class="line">  <span class="keyword">if</span> ( !(v11 &amp; <span class="number">1</span>) )</span><br><span class="line">    v6 = v12;</span><br><span class="line">  v7 = v13;</span><br><span class="line">  <span class="keyword">if</span> ( !(v11 &amp; <span class="number">1</span>) )</span><br><span class="line">    v7 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v11 &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  output_1 = sub_8D24(<span class="number">0</span>, v6, v7);</span><br><span class="line">  _aeabi_memclr8(&amp;output, <span class="number">512</span>);</span><br><span class="line">  <span class="built_in">sprintf</span>(&amp;output, (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;unk_15728, output_1);</span><br><span class="line">  v9 = ((<span class="keyword">int</span> (__fastcall *)(JNIEnv *, <span class="keyword">char</span> *))(*v3)-&gt;NewStringUTF)(v3, &amp;output);</span><br><span class="line">  sub_87E6(&amp;v11);</span><br><span class="line">  result = _stack_chk_guard - v16;</span><br><span class="line">  <span class="keyword">if</span> ( _stack_chk_guard == v16 )</span><br><span class="line">    result = v9;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p>然后继续根据返回值来向上找相关函数sub_8D24。然后下面贴上相关代码</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">sub_8D24</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">unsigned</span> __int8 *a2, <span class="keyword">unsigned</span> <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// r3</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v4; <span class="comment">// r3</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// r3</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v6; <span class="comment">// r3</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v7; <span class="comment">// r3</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v8; <span class="comment">// r3</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v9; <span class="comment">// r3</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// r4</span></span><br><span class="line">  <span class="keyword">int</span> v11; <span class="comment">// r5</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v12; <span class="comment">// r3</span></span><br><span class="line">  <span class="keyword">int</span> v13; <span class="comment">// r4</span></span><br><span class="line">  <span class="keyword">int</span> v14; <span class="comment">// r5</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !a2 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v3 = ~a1;</span><br><span class="line">  <span class="keyword">while</span> ( a3 &gt;= <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    a3 -= <span class="number">8</span>;</span><br><span class="line">    v4 = dword_16974[*a2 ^ (<span class="keyword">unsigned</span> __int8)v3] ^ (v3 &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    v5 = dword_16974[(<span class="keyword">unsigned</span> __int8)v4 ^ a2[<span class="number">1</span>]] ^ (v4 &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    v6 = dword_16974[(<span class="keyword">unsigned</span> __int8)v5 ^ a2[<span class="number">2</span>]] ^ (v5 &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    v7 = dword_16974[(<span class="keyword">unsigned</span> __int8)v6 ^ a2[<span class="number">3</span>]] ^ (v6 &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    v8 = dword_16974[(<span class="keyword">unsigned</span> __int8)v7 ^ a2[<span class="number">4</span>]] ^ (v7 &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    v9 = dword_16974[(<span class="keyword">unsigned</span> __int8)v8 ^ a2[<span class="number">5</span>]] ^ (v8 &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    v10 = (<span class="keyword">unsigned</span> __int8)v9 ^ a2[<span class="number">6</span>];</span><br><span class="line">    v11 = a2[<span class="number">7</span>];</span><br><span class="line">    a2 += <span class="number">8</span>;</span><br><span class="line">    v12 = dword_16974[v10] ^ (v9 &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    v3 = dword_16974[(<span class="keyword">unsigned</span> __int8)v12 ^ v11] ^ (v12 &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( a3 )</span><br><span class="line">  &#123;</span><br><span class="line">    v13 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v14 = a2[v13++];</span><br><span class="line">      v3 = dword_16974[v14 ^ (<span class="keyword">unsigned</span> __int8)v3] ^ (v3 &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( a3 != v13 );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ~v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里发现主要是用dword_16974这个数组来进行加密的。所以进去看一下是什么数据</p><p><img src="/2021/01/07/zuoye2/image-20210107203544370.png" alt="image-20210107203544370"></p><p>大致可以确定这里就是加密函数了。那么frida写个脚本来hook一下看看这个函数的参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_native</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> base_addr=Module.getBaseAddress(<span class="string">&quot;libnative-lib.so&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> sub_8D24=base_addr.add(<span class="number">0x8D24</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;sub_8D24:&quot;</span>,sub_8D24)</span><br><span class="line">    Interceptor.attach(sub_8D24,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;========onenter sub_8D24========&quot;</span>)</span><br><span class="line">            <span class="built_in">this</span>.arg0=args[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">console</span>.log(args[<span class="number">1</span>].readCString());</span><br><span class="line">            <span class="built_in">console</span>.log(args[<span class="number">2</span>]);</span><br><span class="line">        &#125;,<span class="attr">onLeave</span>:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;========onleave sub_8D24========&quot;</span>)</span><br><span class="line">            <span class="built_in">console</span>.log(retval);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_java</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> native_lib=Java.use(<span class="string">&quot;com.kanxue.algorithmbase.MainActivity&quot;</span>);</span><br><span class="line">        native_lib.encodeFromJni_20.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">input</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> res=<span class="built_in">this</span>.encodeFromJni_20(input);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;input:&quot;</span>,input,<span class="string">&quot;output:&quot;</span>,res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    hook_java();</span><br><span class="line">    hook_native();</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sub_8D24: 0xd2d98d25</span><br><span class="line">[AOSP on msm8996::com.kanxue.algorithmbase]-&gt; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;onenter sub_8D24&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">AIyJZYSYJNokIqoCvAPvAvLJ</span><br><span class="line">0x18</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;onleave sub_8D24&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">0x6d64185d</span><br><span class="line">input: AIyJZYSYJNokIqoCvAPvAvLJ output: 6d64185d</span><br></pre></td></tr></table></figure><p>看到加密的结果是一串4字节的整数。这个加密可能是adler32或者是crc32之类的。直接用加密工具验证一下</p><p><img src="/2021/01/07/zuoye2/image-20210107201714394.png" alt="image-20210107201714394"></p><p>结果一致。证实第一题就是crc32加密的。</p><p>===========================================================================================</p><p>第二题algorithmbase_21.apk</p><p>jadx打开找到是encodeFromJni_21函数。然后继续ida打开。然后找到关键函数sub_8D88。然后写frida来hook</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_java</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> native_lib=Java.use(<span class="string">&quot;com.kanxue.algorithmbase.MainActivity&quot;</span>);</span><br><span class="line">        native_lib.encodeFromJni_21.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">input</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> res=<span class="built_in">this</span>.encodeFromJni_21(input);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;input:&quot;</span>,input,<span class="string">&quot;output:&quot;</span>,res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    hook_java();</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input: dzkxuTwzdBDUUSHkaN output: bc0d5852</span><br></pre></td></tr></table></figure><p>继续拿crc32验证一下</p><p><img src="/2021/01/07/zuoye2/image-20210107202658513.png" alt="image-20210107202658513"></p><p>还是一样的。奇怪。和第一题没有区别。继续看第三题。后面发现第二题有啥区别再更新</p><p>===========================================================================================</p><p>第三题algorithmbase_22.apk</p><p>根据之前的经验。先直接frida打印一下encodeFromJni_22函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_java</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> native_lib=Java.use(<span class="string">&quot;com.kanxue.algorithmbase.MainActivity&quot;</span>);</span><br><span class="line">        native_lib.encodeFromJni_22.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">input</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> res=<span class="built_in">this</span>.encodeFromJni_22(input);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;input:&quot;</span>,input,<span class="string">&quot;output:&quot;</span>,res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    hook_java();</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></table></figure><p>然后输出结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input: tzRYRdRASJIAMcNOQfijhCwnxGGQCy output: 1ce88c2</span><br></pre></td></tr></table></figure><p>然后再用crc32加密的结果是98be198d，adler32加密的结果是a2370a84。然后用ida进去看看里面是怎么处理的。依然是找到sub_8D88。然后找到我们之前看到的加密关键的那个数组dword_1B064。</p><p><img src="/2021/01/07/zuoye2/image-20210107203645257.png" alt="image-20210107203645257"></p><p>发现这个数组变空了。有可能是静态分析无法看到。是动态加载的。并且修改了crc32标准的table。</p><p>先贴一下c++的代码分析一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">if ( !a2 )</span><br><span class="line">    return 0;</span><br><span class="line">  v3 &#x3D; a1;</span><br><span class="line">  v4 &#x3D; a3;</span><br><span class="line">  v5 &#x3D; a2;</span><br><span class="line">  if ( !byte_1B060 )        &#x2F;&#x2F;这里判断加密的数组是否为空。</span><br><span class="line">    sub_8D38();                    &#x2F;&#x2F;这里对字典进行加载</span><br><span class="line">  v6 &#x3D; ~v3;</span><br><span class="line">  while ( v4 &gt;&#x3D; 8 )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 -&#x3D; 8;</span><br><span class="line">    v7 &#x3D; dword_1B064[*v5 ^ (unsigned __int8)v6] ^ (v6 &gt;&gt; 8);</span><br><span class="line">    v8 &#x3D; dword_1B064[(unsigned __int8)v7 ^ v5[1]] ^ (v7 &gt;&gt; 8);</span><br><span class="line">    v9 &#x3D; dword_1B064[(unsigned __int8)v8 ^ v5[2]] ^ (v8 &gt;&gt; 8);</span><br><span class="line">    v10 &#x3D; dword_1B064[(unsigned __int8)v9 ^ v5[3]] ^ (v9 &gt;&gt; 8);</span><br><span class="line">    v11 &#x3D; dword_1B064[(unsigned __int8)v10 ^ v5[4]] ^ (v10 &gt;&gt; 8);</span><br><span class="line">    v12 &#x3D; dword_1B064[(unsigned __int8)v11 ^ v5[5]] ^ (v11 &gt;&gt; 8);</span><br><span class="line">    v13 &#x3D; (unsigned __int8)v12 ^ v5[6];</span><br><span class="line">    v14 &#x3D; v5[7];</span><br><span class="line">    v5 +&#x3D; 8;</span><br><span class="line">    v15 &#x3D; dword_1B064[v13] ^ (v12 &gt;&gt; 8);</span><br><span class="line">    v6 &#x3D; dword_1B064[(unsigned __int8)v15 ^ v14] ^ (v15 &gt;&gt; 8);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v16 &#x3D; 0;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">      v17 &#x3D; v5[v16++];</span><br><span class="line">      v6 &#x3D; dword_1B064[v17 ^ (unsigned __int8)v6] ^ (v6 &gt;&gt; 8);</span><br><span class="line">    &#125;</span><br><span class="line">    while ( v4 !&#x3D; v16 );</span><br><span class="line">  &#125;</span><br><span class="line">  return ~v6;</span><br></pre></td></tr></table></figure><p>上面的代码可以看到这个关键的加密数组是sub_8D38这个函数计算出来的。</p><p>所以我们先接下来实现2个步骤。1、还原这个字典的计算算法。2、实现修改加密table的crc32算法</p><p>下面贴上ida中看到的字典计算的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">sub_8D38</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// r0</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v1; <span class="comment">// r3</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v2; <span class="comment">// r4</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// r5</span></span><br><span class="line">  <span class="keyword">char</span> *result; <span class="comment">// r0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i != <span class="number">256</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = <span class="number">8</span>;</span><br><span class="line">    v2 = i;</span><br><span class="line">    <span class="keyword">while</span> ( v1 )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = (v2 &gt;&gt; <span class="number">1</span>) ^ <span class="number">0xEDB88310</span>;</span><br><span class="line">      <span class="keyword">if</span> ( !(v2 &lt;&lt; <span class="number">31</span>) )</span><br><span class="line">        v3 = v2 &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      --v1;</span><br><span class="line">      v2 = v3;</span><br><span class="line">    &#125;</span><br><span class="line">    dword_1B064[i] = v2;</span><br><span class="line">  &#125;</span><br><span class="line">  result = &amp;byte_1B060;</span><br><span class="line">  byte_1B060 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>f5出来看到的都是c++的代码。一般我们还原算法。最优先还是使用c++来处理。如果是很简单的。可以用py随便搞一搞。下面我就直接把F5出来的代码修修补补然后给跑起来。下面贴上代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">uint32_t</span>  CRC32_Table[<span class="number">256</span>];</span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">sub_D2DA9D38</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// r0</span></span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">int</span> v1; <span class="comment">// r3</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> v2; <span class="comment">// r4</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// r5</span></span><br><span class="line">    <span class="keyword">char</span> *result; <span class="comment">// r0</span></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i != <span class="number">256</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">    v1 = <span class="number">8</span>;</span><br><span class="line">    v2 = i;</span><br><span class="line">    <span class="keyword">while</span> ( v1 )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = (v2 &gt;&gt; <span class="number">1</span>) ^ <span class="number">0xEDB88310</span>;</span><br><span class="line">      <span class="keyword">if</span> ( !(v2 &lt;&lt; <span class="number">31</span>) )</span><br><span class="line">        v3 = v2 &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      --v1;</span><br><span class="line">      v2 = v3;</span><br><span class="line">    &#125;</span><br><span class="line">        CRC32_Table[i] = v2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getcrc</span><span class="params">(<span class="keyword">char</span> *c, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> crc;</span><br><span class="line">    <span class="keyword">char</span>     *e = c + len;</span><br><span class="line"></span><br><span class="line">    crc = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">    <span class="keyword">while</span> (c &lt; e) &#123;</span><br><span class="line">        crc = ((crc &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x00FFFFFF</span>) ^ CRC32_Table[ (crc^ *c) &amp; <span class="number">0xFF</span> ];</span><br><span class="line">        ++c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>( crc^<span class="number">0xFFFFFFFF</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sub_D2DA9D38();</span><br><span class="line">    <span class="keyword">char</span>* input=<span class="string">&quot;tzRYRdRASJIAMcNOQfijhCwnxGGQCy&quot;</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> ret= getcrc(input,<span class="built_in">strlen</span>(input));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res:0x%x&quot;</span>,ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终输出如下。第三题搞定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x1ce88c2</span><br></pre></td></tr></table></figure><p>=====================================================================================</p><p>第四题algorithmbase_23.apk</p><p>jadx打开后。老样子找到encodeFromJni_23函数。然后ida打开分析该函数。找到算法关键位置看看有什么不同。结果发现算法的逻辑变了</p><p><img src="/2021/01/07/zuoye2/image-20210107222651224.png" alt="image-20210107222651224"></p><p>中间那里在之前的基础上。又固定异或了一个0x29。先写frida脚本跑出一组数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_java</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> native_lib=Java.use(<span class="string">&quot;com.kanxue.algorithmbase.MainActivity&quot;</span>);</span><br><span class="line">        native_lib.encodeFromJni_23.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">input</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> res=<span class="built_in">this</span>.encodeFromJni_23(input);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;input:&quot;</span>,input,<span class="string">&quot;output:&quot;</span>,res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    hook_java();</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input: zRmkXNUnANXldAEJQWmvOWQ output: a31262b1</span><br></pre></td></tr></table></figure><p>然后对我们前面还原的算法做一点点小修改。在后面多异或一个0x29</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">uint32_t</span>  CRC32_Table[<span class="number">256</span>];</span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">sub_D2DA9D38</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// r0</span></span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">int</span> v1; <span class="comment">// r3</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> v2; <span class="comment">// r4</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// r5</span></span><br><span class="line">    <span class="keyword">char</span> *result; <span class="comment">// r0</span></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i != <span class="number">256</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">    v1 = <span class="number">8</span>;</span><br><span class="line">    v2 = i;</span><br><span class="line">    <span class="keyword">while</span> ( v1 )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = (v2 &gt;&gt; <span class="number">1</span>) ^ <span class="number">0xEDB88310</span>;</span><br><span class="line">      <span class="keyword">if</span> ( !(v2 &lt;&lt; <span class="number">31</span>) )</span><br><span class="line">        v3 = v2 &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      --v1;</span><br><span class="line">      v2 = v3;</span><br><span class="line">    &#125;</span><br><span class="line">        CRC32_Table[i] = v2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getcrc</span><span class="params">(<span class="keyword">char</span> *c, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> crc;</span><br><span class="line">    <span class="keyword">char</span>     *e = c + len;</span><br><span class="line"></span><br><span class="line">    crc = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">    <span class="keyword">while</span> (c &lt; e) &#123;</span><br><span class="line">        crc = ((crc &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x00FFFFFF</span>) ^ (CRC32_Table[ (crc^ *c) &amp; <span class="number">0xFF</span>])^<span class="number">0x29</span>;</span><br><span class="line">        ++c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>( crc^<span class="number">0xFFFFFFFF</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sub_D2DA9D38();</span><br><span class="line">    <span class="keyword">char</span>* input=<span class="string">&quot;zRmkXNUnANXldAEJQWmvOWQ&quot;</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> ret= getcrc(input,<span class="built_in">strlen</span>(input));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res:0x%x&quot;</span>,ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果和hook到的一致了。第四题搞定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xa31262b1</span><br></pre></td></tr></table></figure><p>==================================================================================</p><p>第五题algorithmbase_30.apk</p><p>老样子ida找到encodeFromJni_30。frida也hook打印下参数和结果。下面是输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input: FARNAcpufWWoTlGjzOdlvTV output: 68a53473854d175332b40a884754d7ef</span><br><span class="line">input: 1111111111111111111111111111111111111111111111111 output: 42c3e098e89de933319e0e8b5b33806d</span><br></pre></td></tr></table></figure><p>结果是一个固定32位的字符串。说明这应该是一种hash算法。具体是什么算法我们需要分析下c++代码了</p><p><img src="/2021/01/07/zuoye2/image-20210107224731712.png" alt="image-20210107224731712"></p><p>这里可以看出v16就是结果值了。所以sub_98B0就是关键函数。先hook下这个函数。看看参数分别是什么含义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_native</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> base_addr=Module.getBaseAddress(<span class="string">&quot;libnative-lib.so&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> sub_98B0=base_addr.add(<span class="number">0x98B0</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;sub_98B0:&quot;</span>,sub_98B0)</span><br><span class="line">    Interceptor.attach(sub_98B0,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;========onenter sub_98B0========&quot;</span>)</span><br><span class="line">            <span class="built_in">this</span>.arg2=args[<span class="number">2</span>];</span><br><span class="line">            <span class="built_in">console</span>.log(args[<span class="number">0</span>].readCString())</span><br><span class="line">            <span class="built_in">console</span>.log(args[<span class="number">1</span>]);</span><br><span class="line">        &#125;,<span class="attr">onLeave</span>:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;========onleave sub_98B0========&quot;</span>)</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.arg2);</span><br><span class="line">            <span class="built_in">console</span>.log(hexdump(<span class="built_in">this</span>.arg2,&#123;<span class="attr">length</span>:<span class="number">0x10</span>&#125;))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_java</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> native_lib=Java.use(<span class="string">&quot;com.kanxue.algorithmbase.MainActivity&quot;</span>);</span><br><span class="line">        native_lib.encodeFromJni_30.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">input</span>)</span>&#123;</span><br><span class="line">            input=<span class="string">&quot;1111111111111111111111111111111111111111111111111&quot;</span></span><br><span class="line">            <span class="keyword">var</span> res=<span class="built_in">this</span>.encodeFromJni_30(input);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;input:&quot;</span>,input,<span class="string">&quot;output:&quot;</span>,res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    hook_java();</span><br><span class="line">    hook_native();</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></table></figure><p>输出结果如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;onenter sub_98B0&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">1111111111111111111111111111111111111111111111111</span><br><span class="line">0x31</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;onleave sub_98B0&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">0xff87d308</span><br><span class="line">           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">ff87d308  42 c3 e0 98 e8 9d e9 33 31 9e 0e 8b 5b 33 80 6d  B......31...[3.m</span><br><span class="line">input: 1111111111111111111111111111111111111111111111111 output: 42c3e098e89de933319e0e8b5b33806d</span><br></pre></td></tr></table></figure><p>得到结论。参数a1是输入参数。a2是参数长度。a3是返回结果。下面贴上关键加密函数的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">int __fastcall sub_98B0(int input, int cnt, int output)</span><br><span class="line">&#123;</span><br><span class="line">  int input_1; &#x2F;&#x2F; r10</span><br><span class="line">  int cnt_1; &#x2F;&#x2F; r9</span><br><span class="line">  int output_1; &#x2F;&#x2F; r8</span><br><span class="line">  int v7; &#x2F;&#x2F; [sp+4h] [bp-74h]</span><br><span class="line">  int v8; &#x2F;&#x2F; [sp+8h] [bp-70h]</span><br><span class="line">  int v9; &#x2F;&#x2F; [sp+Ch] [bp-6Ch]</span><br><span class="line">  int v10; &#x2F;&#x2F; [sp+10h] [bp-68h]</span><br><span class="line">  int v11; &#x2F;&#x2F; [sp+14h] [bp-64h]</span><br><span class="line">  int v12; &#x2F;&#x2F; [sp+18h] [bp-60h]</span><br><span class="line">  int v13; &#x2F;&#x2F; [sp+5Ch] [bp-1Ch]</span><br><span class="line"></span><br><span class="line">  input_1 &#x3D; input;</span><br><span class="line">  cnt_1 &#x3D; cnt;</span><br><span class="line">  output_1 &#x3D; output;</span><br><span class="line">  v11 &#x3D; 0;</span><br><span class="line">  v12 &#x3D; 0;</span><br><span class="line">  v9 &#x3D; 0x98BADCFE;            &#x2F;&#x2F;这个值搜索一下。发现是MD5算法</span><br><span class="line">  v10 &#x3D; 0x10325476;</span><br><span class="line">  v7 &#x3D; 0x67452301;</span><br><span class="line">  v8 &#x3D; 0xEFCDAB89;</span><br><span class="line">  sub_9068((int)&amp;v7, (int)&quot;kanxue&quot;, 6u);    &#x2F;&#x2F;md5进行了一点点自定义的改造。</span><br><span class="line">  sub_9068((int)&amp;v7, (int)&quot;imyang&quot;, 6u);</span><br><span class="line">  sub_9068((int)&amp;v7, input_1, cnt_1);</span><br><span class="line">  sub_9810(output_1, &amp;v7);    &#x2F;&#x2F;最后这里进行计算的结果。这里也需要hook查一下</span><br><span class="line">  return _stack_chk_guard - v13;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们搜索了一下常量。发现这个hash算法就是MD5。然后看到这里不单单对我们输入的值进行了md5.前面还自定义了两个值。所以我们验证一下猜想</p><p><img src="/2021/01/07/zuoye2/image-20210107231632946.png" alt="image-20210107231632946"></p><p>对比前面hook到的数据结果。是正确的了。第五题搞定</p><p>==================================================================================</p><p>第六题algorithmbase_31.apk</p><p>先hook打印下输入和结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input: AGBfqjdHpbyRcUzqkLSLsaWVdNA output: 53bc4172d9b48d1e41414044b0cc67c7</span><br></pre></td></tr></table></figure><p>然后ida分析之后发现。这个和第五题基本差不多。直接看那个关键函数即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">sub_98B0</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// r10</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// r9</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// r8</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [sp+4h] [bp-74h]</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// [sp+8h] [bp-70h]</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// [sp+Ch] [bp-6Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// [sp+10h] [bp-68h]</span></span><br><span class="line">  <span class="keyword">int</span> v11; <span class="comment">// [sp+14h] [bp-64h]</span></span><br><span class="line">  <span class="keyword">int</span> v12; <span class="comment">// [sp+18h] [bp-60h]</span></span><br><span class="line">  <span class="keyword">int</span> v13; <span class="comment">// [sp+5Ch] [bp-1Ch]</span></span><br><span class="line"></span><br><span class="line">  v3 = a1;</span><br><span class="line">  v4 = a2;</span><br><span class="line">  v5 = a3;</span><br><span class="line">  v11 = <span class="number">0</span>;</span><br><span class="line">  v12 = <span class="number">0</span>;</span><br><span class="line">  v9 = <span class="number">0xBA98FEDC</span>;</span><br><span class="line">  v10 = <span class="number">0x32107654</span>;</span><br><span class="line">  v7 = <span class="number">0x45670123</span>;</span><br><span class="line">  v8 = <span class="number">0xCDEF89AB</span>;</span><br><span class="line">  sub_9068(&amp;v7, <span class="string">&quot;kanxue&quot;</span>, <span class="number">6</span>);</span><br><span class="line">  sub_9068(&amp;v7, <span class="string">&quot;imyang&quot;</span>, <span class="number">6</span>);</span><br><span class="line">  sub_9068(&amp;v7, v3, v4);</span><br><span class="line">  sub_9810(v5, &amp;v7);</span><br><span class="line">  <span class="keyword">return</span> _stack_chk_guard - v13;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比之前MD5的那个算法。v9,v10,v7,v8发生了变化。其实这个应该算是MD5的key。下面是之前第五题的key。我们hook函数sub_9068的第一个参数就可以知道key是多少了。我们再hook下。看看现在的key是多少了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_native</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> base_addr=Module.getBaseAddress(<span class="string">&quot;libnative-lib.so&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> sub_9068=base_addr.add(<span class="number">0x9068</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;sub_9068:&quot;</span>,sub_9068)</span><br><span class="line">    Interceptor.attach(sub_9068,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;========onenter sub_9068========&quot;</span>)</span><br><span class="line">            <span class="built_in">this</span>.arg0=args[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">console</span>.log(hexdump(<span class="built_in">this</span>.arg0,&#123;<span class="attr">length</span>:<span class="number">0x10</span>&#125;))</span><br><span class="line">        &#125;,<span class="attr">onLeave</span>:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;========onleave sub_9068========&quot;</span>)</span><br><span class="line">            <span class="built_in">console</span>.log(hexdump(<span class="built_in">this</span>.arg0,&#123;<span class="attr">length</span>:<span class="number">0x10</span>&#125;))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_java</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> native_lib=Java.use(<span class="string">&quot;com.kanxue.algorithmbase.MainActivity&quot;</span>);</span><br><span class="line">        native_lib.encodeFromJni_31.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">input</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> res=<span class="built_in">this</span>.encodeFromJni_31(input);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;input:&quot;</span>,input,<span class="string">&quot;output:&quot;</span>,res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    hook_java();</span><br><span class="line">    hook_native();</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;onenter sub_9068&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">ff87d25c  23 01 67 45 ab 89 ef cd dc fe 98 ba 54 76 10 32  #.gE........Tv.2</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;onleave sub_9068&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">ff87d25c  23 01 67 45 ab 89 ef cd dc fe 98 ba 54 76 10 32  #.gE........Tv.2</span><br><span class="line">input: hgxSclQVesPCYKSnUMdOtnHLaLNS output: 9954c813aa188229945e49f866d37833</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来就是实现一下MD5函数。并且修改key再测试下。由于MD5有很多人实现的。我就不自己啃了。直接找github上面一个人家实现好的。然后我们改改那个key来测试一下就好了。这里贴上我找的例子<a href="https://github.com/JieweiWei/md5.git">https://github.com/JieweiWei/md5.git</a></p><p>然后看看我们关键要改的地方</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">MD5::MD5(<span class="keyword">const</span> <span class="built_in">string</span>&amp; message) &#123;</span><br><span class="line">  finished = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">/* Reset number of bits. */</span></span><br><span class="line">  count[<span class="number">0</span>] = count[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* Initialization constants. */</span></span><br><span class="line"><span class="comment">//  state[0] = 0x67452301;</span></span><br><span class="line"><span class="comment">//  state[1] = 0xefcdab89;</span></span><br><span class="line"><span class="comment">//  state[2] = 0x98badcfe;</span></span><br><span class="line"><span class="comment">//  state[3] = 0x10325476;</span></span><br><span class="line">    state[<span class="number">0</span>] = <span class="number">0x45670123</span>;</span><br><span class="line">    state[<span class="number">1</span>] = <span class="number">0xCDEF89AB</span>;</span><br><span class="line">    state[<span class="number">2</span>] = <span class="number">0xBA98FEDC</span>;</span><br><span class="line">    state[<span class="number">3</span>] = <span class="number">0x32107654</span>;</span><br><span class="line">  <span class="comment">/* Initialization the object according to message. */</span></span><br><span class="line">  init((<span class="keyword">const</span> <span class="keyword">byte</span>*)message.c_str(), message.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后贴上我调用的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;md5.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMD5</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; message)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;md5(\&quot;&quot;</span> &lt;&lt; message &lt;&lt; <span class="string">&quot;\&quot;) = &quot;</span></span><br><span class="line">         &lt;&lt; MD5(message).toStr() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* input=<span class="string">&quot;kanxueimyangAGBfqjdHpbyRcUzqkLSLsaWVdNA&quot;</span>;</span><br><span class="line">    printMD5(input);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5(&quot;kanxueimyangAGBfqjdHpbyRcUzqkLSLsaWVdNA&quot;) &#x3D; 53bc4172d9b48d1e41414044b0cc67c7</span><br></pre></td></tr></table></figure><p>第六题就完成了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>还原算法实战</title>
      <link href="/2021/01/05/zuoye1/"/>
      <url>/2021/01/05/zuoye1/</url>
      
        <content type="html"><![CDATA[<p>练习第一题的algorithmbase_10.apk连接如下</p><p>链接: <a href="https://pan.baidu.com/s/1hUyNDzd0VDzqD16X_IhiPg">https://pan.baidu.com/s/1hUyNDzd0VDzqD16X_IhiPg</a>  密码: ocg5</p><p>首先用jadx打开目标应用。看到下面的代码</p><p><img src="/2021/01/05/zuoye1/image-20210105204400773.png" alt="image-20210105204400773"></p><p>看到我们需要还原算法的函数是encodeFromJni_10。参数是随机16个ascii字符。接下来用ida打开libnative-jni.so。找到我们的目标函数。然后修改第一个参数的类型为JNIEnv*，然后把第三个参数的名称修改成input。最后把F5的代码贴到下面</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">Java_com_kanxue_algorithmbase_MainActivity_encodeFromJni_110</span><span class="params">(JNIEnv *a1, __int64 a2, __int64 input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// x22</span></span><br><span class="line">  <span class="keyword">void</span> *input_1; <span class="comment">// x20</span></span><br><span class="line">  JNIEnv *v5; <span class="comment">// x19</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *input_2; <span class="comment">// x21</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// w0</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// w0</span></span><br><span class="line">  _BOOL4 v9; <span class="comment">// w8</span></span><br><span class="line">  _BYTE *v10; <span class="comment">// x0</span></span><br><span class="line">  <span class="keyword">char</span> *v11; <span class="comment">// x1</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v12; <span class="comment">// w2</span></span><br><span class="line">  <span class="keyword">char</span> *output; <span class="comment">// x1</span></span><br><span class="line">  __int64 v14; <span class="comment">// [xsp+8h] [xbp-58h]</span></span><br><span class="line">  __int64 v15; <span class="comment">// [xsp+10h] [xbp-50h]</span></span><br><span class="line">  <span class="keyword">void</span> *v16; <span class="comment">// [xsp+18h] [xbp-48h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v17; <span class="comment">// [xsp+20h] [xbp-40h]</span></span><br><span class="line">  <span class="keyword">int</span> v18; <span class="comment">// [xsp+28h] [xbp-38h]</span></span><br><span class="line">  <span class="keyword">void</span> *v19; <span class="comment">// [xsp+30h] [xbp-30h]</span></span><br><span class="line">  __int64 v20; <span class="comment">// [xsp+38h] [xbp-28h]</span></span><br><span class="line"></span><br><span class="line">  v3 = _ReadStatusReg(ARM64_SYSREG(<span class="number">3</span>, <span class="number">3</span>, <span class="number">13</span>, <span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">  input_1 = (<span class="keyword">void</span> *)input;</span><br><span class="line">  v20 = *(_QWORD *)(v3 + <span class="number">40</span>);</span><br><span class="line">  v5 = a1;</span><br><span class="line">  input_2 = (*a1)-&gt;GetStringUTFChars(a1, (jstring)input, <span class="number">0L</span>L);</span><br><span class="line">  sub_E968(&amp;v17, (__int64)input_2);</span><br><span class="line">  (*v5)-&gt;ReleaseStringUTFChars(v5, input_1, input_2);</span><br><span class="line">  <span class="keyword">if</span> ( v17 &amp; <span class="number">1</span> )</span><br><span class="line">    v7 = v18;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    v7 = (<span class="keyword">unsigned</span> __int64)(<span class="keyword">unsigned</span> __int8)v17 &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  v8 = sub_EE10(v7);</span><br><span class="line">  v15 = <span class="number">0L</span>L;</span><br><span class="line">  v16 = <span class="number">0L</span>L;</span><br><span class="line">  v14 = <span class="number">0L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( v8 )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_EA94(&amp;v14, v8, <span class="number">0</span>);</span><br><span class="line">    v9 = (v14 &amp; <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v9 = <span class="number">1</span>;</span><br><span class="line">    LOWORD(v14) = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v9 )</span><br><span class="line">    v10 = (<span class="keyword">char</span> *)&amp;v14 + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    v10 = v16;</span><br><span class="line">  <span class="keyword">if</span> ( v17 &amp; <span class="number">1</span> )</span><br><span class="line">    v11 = (<span class="keyword">char</span> *)v19;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    v11 = (<span class="keyword">char</span> *)&amp;v17 + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v17 &amp; <span class="number">1</span> )</span><br><span class="line">    v12 = v18;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    v12 = (<span class="keyword">unsigned</span> __int64)(<span class="keyword">unsigned</span> __int8)v17 &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  sub_EE38(v10, (__int64)v11, v12);</span><br><span class="line">  <span class="keyword">if</span> ( v14 &amp; <span class="number">1</span> )</span><br><span class="line">    output = (<span class="keyword">char</span> *)v16;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    output = (<span class="keyword">char</span> *)&amp;v14 + <span class="number">1</span>;</span><br><span class="line">  ((<span class="keyword">void</span> (__fastcall *)(JNIEnv *, <span class="keyword">char</span> *))(*v5)-&gt;NewStringUTF)(v5, output);</span><br><span class="line">  <span class="keyword">if</span> ( v14 &amp; <span class="number">1</span> )</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(v16)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> ( v17 &amp; <span class="number">1</span> )</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(v19)</span></span>;</span><br><span class="line">  *(_QWORD *)(v3 + <span class="number">40</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以从参数的一步步传递、返回值的向上回溯这两个方式来进行分析。</p><p>我先从返回值开始向上查。打开最后和返回值output相关的函数sub_EE38。发现了一些熟悉的东西</p><p><img src="/2021/01/05/zuoye1/image-20210105211902397.png" alt="image-20210105211902397"></p><p>点进aAbcdefghijklmn数组里面看看是什么</p><p><img src="/2021/01/05/zuoye1/image-20210105212007265.png" alt="image-20210105212007265"></p><p>说明这里可能是一个base64.我们用frida来hook一下encodeFromJni_10这个函数的参数和返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_java</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> native_lib=Java.use(<span class="string">&quot;com.kanxue.algorithmbase.MainActivity&quot;</span>);</span><br><span class="line">        native_lib.encodeFromJni_10.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">input</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> res=<span class="built_in">this</span>.encodeFromJni_10(input);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;input:&quot;</span>,input,<span class="string">&quot;output:&quot;</span>,res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    hook_java();</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></table></figure><p>然后看看输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input: 2vOHn\n(boFhN|_T output: MnZPSG5cbihib0ZoTnxfVA&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><p>猜测是对参数进行了base64的处理。然后直接拿input值进行base64处理后对比下结果</p><p><img src="/2021/01/05/zuoye1/image-20210105212532999.png" alt="image-20210105212532999"></p><p>对比输出结果是一致的。那么第一题的结果就是直接base64加密。</p><p>=====================================================================================================================</p><p>练习第一题的algorithmbase_11.apk连接如下</p><p>链接: <a href="https://pan.baidu.com/s/1_XqSzUqHfRxSBnU0Ddzlog">https://pan.baidu.com/s/1_XqSzUqHfRxSBnU0Ddzlog</a>  密码: u37v</p><p>第一步同样是jadx打开分析一下。然后看到的代码基本一致。不过这个是用的encodeFromJni_11函数。然后继续ida打开分析。然后用frida再hook看到参数和返回值如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input: i17gs-B[4hbzg@-l output: Kjbw1wBqg+ptKG0Q1tAqLA&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><p>然后我们再用工具对input进行base64加密后。发现和返回值不一样了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input: i17gs-B[4hbzg@-l base64: aTE3Z3MtQls0aGJ6Z0AtbA&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><p>接下来。我们从返回值开始分析。先将sub_EE38这个函数进行hook</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_native</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> base_addr=Module.getBaseAddress(<span class="string">&quot;libnative-lib.so&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> sub_EE38=base_addr.add(<span class="number">0xEE38</span>);</span><br><span class="line">    Interceptor.attach(sub_EE38,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.arg0=args[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;========onenter========&quot;</span>)</span><br><span class="line">            <span class="built_in">console</span>.log(args[<span class="number">1</span>].readCString());</span><br><span class="line">            <span class="built_in">console</span>.log(args[<span class="number">2</span>]);</span><br><span class="line">        &#125;,<span class="attr">onLeave</span>:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;========onleave========&quot;</span>)</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.arg0.readCString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_java</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> native_lib=Java.use(<span class="string">&quot;com.kanxue.algorithmbase.MainActivity&quot;</span>);</span><br><span class="line">        native_lib.encodeFromJni_11.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">input</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> res=<span class="built_in">this</span>.encodeFromJni_11(input);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;input:&quot;</span>,input,<span class="string">&quot;output:&quot;</span>,res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    hook_java();</span><br><span class="line">    hook_native();</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></table></figure><p>然后点击check后得到下面的日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;onenter&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Wyi&quot;:?fq&gt;Dd!xA6z</span><br><span class="line">0x10</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;onleave&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">lw+Xz8W41VbyhGg6TbbvT5&#x3D;&#x3D;</span><br><span class="line">input: Wyi&quot;:?fq&gt;Dd!xA6z output: lw+Xz8W41VbyhGg6TbbvT5&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><p>说明这个函数就是关键的函数了。然后我们分析里面是如何计算出来。首先根据我们上面得到的数据。知道了三个参数是什么，然后进行重命名。我把新的代码贴下面</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_EE38</span><span class="params">(_BYTE *output, __int64 input, <span class="keyword">signed</span> <span class="keyword">int</span> data_10)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 v3; <span class="comment">// x9</span></span><br><span class="line">  _BYTE *v4; <span class="comment">// x12</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 *v5; <span class="comment">// x10</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v6; <span class="comment">// x13</span></span><br><span class="line">  _BYTE *v7; <span class="comment">// x10</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v8; <span class="comment">// x11</span></span><br><span class="line">  <span class="keyword">char</span> v9; <span class="comment">// w8</span></span><br><span class="line">  __int64 v10; <span class="comment">// x9</span></span><br><span class="line">  __int64 result; <span class="comment">// x0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( data_10 - <span class="number">2</span> &lt; <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    LODWORD(v3) = <span class="number">0</span>;</span><br><span class="line">    v7 = output;</span><br><span class="line">    <span class="keyword">if</span> ( data_10 &lt;= <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_11;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v3 = <span class="number">0L</span>L;</span><br><span class="line">    v4 = output;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v5 = (input + v3);</span><br><span class="line">      v6 = *(input + v3);</span><br><span class="line">      v3 += <span class="number">3L</span>L;</span><br><span class="line">      *v4 = aAyzabfghz0cmbd[v6 &gt;&gt; <span class="number">2</span>];</span><br><span class="line">      v4[<span class="number">1</span>] = aAyzabfghz0cmbd[<span class="number">16</span> * *v5 &amp; <span class="number">0x30</span>LL | (v5[<span class="number">1</span>] &gt;&gt; <span class="number">4</span>)];</span><br><span class="line">      v4[<span class="number">2</span>] = aAyzabfghz0cmbd[<span class="number">4</span> * v5[<span class="number">1</span>] &amp; <span class="number">0x3C</span>LL | (v5[<span class="number">2</span>] &gt;&gt; <span class="number">6</span>)];</span><br><span class="line">      LOBYTE(v6) = aAyzabfghz0cmbd[v5[<span class="number">2</span>] &amp; <span class="number">0x3F</span>];</span><br><span class="line">      v7 = v4 + <span class="number">4</span>;</span><br><span class="line">      v4[<span class="number">3</span>] = v6;</span><br><span class="line">      v4 += <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v3 &lt; data_10 - <span class="number">2</span> );</span><br><span class="line">    <span class="keyword">if</span> ( v3 &gt;= data_10 )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_11;</span><br><span class="line">  &#125;</span><br><span class="line">  *v7 = aAyzabfghz0cmbd[*(input + v3) &gt;&gt; <span class="number">2</span>];</span><br><span class="line">  v8 = <span class="number">16</span> * *(input + v3) &amp; <span class="number">0x30</span>LL;</span><br><span class="line">  <span class="keyword">if</span> ( v3 == data_10 - <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v7[<span class="number">1</span>] = aAyzabfghz0cmbd[v8];</span><br><span class="line">    v9 = <span class="number">61</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v10 = input + v3;</span><br><span class="line">    v7[<span class="number">1</span>] = aAyzabfghz0cmbd[v8 | (*(v10 + <span class="number">1</span>) &gt;&gt; <span class="number">4</span>)];</span><br><span class="line">    v9 = aAyzabfghz0cmbd[<span class="number">4</span> * *(v10 + <span class="number">1</span>) &amp; <span class="number">0x3C</span>LL];</span><br><span class="line">  &#125;</span><br><span class="line">  v7[<span class="number">2</span>] = v9;</span><br><span class="line">  v7[<span class="number">3</span>] = <span class="number">61</span>;</span><br><span class="line">  v7 += <span class="number">4</span>;</span><br><span class="line">LABEL_11:</span><br><span class="line">  result = (v7 - output + <span class="number">1</span>);</span><br><span class="line">  *v7 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面那段可以看到之前分析的是base64.然后由于第三个参数我们hook知道了值。所以分析一下就可以知道必然是走以下的代码来进行加密的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">index = <span class="number">0L</span>L;</span><br><span class="line">output_1 = output;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">  v5 = (input + index);</span><br><span class="line">  v6 = *(input + index);</span><br><span class="line">  index += <span class="number">3L</span>L;</span><br><span class="line">  *output_1 = aAyzabfghz0cmbd[v6 &gt;&gt; <span class="number">2</span>];</span><br><span class="line">  output_1[<span class="number">1</span>] = aAyzabfghz0cmbd[<span class="number">16</span> * *v5 &amp; <span class="number">0x30</span>LL | (v5[<span class="number">1</span>] &gt;&gt; <span class="number">4</span>)];</span><br><span class="line">  output_1[<span class="number">2</span>] = aAyzabfghz0cmbd[<span class="number">4</span> * v5[<span class="number">1</span>] &amp; <span class="number">0x3C</span>LL | (v5[<span class="number">2</span>] &gt;&gt; <span class="number">6</span>)];</span><br><span class="line">  LOBYTE(v6) = aAyzabfghz0cmbd[v5[<span class="number">2</span>] &amp; <span class="number">0x3F</span>];</span><br><span class="line">  v7 = output_1 + <span class="number">4</span>;</span><br><span class="line">  output_1[<span class="number">3</span>] = v6;</span><br><span class="line">  output_1 += <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ( index &lt; data_10 - <span class="number">2</span> );</span><br><span class="line"><span class="keyword">if</span> ( index &gt;= data_10 )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_11;</span><br></pre></td></tr></table></figure><p>然后对照逻辑写个py版本的加密</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">idx=<span class="number">0</span></span><br><span class="line">data=<span class="number">10</span></span><br><span class="line">input=<span class="string">&quot;&quot;&quot;Wyi&quot;:?fq&gt;Dd!xA6z&quot;&quot;&quot;</span></span><br><span class="line">input_bytes=bytes(input,<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">bkey=<span class="string">&quot;AYZabFGHz0cmBdefghijklCDE1KLMNTU56789+/VWXnopq23IJrstuvwOPQRSxy4&quot;</span></span><br><span class="line">output=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    v5 = input_bytes[idx]</span><br><span class="line">    v5_1 = input_bytes[idx+<span class="number">1</span>]</span><br><span class="line">    v5_2 = input_bytes[idx + <span class="number">2</span>]</span><br><span class="line">    print(input_bytes[idx])</span><br><span class="line">    v6 = input_bytes[idx]</span><br><span class="line">    idx += <span class="number">3</span></span><br><span class="line">    output += bkey[v6 &gt;&gt; <span class="number">2</span>]</span><br><span class="line">    output += bkey[<span class="number">16</span> * v5 &amp; <span class="number">0x30</span> | (v5_1 &gt;&gt; <span class="number">4</span>)]</span><br><span class="line">    output += bkey[<span class="number">4</span> * v5_1 &amp; <span class="number">0x3C</span> | (v5_2 &gt;&gt; <span class="number">6</span>)]</span><br><span class="line">    v6 = bkey[v5_2 &amp; <span class="number">0x3f</span>]</span><br><span class="line">    output += v6</span><br><span class="line">    <span class="keyword">if</span> idx &gt; data<span class="number">-2</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">print(output)</span><br><span class="line">print(idx)</span><br></pre></td></tr></table></figure><p>写到这里之后计算一下看看结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lw+Xz8W41Vby</span><br><span class="line">9</span><br></pre></td></tr></table></figure><p>对比ida上的逻辑发现并不符合结束的判断。这里的结果是9.所以还得继续往后执行。并且前面部分的计算已经和我们的输出结果一致了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( index &gt;= data_10 )</span><br></pre></td></tr></table></figure><p>继续把后面的代码贴一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">*v7 = aAyzabfghz0cmbd[*(input + v3) &gt;&gt; <span class="number">2</span>];</span><br><span class="line">  v8 = <span class="number">16</span> * *(input + v3) &amp; <span class="number">0x30</span>LL;</span><br><span class="line">  <span class="keyword">if</span> ( v3 == data_10 - <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v7[<span class="number">1</span>] = aAyzabfghz0cmbd[v8];</span><br><span class="line">    v9 = <span class="number">61</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v10 = input + v3;</span><br><span class="line">    v7[<span class="number">1</span>] = aAyzabfghz0cmbd[v8 | (*(v10 + <span class="number">1</span>) &gt;&gt; <span class="number">4</span>)];</span><br><span class="line">    v9 = aAyzabfghz0cmbd[<span class="number">4</span> * *(v10 + <span class="number">1</span>) &amp; <span class="number">0x3C</span>LL];</span><br><span class="line">  &#125;</span><br><span class="line">  v7[<span class="number">2</span>] = v9;</span><br><span class="line">  v7[<span class="number">3</span>] = <span class="number">61</span>;</span><br><span class="line">  v7 += <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>然后继续再完善下py的模拟代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">idx=<span class="number">0</span></span><br><span class="line">data=<span class="number">10</span></span><br><span class="line">input=<span class="string">&quot;&quot;&quot;Wyi&quot;:?fq&gt;Dd!xA6z&quot;&quot;&quot;</span></span><br><span class="line">input_bytes=bytes(input,<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">bkey=<span class="string">&quot;AYZabFGHz0cmBdefghijklCDE1KLMNTU56789+/VWXnopq23IJrstuvwOPQRSxy4&quot;</span></span><br><span class="line">output=<span class="string">&quot;&quot;</span></span><br><span class="line">v7=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    v5 = input_bytes[idx]</span><br><span class="line">    v5_1 = input_bytes[idx+<span class="number">1</span>]</span><br><span class="line">    v5_2 = input_bytes[idx + <span class="number">2</span>]</span><br><span class="line">    v6 = input_bytes[idx]</span><br><span class="line">    idx += <span class="number">3</span></span><br><span class="line">    v7 += <span class="number">4</span></span><br><span class="line">    output += bkey[v6 &gt;&gt; <span class="number">2</span>]</span><br><span class="line">    output += bkey[<span class="number">16</span> * v5 &amp; <span class="number">0x30</span> | (v5_1 &gt;&gt; <span class="number">4</span>)]</span><br><span class="line">    output += bkey[<span class="number">4</span> * v5_1 &amp; <span class="number">0x3C</span> | (v5_2 &gt;&gt; <span class="number">6</span>)]</span><br><span class="line">    v6 = bkey[v5_2 &amp; <span class="number">0x3f</span>]</span><br><span class="line">    output += v6</span><br><span class="line">    <span class="keyword">if</span> idx &gt; data+<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">output+=bkey[input_bytes[idx]&gt;&gt;<span class="number">2</span>]</span><br><span class="line">v8 = <span class="number">16</span> * input_bytes[idx] &amp; <span class="number">0x30</span></span><br><span class="line"><span class="keyword">if</span> idx &gt; data - <span class="number">1</span>:</span><br><span class="line">    output += bkey[v8]</span><br><span class="line">    v9 = <span class="string">&#x27;=&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    output += bkey[v8 | (input_bytes[idx+<span class="number">1</span>]&gt;&gt; <span class="number">4</span>)]</span><br><span class="line">    v9 = bkey[<span class="number">4</span> * input_bytes[idx+<span class="number">1</span>] &amp; <span class="number">0x3C</span>]</span><br><span class="line">output += v9</span><br><span class="line">output += <span class="string">&#x27;=&#x27;</span></span><br><span class="line">print(output)</span><br></pre></td></tr></table></figure><p>最后输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lw+Xz8W41VbyhGg6TbbvT5&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><p>到这里第二题就搞定了。</p><p>=====================================================================================================================</p><p>第三题algorithmbase_12.apk</p><p>链接: <a href="https://pan.baidu.com/s/1imjPHj7eSnBUJmWWeB3NKQ">https://pan.baidu.com/s/1imjPHj7eSnBUJmWWeB3NKQ</a>  密码: 9bk2</p><p>同样用frida来hook看下结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_java</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> native_lib=Java.use(<span class="string">&quot;com.kanxue.algorithmbase.MainActivity&quot;</span>);</span><br><span class="line">        native_lib.encodeFromJni_12.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">input</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> res=<span class="built_in">this</span>.encodeFromJni_12(input);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;input:&quot;</span>,input,<span class="string">&quot;output:&quot;</span>,res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    hook_java();</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input: 5Ki*$:&amp;xh.!u4&#123;|[mAR*a^x&quot;yK5 output: |_zxO-qJia.+]-)C|RzH*uCB_-x.PaN-h_lC</span><br></pre></td></tr></table></figure><p>ida分析同样是从返回值向上回溯。找到第一个相关函数sub_8B04进行hook。下面贴上代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_native</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> base_addr=Module.getBaseAddress(<span class="string">&quot;libnative-lib.so&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> sub_8B04=base_addr.add(<span class="number">0x8B04</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;sub_8b04:&quot;</span>,sub_8B04)</span><br><span class="line">    Interceptor.attach(sub_8B04,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;========onenter========&quot;</span>)</span><br><span class="line">            <span class="built_in">this</span>.arg0=args[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">console</span>.log(args[<span class="number">1</span>].readCString());</span><br><span class="line">            <span class="built_in">console</span>.log(args[<span class="number">2</span>]);</span><br><span class="line">        &#125;,<span class="attr">onLeave</span>:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;========onleave========&quot;</span>)</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.arg0.readCString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_java</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> native_lib=Java.use(<span class="string">&quot;com.kanxue.algorithmbase.MainActivity&quot;</span>);</span><br><span class="line">        native_lib.encodeFromJni_12.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">input</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> res=<span class="built_in">this</span>.encodeFromJni_12(input);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;input:&quot;</span>,input,<span class="string">&quot;output:&quot;</span>,res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    hook_java();</span><br><span class="line">    hook_native();</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;onenter&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">3ez|q|z\8QzIU]&#125;&#96;bM ZMlJ]</span><br><span class="line">0x18</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;onleave&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">~v]IlQ*Kk_!W\S&#123;j]]@&#96;T+jR*&#123;Zi&#123;&#125;</span><br><span class="line">input: 3ez|q|z\8QzIU]&#125;&#96;bM ZMlJ] output: ~v]IlQ*Kk_!W\S&#123;j]]@&#96;T+jR*&#123;Zi&#123;&#125;</span><br></pre></td></tr></table></figure><p>对比输出结果。看出加密位置确实也还是这里。接下来贴上里面的加密逻辑</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">data_0x16 = data_0x18 - <span class="number">2</span>;</span><br><span class="line">  data_0x18_1 = data_0x18;</span><br><span class="line">  output_1 = output;</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = (_BYTE *)(output_1 + v6);</span><br><span class="line">    <span class="keyword">if</span> ( v7 &gt;= data_0x16 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v9 = input + v7;</span><br><span class="line">    v6 += <span class="number">4</span>;</span><br><span class="line">    *v8 = aAyzpq23ijrtffg[(<span class="keyword">unsigned</span> <span class="keyword">int</span>)*(<span class="keyword">unsigned</span> __int8 *)(input + v7) &gt;&gt; <span class="number">2</span>];</span><br><span class="line">    v10 = *(<span class="keyword">unsigned</span> __int8 *)(input + v7 + <span class="number">1</span>);</span><br><span class="line">    v11 = *(_BYTE *)(input + v7);</span><br><span class="line">    v7 += <span class="number">3</span>;</span><br><span class="line">    v8[<span class="number">1</span>] = aAyzpq23ijrtffg[(v10 &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xFFFFFFCF</span> | <span class="number">16</span> * (v11 &amp; <span class="number">3</span>)];</span><br><span class="line">    v8[<span class="number">2</span>] = aAyzpq23ijrtffg[((<span class="keyword">unsigned</span> <span class="keyword">int</span>)*(<span class="keyword">unsigned</span> __int8 *)(v9 + <span class="number">2</span>) &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0xFFFFFFC3</span> | <span class="number">4</span></span><br><span class="line">                                                                                           * (*(_BYTE *)(v9 + <span class="number">1</span>) &amp; <span class="number">0xF</span>)];</span><br><span class="line">    v8[<span class="number">3</span>] = aAyzpq23ijrtffg[*(_BYTE *)(v9 + <span class="number">2</span>) &amp; <span class="number">0x3F</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v7 &lt; data_0x18_1 )</span><br><span class="line">  &#123;</span><br><span class="line">    *v8 = aAyzpq23ijrtffg[(<span class="keyword">unsigned</span> <span class="keyword">int</span>)*(<span class="keyword">unsigned</span> __int8 *)(input + v7) &gt;&gt; <span class="number">2</span>];</span><br><span class="line">    v12 = <span class="number">16</span> * *(<span class="keyword">unsigned</span> __int8 *)(input + v7) &amp; <span class="number">0x30</span>;</span><br><span class="line">    <span class="keyword">if</span> ( data_0x18_1 - <span class="number">1</span> == v7 )</span><br><span class="line">    &#123;</span><br><span class="line">      v13 = <span class="number">61</span>;</span><br><span class="line">      v8[<span class="number">1</span>] = aAyzpq23ijrtffg[v12];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v8[<span class="number">1</span>] = aAyzpq23ijrtffg[v12 | ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)*(<span class="keyword">unsigned</span> __int8 *)(input + v7 + <span class="number">1</span>) &gt;&gt; <span class="number">4</span>)];</span><br><span class="line">      v13 = aAyzpq23ijrtffg[<span class="number">4</span> * (*(_BYTE *)(input + v7 + <span class="number">1</span>) &amp; <span class="number">0xF</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">    v8[<span class="number">3</span>] = <span class="number">61</span>;</span><br><span class="line">    v8[<span class="number">2</span>] = v13;</span><br><span class="line">    v8 += <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *v8 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">int</span>)&amp;v8[-output_1 + <span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>aAyzpq23ijrtffg这个数组静态分析的时候是没有特殊字符的。实际上是有动态的对其进行赋值的。修改下frida脚本。将其打印一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">function hook_native()&#123;</span><br><span class="line">    var base_addr=Module.getBaseAddress(<span class="string">&quot;libnative-lib.so&quot;</span>);</span><br><span class="line">    var sub_8B04=base_addr.add(<span class="number">0x8B04</span>+<span class="number">1</span>);</span><br><span class="line">    Interceptor.attach(sub_8B04,&#123;</span><br><span class="line">        onEnter:function(args)&#123;</span><br><span class="line">            console.log(<span class="string">&quot;========onenter========&quot;</span>)</span><br><span class="line">            this.arg0=args[<span class="number">0</span>];</span><br><span class="line">            console.log(<span class="string">&quot;input:&quot;</span>,args[<span class="number">1</span>].readCString());</span><br><span class="line">            console.log(args[<span class="number">2</span>]);</span><br><span class="line">            //<span class="number">0001</span>B000</span><br><span class="line">            var dump_addr=base_addr.add(<span class="number">0x0001B000</span>);</span><br><span class="line">            console.log(<span class="string">&quot;aAyzpq23ijrtffg sub_8B04:&quot;</span>,dump_addr.readCString())</span><br><span class="line">        &#125;,onLeave:function(retval)&#123;</span><br><span class="line">            console.log(<span class="string">&quot;========onleave========&quot;</span>)</span><br><span class="line">            console.log(<span class="string">&quot;output:&quot;</span>,this.arg0.readCString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    var sub_8ABC=base_addr.add(<span class="number">0x8ABC</span>+<span class="number">1</span>);</span><br><span class="line">    Interceptor.attach(sub_8ABC,&#123;</span><br><span class="line">        onEnter:function(args)&#123;</span><br><span class="line">            var dump_addr=base_addr.add(<span class="number">0x0001B000</span>);</span><br><span class="line">            console.log(<span class="string">&quot;aAyzpq23ijrtffg sub_8ABC enter:&quot;</span>,dump_addr.readCString())</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:function(retval)&#123;</span><br><span class="line">            var dump_addr=base_addr.add(<span class="number">0x0001B000</span>);</span><br><span class="line">            console.log(<span class="string">&quot;aAyzpq23ijrtffg sub_8ABC leave:&quot;</span>,dump_addr.readCString())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    var encode= Module.getExportByName(<span class="string">&quot;libnative-lib.so&quot;</span>,<span class="string">&quot;Java_com_kanxue_algorithmbase_MainActivity_encodeFromJni_112&quot;</span>);</span><br><span class="line">    Interceptor.attach(encode,&#123;</span><br><span class="line">        onEnter:function(args)&#123;</span><br><span class="line">            var dump_addr=base_addr.add(<span class="number">0x0001B000</span>);</span><br><span class="line">            console.log(<span class="string">&quot;aAyzpq23ijrtffg encode enter:&quot;</span>,dump_addr.readCString())</span><br><span class="line">        &#125;,onLeave:function(retval)&#123;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function hook_java()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var native_lib=Java.use(<span class="string">&quot;com.kanxue.algorithmbase.MainActivity&quot;</span>);</span><br><span class="line">        native_lib.encodeFromJni_12.implementation=function(input)&#123;</span><br><span class="line">            input=<span class="string">&quot;3ez|q|z\\8QzIU]&#125;`bM ZMlJ]&quot;</span></span><br><span class="line">            var res=this.encodeFromJni_12(input);</span><br><span class="line">            console.log(<span class="string">&quot;input:&quot;</span>,input,<span class="string">&quot;output:&quot;</span>,res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">function main()&#123;</span><br><span class="line">    hook_java();</span><br><span class="line">    hook_native();</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></table></figure><p>下面是输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">aAyzpq23ijrtffg encode enter: YABhi*+QRjL^~pqrst[\])STUuZ|&#125;klM-.&#x2F; _Pb(&#123;mnoyzV!37NO@vwWHIJK&#96;a,</span><br><span class="line">aAyzpq23ijrtffg sub_8ABC enter: YABhi*+QRjL^~pqrst[\])STUuZ|&#125;klM-.&#x2F; _Pb(&#123;mnoyzV!37NO@vwWHIJK&#96;a,</span><br><span class="line">aAyzpq23ijrtffg sub_8ABC leave: YABhi*+QRjL^~pqrst[\])STUuZ|&#125;klM-.&#x2F; _Pb(&#123;mnoyzV!37NO@vwWHIJK&#96;a,</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;onenter&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">input: 3ez|q|z\8QzIU]&#125;&#96;bM ZMlJ]</span><br><span class="line">0x18</span><br><span class="line">aAyzpq23ijrtffg sub_8B04: YABhi*+QRjL^~pqrst[\])STUuZ|&#125;klM-.&#x2F; _Pb(&#123;mnoyzV!37NO@vwWHIJK&#96;a,</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;onleave&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">output: ~v]IlQ*Kk_!W\S&#123;j]]@&#96;T+jR*&#123;Zi&#123;&#125;</span><br><span class="line">input: 3ez|q|z\8QzIU]&#125;&#96;bM ZMlJ] output: ~v]IlQ*Kk_!W\S&#123;j]]@&#96;T+jR*&#123;Zi&#123;&#125;</span><br></pre></td></tr></table></figure><p>这里可以看出aAyzpq23ijrtffg修改的时机似乎比较早。在调用加密前的时候这个数据就已经修改了。得到正确的key之后。再根据上面的c++代码写出下面的py模拟算法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">bkey=<span class="string">&quot;&quot;&quot;YABhi*+QRjL^~pqrst[\])STUuZ|&#125;klM-./ _Pb(&#123;mnoyzV!37NO@vwWHIJK`a,&quot;&quot;&quot;</span></span><br><span class="line">input=<span class="string">&quot;3ez|q|z\8QzIU]&#125;`bM ZMlJ]&quot;</span></span><br><span class="line">input_bytes=bytes(input,<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">output=<span class="string">&quot;&quot;</span></span><br><span class="line">cnt=len(input)</span><br><span class="line">precnt=cnt<span class="number">-2</span></span><br><span class="line">cnt1=cnt</span><br><span class="line">v6=<span class="number">0</span></span><br><span class="line">v7=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span> v7 &gt;= precnt:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    v9 = v7</span><br><span class="line">    v6 += <span class="number">4</span></span><br><span class="line">    output += bkey[input_bytes[v7] &gt;&gt; <span class="number">2</span>]</span><br><span class="line">    v10 = input_bytes[v7+<span class="number">1</span>]</span><br><span class="line">    v11 = input_bytes[v7]</span><br><span class="line">    v7 += <span class="number">3</span></span><br><span class="line">    output += bkey[(v10 &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xFFFFFFCF</span> | <span class="number">16</span> * (v11 &amp; <span class="number">3</span>)]</span><br><span class="line">    output += bkey[((input_bytes[v9+<span class="number">2</span>]&gt;&gt;<span class="number">0x6</span>) &amp; <span class="number">0xFFFFFFC3</span>) | (<span class="number">4</span> * (input_bytes[v9+<span class="number">1</span>] &amp; <span class="number">0xF</span>))]</span><br><span class="line">    output += bkey[input_bytes[v9+<span class="number">2</span>] &amp; <span class="number">0x3F</span>]</span><br><span class="line"><span class="keyword">if</span> v7 &lt; cnt1:</span><br><span class="line">    output += bkey[input_bytes[v7] &gt;&gt; <span class="number">2</span>]</span><br><span class="line">    v12 = <span class="number">16</span> * input_bytes[v7] &amp; <span class="number">0x30</span></span><br><span class="line">    <span class="keyword">if</span> cnt1 - <span class="number">1</span> == v7:</span><br><span class="line">      v13 = <span class="string">&#x27;=&#x27;</span></span><br><span class="line">      output +=  bkey[v12]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      output +=  bkey[v12 | (input_bytes[v7+<span class="number">1</span>] &gt;&gt; <span class="number">4</span>)]</span><br><span class="line">      v13 = bkey[<span class="number">4</span> * (input_bytes[v7+<span class="number">1</span>] &amp; <span class="number">0xF</span>)]</span><br><span class="line">    output += v13</span><br><span class="line">    output += <span class="string">&#x27;=&#x27;</span></span><br><span class="line">print(output)</span><br></pre></td></tr></table></figure><p>最后输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~v]IlQ*Kk_!W\S&#123;j]]@&#96;T+jR*&#123;Zi&#123;&#125;</span><br></pre></td></tr></table></figure><p>和那边的结果一致了。但是还需要继续排查那个key是如何转变过来的。因为每个不同的input。key都会发生变化。所以key应该是根据input来进行计算的。上面的hook脚本处理的sub_8ABC这个函数是看到非常疑似修改了这个bkey的函数。但是hook后发现好像不是。为了精确。我调整了一下hook脚本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_native</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> base_addr=Module.getBaseAddress(<span class="string">&quot;libnative-lib.so&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> sub_8B04=base_addr.add(<span class="number">0x8B04</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;sub_8b04:&quot;</span>,sub_8B04)</span><br><span class="line">    Interceptor.attach(sub_8B04,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;========onenter sub_8b04========&quot;</span>)</span><br><span class="line">            <span class="built_in">this</span>.arg0=args[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">console</span>.log(args[<span class="number">1</span>].readCString());</span><br><span class="line">            <span class="built_in">console</span>.log(args[<span class="number">2</span>]);</span><br><span class="line">        &#125;,<span class="attr">onLeave</span>:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;========onleave sub_8b04========&quot;</span>)</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.arg0.readCString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">var</span> sub_8ABC=base_addr.add(<span class="number">0x8ABC</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;sub_8ABC:&quot;</span>,sub_8ABC)</span><br><span class="line">    Interceptor.attach(sub_8ABC,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;========onenter sub_8ABC========&quot;</span>)</span><br><span class="line">            <span class="built_in">console</span>.log(args[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">var</span> dump_addr=base_addr.add(<span class="number">0x1B000</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;dump_addr:&quot;</span>,dump_addr.readCString());</span><br><span class="line">        &#125;,<span class="attr">onLeave</span>:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;========onleave sub_8ABC========&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> dump_addr=base_addr.add(<span class="number">0x1B000</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;dump_addr:&quot;</span>,dump_addr.readCString());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_init_so</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dlopen_ext=Module.getExportByName(<span class="literal">null</span>,<span class="string">&quot;android_dlopen_ext&quot;</span>);</span><br><span class="line">    Interceptor.attach(dlopen_ext,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> soname=ptr(args[<span class="number">0</span>]).readCString();</span><br><span class="line">            <span class="keyword">if</span>(soname.indexOf(<span class="string">&quot;libnative-lib.so&quot;</span>)!=<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">this</span>.hook_start=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="attr">onLeave</span>:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.hook_start)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;start hook&quot;</span>);</span><br><span class="line">                hook_native();</span><br><span class="line">                <span class="built_in">this</span>.hook_start=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_java</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> native_lib=Java.use(<span class="string">&quot;com.kanxue.algorithmbase.MainActivity&quot;</span>);</span><br><span class="line">        native_lib.encodeFromJni_12.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">input</span>)</span>&#123;</span><br><span class="line">            input=<span class="string">&quot;TjFJ,U.@IyVufb&#x27;X&#123;&quot;</span></span><br><span class="line">            <span class="keyword">var</span> res=<span class="built_in">this</span>.encodeFromJni_12(input);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;input:&quot;</span>,input,<span class="string">&quot;output:&quot;</span>,res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    hook_java();</span><br><span class="line">    hook_init_so();</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></table></figure><p>将时机调整为打开时就hook。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida -U --no-pause -f com.kanxue.algorithmbase -l lianxi2.js</span><br></pre></td></tr></table></figure><p>然后下面是触发时的输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sub_8b04: 0xd199bb05</span><br><span class="line">sub_8ABC: 0xd199babd</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;onenter sub_8ABC&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">0x11</span><br><span class="line">dump_addr: AYZpq23IJrTFfghijklCDE1KLMmBdestU5678GHz0cuvwabN9+&#x2F;VWXnoOPQRSxy4</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;onleave sub_8ABC&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">dump_addr: PHKa&#96;#&quot;X[cEWwvyx&#123;z&#125;RUT Z]\|SutbeD$&#39;&amp;)VYk!rdgfps_(:&gt;GFI~^A@CBih%</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;onenter sub_8b04&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">TjFJ,U.@IyVufb&#39;X&#123;</span><br><span class="line">0x11</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;onleave sub_8b04&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">T&quot;r&quot;&#125;&#39;:TW)HcbT\I\Y[k Xf&#x3D;</span><br><span class="line">input: TjFJ,U.@IyVufb&#39;X&#123; output: T&quot;r&quot;&#125;&#39;:TW)HcbT\I\Y[k Xf&#x3D;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看到这里就证明确实是这个在这个函数里面发生的变动。接着看这个函数的处理。并且发现sub_8ABC的入参和input的长度一致。最后我们参考下面的c++代码。修改成py的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">sub_8ABC</span><span class="params">(<span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// r8</span></span><br><span class="line">  <span class="keyword">size_t</span> i; <span class="comment">// r6</span></span><br><span class="line"></span><br><span class="line">  v1 = count;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(aAyzpq23ijrtffg); ++i )</span><br><span class="line">    aAyzpq23ijrtffg[i] = aAyzpq23ijrtffg_0[i] ^ v1;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">4</span> * sub_133E8(v1 + <span class="number">2</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面放上完整代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getKey</span>(<span class="params">cnt</span>):</span></span><br><span class="line">    bkey = <span class="string">&quot;AYZpq23IJrTFfghijklCDE1KLMmBdestU5678GHz0cuvwabN9+/VWXnoOPQRSxy4&quot;</span></span><br><span class="line">    bkey_bytes=bytes(bkey,<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    res=bytearray()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(bkey)):</span><br><span class="line">        res.append(bkey_bytes[i]^cnt)</span><br><span class="line">    <span class="keyword">return</span> res.decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">input=<span class="string">&quot;&quot;&quot;TjFJ,U.@IyVufb&#x27;X&#123;&quot;&quot;&quot;</span></span><br><span class="line">bkey=getKey(len(input))</span><br><span class="line"></span><br><span class="line">cnt=len(input)</span><br><span class="line">cntpre=cnt<span class="number">-2</span></span><br><span class="line">cnt1=cnt</span><br><span class="line">output=<span class="string">&quot;&quot;</span></span><br><span class="line">print(<span class="string">&quot;bkey:&quot;</span>+bkey)</span><br><span class="line">input_bytes=bytes(input,<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">v6=<span class="number">0</span></span><br><span class="line">v7=<span class="number">0</span></span><br><span class="line">idx=<span class="number">0</span></span><br><span class="line">print(input_bytes[<span class="number">0</span>])</span><br><span class="line">print(input_bytes[<span class="number">0</span>]&amp;<span class="number">0xffffffff</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    v8 = idx+v6</span><br><span class="line">    <span class="keyword">if</span> v7 &gt;= cntpre:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    v9 = v7</span><br><span class="line">    v6 += <span class="number">4</span></span><br><span class="line">    output+=bkey[input_bytes[v7] &gt;&gt; <span class="number">2</span>]</span><br><span class="line">    v10=input_bytes[v7+<span class="number">1</span>]</span><br><span class="line">    v11=input_bytes[v7]</span><br><span class="line">    v7+=<span class="number">3</span></span><br><span class="line">    output +=bkey[(v10 &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xFFFFFFCF</span> | <span class="number">16</span> * (v11 &amp; <span class="number">3</span>)]</span><br><span class="line">    output +=bkey[((input_bytes[v9 + <span class="number">2</span>] &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0xFFFFFFC3</span>) | (<span class="number">4</span> * (input_bytes[v9 + <span class="number">1</span>] &amp; <span class="number">0xF</span>))]</span><br><span class="line">    output +=bkey[(input_bytes[v9 + <span class="number">2</span>])&amp;<span class="number">0x3f</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> v7 &lt; cnt1 :</span><br><span class="line">    output +=bkey[input_bytes[v7] &gt;&gt; <span class="number">2</span>]</span><br><span class="line">    v12 = <span class="number">16</span> * input_bytes[v7] &amp; <span class="number">0x30</span></span><br><span class="line">    <span class="keyword">if</span> cnt1 - <span class="number">1</span> == v7:</span><br><span class="line">        v13 = <span class="string">&#x27;=&#x27;</span></span><br><span class="line">        output+=bkey[v12]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        output+=bkey[v12 | (input_bytes[v7+<span class="number">1</span>] &gt;&gt; <span class="number">4</span>)]</span><br><span class="line">        v13=bkey[<span class="number">4</span> * (input_bytes[v7+<span class="number">1</span>] &amp; <span class="number">0xF</span>)]</span><br><span class="line">    output+=<span class="string">&#x27;=&#x27;</span></span><br><span class="line">    output+=v13</span><br><span class="line">print(output)</span><br></pre></td></tr></table></figure><p>输出结果如下。和日志中的一致。第三题搞定。这几个算法看下来。算法部分基本是差不多的。主要变化的就是那个bkey部分。应该都是使用的base64的算法。只是key进行了调整。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PHKa&#96;#&quot;X[cEWwvyx&#123;z&#125;RUT Z]\|SutbeD$&#39;&amp;)VYk!rdgfps_(:&gt;GFI~^A@CBih%</span><br></pre></td></tr></table></figure><p>====================================================================================================================</p><p>第四题algorithmbase_13.apk</p><p>和上面的例子差不多的步骤。依然是ida打开。然后直接分析encodeFromJni_13函数。然后根据返回值找到最后的处理函数sub_8B04。然后写个hook脚本。这次我们直接将前面注意到每次都变化的base64的key给打印出来。脚本直接用上面的hook脚本。只修改为encodeFromJni_13即可。输出如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sub_8b04: 0xd67a1b05</span><br><span class="line">sub_8ABC: 0xd67a1abd</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;onenter sub_8ABC&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">0x18</span><br><span class="line">dump_addr: AYZpq23IJrTFfghijklCDE1KLMmBdestU5678GHz0cuvwabN9+&#x2F;VWXnoOPQRSxy4</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;onleave sub_8ABC&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">dump_addr: YABhi*+QRjL^~pqrst[\])STUuZ|&#125;klM-.&#x2F; _Pb(&#123;mnoyzV!37NO@vwWHIJK&#96;a,</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;onenter sub_8b04&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">#e9mUmm7YI!eEn&#125;&#96;b6jXg;Qg</span><br><span class="line">0x18</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;onleave sub_8b04&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">JvDHB]EyB[eUlt2_k)P&#96;L+Jvm_5bh@2b</span><br><span class="line">input: #e9mUmm7YI!eEn&#125;&#96;b6jXg;Qg output: JvDHB]EyB[eUlt2_k)P&#96;L+Jvm_5bh@2b</span><br></pre></td></tr></table></figure><p>老样子。我还是用之前的py模拟来进行处理。先放上c++的版本。然后对照修改成py的版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">prelen = len - <span class="number">2</span>;</span><br><span class="line">  cnt = len;</span><br><span class="line">  output_1 = output;</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = (_BYTE *)(output_1 + v6);</span><br><span class="line">    <span class="keyword">if</span> ( v7 &gt;= prelen )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v9 = input + v7;</span><br><span class="line">    v6 += <span class="number">4</span>;</span><br><span class="line">    *v8 = aAyzpq23ijrtffg[(<span class="keyword">unsigned</span> <span class="keyword">int</span>)*(<span class="keyword">unsigned</span> __int8 *)(input + v7) &gt;&gt; <span class="number">2</span>] ^ cnt;</span><br><span class="line">    v10 = *(<span class="keyword">unsigned</span> __int8 *)(input + v7 + <span class="number">1</span>);</span><br><span class="line">    v11 = *(_BYTE *)(input + v7);</span><br><span class="line">    v7 += <span class="number">3</span>;</span><br><span class="line">    v8[<span class="number">1</span>] = aAyzpq23ijrtffg[(v10 &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xFFFFFFCF</span> | <span class="number">16</span> * (v11 &amp; <span class="number">3</span>)];</span><br><span class="line">    v8[<span class="number">2</span>] = aAyzpq23ijrtffg[((<span class="keyword">unsigned</span> <span class="keyword">int</span>)*(<span class="keyword">unsigned</span> __int8 *)(v9 + <span class="number">2</span>) &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0xFFFFFFC3</span> | <span class="number">4</span></span><br><span class="line">                                                                                           * (*(_BYTE *)(v9 + <span class="number">1</span>) &amp; <span class="number">0xF</span>)] ^ cnt;</span><br><span class="line">    v8[<span class="number">3</span>] = aAyzpq23ijrtffg[*(_BYTE *)(v9 + <span class="number">2</span>) &amp; <span class="number">0x3F</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v7 &lt; cnt )</span><br><span class="line">  &#123;</span><br><span class="line">    *v8 = aAyzpq23ijrtffg[(<span class="keyword">unsigned</span> <span class="keyword">int</span>)*(<span class="keyword">unsigned</span> __int8 *)(input + v7) &gt;&gt; <span class="number">2</span>];</span><br><span class="line">    v12 = <span class="number">16</span> * *(<span class="keyword">unsigned</span> __int8 *)(input + v7) &amp; <span class="number">0x30</span>;</span><br><span class="line">    <span class="keyword">if</span> ( cnt - <span class="number">1</span> == v7 )</span><br><span class="line">    &#123;</span><br><span class="line">      v13 = <span class="number">61</span>;</span><br><span class="line">      v8[<span class="number">1</span>] = aAyzpq23ijrtffg[v12];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v8[<span class="number">1</span>] = aAyzpq23ijrtffg[v12 | ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)*(<span class="keyword">unsigned</span> __int8 *)(input + v7 + <span class="number">1</span>) &gt;&gt; <span class="number">4</span>)];</span><br><span class="line">      v13 = aAyzpq23ijrtffg[<span class="number">4</span> * (*(_BYTE *)(input + v7 + <span class="number">1</span>) &amp; <span class="number">0xF</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">    v8[<span class="number">3</span>] = <span class="number">61</span>;</span><br><span class="line">    v8[<span class="number">2</span>] = v13;</span><br><span class="line">    v8 += <span class="number">4</span>;a</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>下面贴上完整py的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getKey</span>(<span class="params">cnt</span>):</span></span><br><span class="line">    bkey = <span class="string">&quot;AYZpq23IJrTFfghijklCDE1KLMmBdestU5678GHz0cuvwabN9+/VWXnoOPQRSxy4&quot;</span></span><br><span class="line">    bkey_bytes=bytes(bkey,<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    res=bytearray()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(bkey)):</span><br><span class="line">        res.append(bkey_bytes[i]^cnt)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">input=<span class="string">&quot;&quot;&quot;#e9mUmm7YI!eEn&#125;`b6jXg;Qg&quot;&quot;&quot;</span></span><br><span class="line">input_bytes=bytes(input,<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">bkey=getKey(len(input))</span><br><span class="line"></span><br><span class="line">cnt = len(input)</span><br><span class="line">prelen = cnt - <span class="number">2</span></span><br><span class="line">output = <span class="string">&quot;&quot;</span></span><br><span class="line">v6 = <span class="number">0</span></span><br><span class="line">v7 = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span> v7 &gt;= prelen:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    v9 = v7</span><br><span class="line">    v6 += <span class="number">4</span></span><br><span class="line">    output += chr(bkey[input_bytes[v7] &gt;&gt; <span class="number">2</span>] ^ cnt)</span><br><span class="line">    v10 = input_bytes[v7+<span class="number">1</span>]</span><br><span class="line">    v11 = input_bytes[v7]</span><br><span class="line">    v7 += <span class="number">3</span></span><br><span class="line">    output += chr(bkey[(v10 &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xFFFFFFCF</span> | <span class="number">16</span> * (v11 &amp; <span class="number">3</span>)])</span><br><span class="line">    output += chr(bkey[(input_bytes[v9+<span class="number">2</span>] &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0xFFFFFFC3</span> | <span class="number">4</span> * (input_bytes[v9+<span class="number">1</span>] &amp; <span class="number">0xF</span>)] ^ cnt)</span><br><span class="line">    output += chr(bkey[input_bytes[v9+<span class="number">2</span>] &amp; <span class="number">0x3F</span>])</span><br><span class="line"><span class="keyword">if</span> v7 &lt; cnt:</span><br><span class="line">    output += chr(bkey[input_bytes[v7] &gt;&gt; <span class="number">2</span>])</span><br><span class="line">    v12 = <span class="number">16</span> * input_bytes[v7] &amp; <span class="number">0x30</span></span><br><span class="line">    <span class="keyword">if</span> cnt - <span class="number">1</span> == v7:</span><br><span class="line">      v13 = <span class="string">&#x27;=&#x27;</span></span><br><span class="line">      output += bkey[v12]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      output += bkey[v12 | (input_bytes[v7+<span class="number">1</span>] &gt;&gt; <span class="number">4</span>)]</span><br><span class="line">      v13 = bkey[<span class="number">4</span> * (input_bytes[v7+<span class="number">1</span>] &amp; <span class="number">0xF</span>)]</span><br><span class="line">    output += v13</span><br><span class="line">    output += <span class="string">&#x27;=&#x27;</span></span><br><span class="line"></span><br><span class="line">print(output)</span><br></pre></td></tr></table></figure><p>输出结果对比正确。第四题完成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JvDHB]EyB[eUlt2_k)P&#96;L+Jvm_5bh@2b</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vmp入门</title>
      <link href="/2020/11/16/vmp/"/>
      <url>/2020/11/16/vmp/</url>
      
        <content type="html"><![CDATA[<p>记录学习的过程</p><p>vmp壳的应用。从效果上面看，是把java的函数，加密成了native的函数，在实现函数加密保护时，主要是对相同参数并且相同返回值的函数加密成native的。所以会一般是两种情况，一个是直接对onCreate函数进行vmp保护，或者是抽象出一个统一参数和返回值的函数。然后对这个函数进行vmp保护。</p><p>native的函数都是需要动态注册的。所以我们先改造aosp源码。打印下注册了函数，以及函数的地址，方便我们后续进行调试跟踪，下面修改art_method.cc</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">void</span>* <span class="title">ArtMethod::RegisterNative</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* native_method, <span class="keyword">bool</span> is_fast)</span> </span>&#123;</span><br><span class="line">  CHECK(IsNative()) &lt;&lt; PrettyMethod();</span><br><span class="line">  CHECK(!IsFastNative()) &lt;&lt; PrettyMethod();</span><br><span class="line">  CHECK(native_method != <span class="literal">nullptr</span>) &lt;&lt; PrettyMethod();</span><br><span class="line">  <span class="keyword">if</span> (is_fast) &#123;</span><br><span class="line">    AddAccessFlags(kAccFastNative);</span><br><span class="line">  &#125;</span><br><span class="line">  LOG(ERROR)&lt;&lt;<span class="string">&quot;krom ArtMethod::RegisterNative:&quot;</span>&lt;&lt;<span class="keyword">this</span>-&gt;PrettyMethod()&lt;&lt;<span class="string">&quot;----addr:&quot;</span>&lt;&lt;native_method;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span>* new_native_method = <span class="literal">nullptr</span>;</span><br><span class="line">  Runtime::Current()-&gt;GetRuntimeCallbacks()-&gt;RegisterNativeMethod(<span class="keyword">this</span>,</span><br><span class="line">                                                                  native_method,</span><br><span class="line">                                                                  <span class="comment">/*out*/</span>&amp;new_native_method);</span><br><span class="line">  SetEntryPointFromJni(new_native_method);</span><br><span class="line">  <span class="keyword">return</span> new_native_method;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于vmp中将java函数转成了native函数，所以函数内肯定有大量jni调用处理。所以为了方便分析，再改造下rom，在jni函数调用的时候将触发调用的函数以及被调用的函数，都打印出来。这样就知道加密的一部分jni调用，InvokeWithArgArray这个函数就满足我们的需求，jni函数都会调用的地方。我们在这里插入日志记录即可。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InvokeWithArgArray</span><span class="params">(<span class="keyword">const</span> ScopedObjectAccessAlreadyRunnable&amp; soa,</span></span></span><br><span class="line"><span class="function"><span class="params">                               ArtMethod* method, ArgArray* arg_array, JValue* result,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">const</span> <span class="keyword">char</span>* shorty)</span></span></span><br><span class="line"><span class="function">    <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span>* args = arg_array-&gt;GetArray();</span><br><span class="line">  <span class="keyword">if</span> (UNLIKELY(soa.Env()-&gt;check_jni)) &#123;</span><br><span class="line">    CheckMethodArguments(soa.Vm(), method-&gt;GetInterfaceMethodIfProxy(kRuntimePointerSize), args);</span><br><span class="line">  &#125;</span><br><span class="line">  ArtMethod* artmethod=<span class="literal">nullptr</span>;</span><br><span class="line">  Thread* thread=Thread::Current;</span><br><span class="line">  ManagedStack* managerStack=thread-&gt;GetManagedStack();</span><br><span class="line">  <span class="keyword">if</span>(managerStack!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">      ArtMethod** methodPP=managerStack-&gt;GetTopQuickFrame();</span><br><span class="line">      <span class="keyword">if</span>(methodPP!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">          artmethod=*methodPP;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(artmethod!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">      LOG(ERROR)&lt;&lt;<span class="string">&quot;krom start InvokeWithArgArray call:&quot;</span>&lt;&lt;artmethod-&gt;PrettyMethod()&lt;&lt;<span class="string">&quot;----goal:&quot;</span>&lt;&lt;method-&gt;PrettyMethod();</span><br><span class="line">  &#125;</span><br><span class="line">  method-&gt;Invoke(soa.Self(), args, arg_array-&gt;GetNumBytes(), result, shorty);</span><br><span class="line">  <span class="keyword">if</span>(artmethod!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">      LOG(ERROR)&lt;&lt;<span class="string">&quot;krom end InvokeWithArgArray call:&quot;</span>&lt;&lt;artmethod-&gt;PrettyMethod()&lt;&lt;<span class="string">&quot;----goal:&quot;</span>&lt;&lt;method-&gt;PrettyMethod();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后为了方便调试，过掉各种检测，所以先修改aosp源码，能够在想要调试的jni函数执行前进行sleep等待。然后我们再附加进程。这样不在开始的时候直接附加进程，就可以直接跳过很多种动态调试检测。</p><p>所有jni函数在执行前后，art会进行一些准备和清场的步骤，比如JniMethodStart和JniMethodEnd。我们可以在JniMethodStart的时候判断一下。符合条件就sleep等待一下。下面贴下修改后的代码，文件路径是/art/runtime/entrypoints/quick/quick_jni_entrypoints.cc</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Called on entry to JNI, transition out of Runnable and release share of mutator_lock_.</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">uint32_t</span> <span class="title">JniMethodStart</span><span class="params">(Thread* self)</span> </span>&#123;</span><br><span class="line">  JNIEnvExt* env = self-&gt;GetJniEnv();</span><br><span class="line">  DCHECK(env != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">uint32_t</span> saved_local_ref_cookie = bit_cast&lt;<span class="keyword">uint32_t</span>&gt;(env-&gt;local_ref_cookie);</span><br><span class="line">  env-&gt;local_ref_cookie = env-&gt;locals.GetSegmentState();</span><br><span class="line">  ArtMethod* native_method = *self-&gt;GetManagedStack()-&gt;GetTopQuickFrame();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* methodname=native_method-&gt;PrettyMethod();</span><br><span class="line">  <span class="comment">//这里虽然是拿函数名判断。但是我们使用的时候，是用frida来hook这个strstr函数。然后再根据第一个参数判断。是想要断点的函数。就直接返回数据</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">strstr</span>(methodname,<span class="string">&quot;JniMethodStart&quot;</span>)!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">      sleep(<span class="number">60</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!native_method-&gt;IsFastNative()) &#123;</span><br><span class="line">    <span class="comment">// When not fast JNI we transition out of runnable.</span></span><br><span class="line">    self-&gt;TransitionFromRunnableToSuspended(kNative);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> saved_local_ref_cookie;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们使用frida配合rom来控制函数是否需要进入等待。从而达到跳过各种反调试。在最后jni函数执行前才进行附加调试的效果。</p><p>下面贴上配合的frida代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> libcModule=Process.getModuleByName(<span class="string">&quot;libc.so&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> strstr=libcModule.getExportByName(<span class="string">&quot;strstr&quot;</span>);</span><br><span class="line">    Interceptor.attach(strstr,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.arg0=args[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">this</span>.arg1=args[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">var</span> method_name=ptr(<span class="built_in">this</span>.arg0).readUtf8String();</span><br><span class="line">            <span class="keyword">var</span> call_name=ptr(<span class="built_in">this</span>.arg1).readUtf8String();</span><br><span class="line">            <span class="keyword">if</span>(call_name.indexOf(<span class="string">&quot;JniMethodStart&quot;</span>)!=<span class="number">-1</span> &amp;&amp; method_name.indexOf(<span class="string">&quot;MainActivity.onCreate&quot;</span>)!=<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;JniMethodStart onCreate enter&quot;</span>);</span><br><span class="line">                <span class="built_in">this</span>.retval=<span class="string">&quot;1&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="attr">onLeave</span>:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.retval)&#123;</span><br><span class="line">                retval.replace(<span class="built_in">this</span>.retval);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    hook_start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></table></figure><p>然后启动frida。我这里环境使用的xadb。所以可以简单的直接打开frida</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vmp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fart的理解和分析过程</title>
      <link href="/2020/11/03/fart/"/>
      <url>/2020/11/03/fart/</url>
      
        <content type="html"><![CDATA[<p>文章内的fart的源码素材均来自看雪搞研网课。安卓源码为8.1</p><p>学习了一段时间fart然后整理一下以便哪天忘记了翻翻</p><p>fart是一个art环境下基于主动调用的自动化脱壳方案。在定制的fart环境中，只需要运行需要脱壳的apk即可自动脱壳，将脱壳后的dex文件dump在/sdcard/fart/app包名的目录下，那么这个流程是如何实现的呢。</p><p>内部的一些原理作者有发过帖子详细进行过讲解，所以这里先是跟着作者的思想进行一步步的深入。先贴上地址</p><p>1、[FART：ART环境下基于主动调用的自动化脱壳方案][<a href="https://bbs.pediy.com/thread-252630.htm]">https://bbs.pediy.com/thread-252630.htm]</a></p><p>2、[FART正餐前甜点：ART下几个通用简单高效的dump内存中dex方法][<a href="https://bbs.pediy.com/thread-254028.htm]">https://bbs.pediy.com/thread-254028.htm]</a></p><p>3、[拨云见日：安卓APP脱壳的本质以及如何快速发现ART下的脱壳点][<a href="https://bbs.pediy.com/thread-254555.htm]">https://bbs.pediy.com/thread-254555.htm]</a></p><p>阅读几篇文章后，我简单整理一下收获</p><a id="more"></a><p>ActivityThread.main()是一个app开始的入口，下面先贴下8.1系统的main的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SamplingProfilerIntegration.start();</span><br><span class="line">        CloseGuard.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">        Environment.initForCurrentUser();</span><br><span class="line">        EventLogger.setReporter(<span class="keyword">new</span> ActivityThread.EventLoggingReporter());</span><br><span class="line">        Security.addProvider(<span class="keyword">new</span> AndroidKeyStoreProvider());</span><br><span class="line">        File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">        TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line">        Process.setArgV0(<span class="string">&quot;&lt;pre-initialized&gt;&quot;</span>);</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">        thread.attach(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        Looper.loop();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里看到主要是创建了一个ActivityThread然后调用了attach，然后就是进入了主线程的事件循环，在attach的里面将这个ActivityThread保存在了一个全局的静态变量中。attach代码比较多，我就只截一点点了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ActivityThread sCurrentActivityThread;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ActivityThread <span class="title">currentActivityThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sCurrentActivityThread;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system)</span> </span>&#123;</span><br><span class="line">    sCurrentActivityThread = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再看看主线程的事件循环做了什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper me = myLooper();</span><br><span class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            MessageQueue queue = me.mQueue;</span><br><span class="line">            Binder.clearCallingIdentity();</span><br><span class="line">            <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                Message msg = queue.next();</span><br><span class="line">                <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Printer logging = me.mLogging;</span><br><span class="line">                <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);</span><br><span class="line">                &#125;</span><br><span class="line">                msg.target.dispatchMessage(msg);</span><br><span class="line">                <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">                <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">                    Log.wtf(<span class="string">&quot;Looper&quot;</span>, <span class="string">&quot;Thread identity changed from 0x&quot;</span> + Long.toHexString(ident) + <span class="string">&quot; to 0x&quot;</span> + Long.toHexString(newIdent) + <span class="string">&quot; while dispatching to &quot;</span> + msg.target.getClass().getName() + <span class="string">&quot; &quot;</span> + msg.callback + <span class="string">&quot; what=&quot;</span> + msg.what);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                msg.recycleUnchecked();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后看到消息交给dispatchMessage这个函数进行分发处理继续看看这个函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.mCallback != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>到这里。就进入了handleMessage处理消息分发，这里注意。这个地方的handle使用的是ActivityThread内部的H类，看ActivityThread的以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ActivityThread.H mH = <span class="keyword">new</span> ActivityThread.H();</span><br><span class="line"><span class="function"><span class="keyword">final</span> Handler <span class="title">getHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.mH;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>所以这里看H类的handleMessage函数，代码太多，这里只贴文章里面所说的bindapplication的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">110</span>:</span><br><span class="line">    Trace.traceBegin(<span class="number">64L</span>, <span class="string">&quot;bindApplication&quot;</span>);</span><br><span class="line">    ActivityThread.AppBindData data = (ActivityThread.AppBindData)msg.obj;</span><br><span class="line">    ActivityThread.<span class="keyword">this</span>.handleBindApplication(data);</span><br><span class="line">    Trace.traceEnd(<span class="number">64L</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>然后继续看handleBindApplication，我们就可以看到大神所说的重要的点了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Application app = data.info.makeApplication(data.restrictedBackupMode, (Instrumentation)<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">this</span>.mInitialApplication = app;</span><br><span class="line"><span class="keyword">if</span> (!data.restrictedBackupMode) &#123;</span><br><span class="line">  List&lt;ProviderInfo&gt; providers = data.providers;</span><br><span class="line">  <span class="keyword">if</span> (providers != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.installContentProviders(app, providers);</span><br><span class="line">    <span class="keyword">this</span>.mH.sendEmptyMessageDelayed(<span class="number">132</span>, <span class="number">10000L</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception var20) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Exception thrown in onCreate() of &quot;</span> + data.instrumentationName + <span class="string">&quot;: &quot;</span> + var20.toString(), var20);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception var26) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.mInstrumentation.onException(app, var26)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Unable to create application &quot;</span> + app.getClass().getName() + <span class="string">&quot;: &quot;</span> + var26.toString(), var26);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的callApplicationOnCreate就是app的onCreate调用了。再看看前面的makeApplication的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ContextImpl appContext = ContextImpl.createAppContext(<span class="keyword">this</span>.mActivityThread, <span class="keyword">this</span>);</span><br><span class="line">app = <span class="keyword">this</span>.mActivityThread.mInstrumentation.newApplication(cl, appClass, appContext);</span><br><span class="line">appContext.setOuterContext(app);</span><br></pre></td></tr></table></figure><p>这里又调用了newApplication,继续看里面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Application <span class="title">newApplication</span><span class="params">(Class&lt;?&gt; clazz, Context context)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException </span>&#123;</span><br><span class="line">    Application app = (Application)clazz.newInstance();</span><br><span class="line">    app.attach(context);</span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续再看app的attach</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.attachBaseContext(context);</span><br><span class="line">    <span class="keyword">this</span>.mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里就知道了大家都喜欢的attachBaseContext和onCreate分别是在什么时机调用的了</p><p>然后就看下面的图</p><p><img src="/2020/11/03/fart/632473_3B54U89SWTXUKRE.png" alt="img"></p><p>这里的意思就是加壳的app会在attachBaseContext函数和onCreate函数里面对dex进行解密，解密后再用反射修复里面的变量。最后修复成正常的dex。其中最重要的就是Classloader。所有的应用中加载的dex文件最终都在应用的Classloader中。</p><p>所以我们只要取到加壳的应用最后修复完，正常加载时的Classloader就脱壳成功了。这种脱壳方式就是所谓的整体dump。</p><p>后来的第二代壳所谓的函数抽取，就是为了防止修复后的dex被直接整体dump给脱下来，然后将类和函数的关键流程在调用时，才进行解密修复。而fart的主动调用所有函数，就会触发解密修复，然后再进行dump，从而实现函数抽取壳的脱壳。</p><p>fart脱壳的原理下面贴上作者大佬的原话。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FART脱壳的步骤主要分为三步：</span><br><span class="line">1.内存中DexFile结构体完整dex的dump</span><br><span class="line">2.主动调用类中的每一个方法，并实现对应CodeItem的dump</span><br><span class="line">3.通过主动调用dump下来的方法的CodeItem进行dex中被抽取的方法的修复</span><br></pre></td></tr></table></figure><p>一代壳的脱法，就是选择一个已经完成解密加载的时机，然后把完整的dex给dump下来。由于加壳是通过替换attachBaseContext和onCreate函数，在这两个函数里面解密dex。所以时机选在onCreate后的任意函数都可以。作者大佬选择的是performLaunchActivity作为脱壳的时机。下面贴上关键部分代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    fartthread();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fartthread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Log.e(<span class="string">&quot;ActivityThread&quot;</span>, <span class="string">&quot;start sleep......&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1</span> * <span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      Log.e(<span class="string">&quot;ActivityThread&quot;</span>, <span class="string">&quot;sleep over and start fart&quot;</span>);</span><br><span class="line">      fart();</span><br><span class="line">      Log.e(<span class="string">&quot;ActivityThread&quot;</span>, <span class="string">&quot;fart run over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里开了一个线程去处理，接着继续看fart做了些啥</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ClassLoader appClassloader = getClassloader();</span><br><span class="line">  ClassLoader tmpClassloader=appClassloader;</span><br><span class="line">  ClassLoader parentClassloader=appClassloader.getParent();</span><br><span class="line">  <span class="comment">//如果当前classloader不是根，就脱他</span></span><br><span class="line">  <span class="keyword">if</span>(appClassloader.toString().indexOf(<span class="string">&quot;java.lang.BootClassLoader&quot;</span>)==-<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    fartwithClassloader(appClassloader);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果有父节点，并且父节点不是根，就脱他。一直脱到根节点就结束</span></span><br><span class="line">  <span class="keyword">while</span>(parentClassloader!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(parentClassloader.toString().indexOf(<span class="string">&quot;java.lang.BootClassLoader&quot;</span>)==-<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fartwithClassloader(parentClassloader);</span><br><span class="line">    &#125;</span><br><span class="line">    tmpClassloader=parentClassloader;</span><br><span class="line">    parentClassloader=parentClassloader.getParent();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里相当于是从当前classloader一直向上层的遍历，把所有classloader挨个脱一遍。先看看他是怎么获取classloader的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getClassloader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ClassLoader resultClassloader = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">//这里反射获取到的currentActivityThread</span></span><br><span class="line">  Object currentActivityThread = invokeStaticMethod(</span><br><span class="line">    <span class="string">&quot;android.app.ActivityThread&quot;</span>, <span class="string">&quot;currentActivityThread&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> Class[]&#123;&#125;, <span class="keyword">new</span> Object[]&#123;&#125;);</span><br><span class="line">  <span class="comment">//这里反射获取出mBoundApplication</span></span><br><span class="line">  Object mBoundApplication = getFieldOjbect(</span><br><span class="line">    <span class="string">&quot;android.app.ActivityThread&quot;</span>, currentActivityThread,</span><br><span class="line">    <span class="string">&quot;mBoundApplication&quot;</span>);</span><br><span class="line">  Application mInitialApplication = (Application) getFieldOjbect(<span class="string">&quot;android.app.ActivityThread&quot;</span>,</span><br><span class="line">                                                                 currentActivityThread, <span class="string">&quot;mInitialApplication&quot;</span>);</span><br><span class="line">  Object loadedApkInfo = getFieldOjbect(</span><br><span class="line">    <span class="string">&quot;android.app.ActivityThread$AppBindData&quot;</span>,</span><br><span class="line">    mBoundApplication, <span class="string">&quot;info&quot;</span>);</span><br><span class="line">  <span class="comment">//反射获取出目标application</span></span><br><span class="line">  Application mApplication = (Application) getFieldOjbect(<span class="string">&quot;android.app.LoadedApk&quot;</span>, loadedApkInfo, <span class="string">&quot;mApplication&quot;</span>);</span><br><span class="line">  <span class="comment">//获取classloader</span></span><br><span class="line">  resultClassloader = mApplication.getClassLoader();</span><br><span class="line">  <span class="keyword">return</span> resultClassloader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我不太了解为什么是获取android.app.LoadedApk里面的mApplication。所以特地的去翻了一下。这个值的来源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">makeApplication</span><span class="params">(<span class="keyword">boolean</span> forceDefaultAppClass, Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.mApplication != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.mApplication;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Application app = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//...省略中间app创建的若干代码</span></span><br><span class="line">    <span class="keyword">this</span>.mActivityThread.mAllApplications.add(app);</span><br><span class="line">    <span class="keyword">this</span>.mApplication = app;</span><br><span class="line">    <span class="comment">//...省略中间若干代码</span></span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">  Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">  <span class="comment">//省略中间的代码</span></span><br><span class="line">  <span class="comment">//add</span></span><br><span class="line">  fartthread();</span><br><span class="line">  <span class="comment">//add</span></span><br><span class="line">  <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子看，在这个时机的脱壳必然是能取到那个mApplication的。大概就看出这么点原因。</p><p>==========================================================================================</p><p>里面还有很多地方不太理解。所以这里先从fart中跳出来，先看看android源码中对于获取一个ClassLoader的追溯，看看里面是怎么实现获取一个ClassLoader的。先看看java代码我们要如何获取一个ClassLoader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader cl = ClassLoader.getSystemClassLoader();</span><br><span class="line">cl.loadClass(<span class="string">&quot;com.example.demo&quot;</span>);</span><br></pre></td></tr></table></figure><p>这里可以看到直接通过loadClass取到的classLoader，那么这个函数是怎么做到的呢，下面贴下代码追踪ClassLoader.java中的loadClass</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">  <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了另外一个重载，继续贴第二个重载的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">  <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">  Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        c = findBootstrapClassOrNull(name);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">      <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">      <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">      <span class="comment">// to find the class.</span></span><br><span class="line">      c = findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的意思大概就是，如果曾经获取过，findLoadedClass就直接可以获取到并返回。否则就继续通过findClass查找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是个默认,好像这个是提供给子类重写的。然后我们再看看父类BaseDexClassLoader也有一个findClass</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DexPathList pathList;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">  List&lt;Throwable&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;Throwable&gt;();</span><br><span class="line">  Class c = pathList.findClass(name, suppressedExceptions);</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">  ClassNotFoundException cnfe = <span class="keyword">new</span> ClassNotFoundException(</span><br><span class="line">  <span class="string">&quot;Didn&#x27;t find class \&quot;&quot;</span> + name + <span class="string">&quot;\&quot; on path: &quot;</span> + pathList);</span><br><span class="line">  <span class="keyword">for</span> (Throwable t : suppressedExceptions) &#123;</span><br><span class="line">  cnfe.addSuppressed(t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> cnfe;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到最后返回的Class c又是由pathList.findClass获取的。继续看DexPathList类的findClass，后面fart里面有参考这里的代码。在fart中同样是获取dexElements，然后遍历，然后取出dexFile。然后再进行各种操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">  DexPathList.Element[] arr$ = <span class="keyword">this</span>.dexElements;</span><br><span class="line">  <span class="keyword">int</span> len$ = arr$.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i$ = <span class="number">0</span>; i$ &lt; len$; ++i$) &#123;</span><br><span class="line">    DexPathList.Element element = arr$[i$];</span><br><span class="line">    DexFile dex = element.dexFile;</span><br><span class="line">    <span class="keyword">if</span> (dex != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Class clazz = dex.loadClassBinaryName(name, <span class="keyword">this</span>.definingContext, suppressed);</span><br><span class="line">      <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.dexElementsSuppressedExceptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">    suppressed.addAll(Arrays.asList(<span class="keyword">this</span>.dexElementsSuppressedExceptions));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后继续看返回值的来源是通过loadClassBinaryName来获取的。继续看看实现的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">loadClassBinaryName</span><span class="params">(String name, ClassLoader loader, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> defineClass(name, loader, <span class="keyword">this</span>.mCookie, suppressed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着继续看defineClass</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Class <span class="title">defineClass</span><span class="params">(String name, ClassLoader loader, <span class="keyword">long</span> cookie, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">  Class result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    result = defineClassNative(name, loader, cookie);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (NoClassDefFoundError var7) &#123;</span><br><span class="line">    <span class="keyword">if</span> (suppressed != <span class="keyword">null</span>) &#123;</span><br><span class="line">      suppressed.add(var7);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ClassNotFoundException var8) &#123;</span><br><span class="line">    <span class="keyword">if</span> (suppressed != <span class="keyword">null</span>) &#123;</span><br><span class="line">      suppressed.add(var8);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果又是从defineClassNative来的。而这个函数就是一个native的函数。再翻就得去c++里面找代码了。下面再回到fart的脱壳函数fartwithClassloader，就会发现不少眼熟的地方了</p><p>重新回到fart继续看看fartwithClassloader这个函数如何实现脱classloader的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fartwithClassloader</span><span class="params">(ClassLoader appClassloader)</span> </span>&#123;</span><br><span class="line">  List&lt;Object&gt; dexFilesArray = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">  <span class="comment">//这个是刚刚的findClass的pathList。这里通过反射获取。不过这个下面没使用。</span></span><br><span class="line">  Field pathList_Field = (Field) getClassField(appClassloader, <span class="string">&quot;dalvik.system.BaseDexClassLoader&quot;</span>, <span class="string">&quot;pathList&quot;</span>);</span><br><span class="line">  <span class="comment">//和上面一样。不过这个是直接获取这个属性的结果出来，比上面多了个field.get()</span></span><br><span class="line">  Object pathList_object = getFieldOjbect(<span class="string">&quot;dalvik.system.BaseDexClassLoader&quot;</span>, appClassloader, <span class="string">&quot;pathList&quot;</span>);</span><br><span class="line">  <span class="comment">//通过反射获取dexElements，这个流程可以直接回顾上面的findClass。基本是一样的。</span></span><br><span class="line">  Object[] ElementsArray = (Object[]) getFieldOjbect(<span class="string">&quot;dalvik.system.DexPathList&quot;</span>, pathList_object, <span class="string">&quot;dexElements&quot;</span>);</span><br><span class="line">  Field dexFile_fileField = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    dexFile_fileField = (Field) getClassField(appClassloader, <span class="string">&quot;dalvik.system.DexPathList$Element&quot;</span>, <span class="string">&quot;dexFile&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  Class DexFileClazz = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//反射获取dexfile类型</span></span><br><span class="line">    DexFileClazz = appClassloader.loadClass(<span class="string">&quot;dalvik.system.DexFile&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  Method getClassNameList_method = <span class="keyword">null</span>;</span><br><span class="line">  Method defineClass_method = <span class="keyword">null</span>;</span><br><span class="line">  Method dumpDexFile_method = <span class="keyword">null</span>;</span><br><span class="line">  Method dumpMethodCode_method = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//通过反射将4个函数的值填充上</span></span><br><span class="line">  <span class="keyword">for</span> (Method field : DexFileClazz.getDeclaredMethods()) &#123;</span><br><span class="line">    <span class="comment">//这个应该是用来获取类名称列表的</span></span><br><span class="line">    <span class="keyword">if</span> (field.getName().equals(<span class="string">&quot;getClassNameList&quot;</span>)) &#123;</span><br><span class="line">      getClassNameList_method = field;</span><br><span class="line">      getClassNameList_method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个是我们在上面loadClass流程最后看到的函数</span></span><br><span class="line">    <span class="keyword">if</span> (field.getName().equals(<span class="string">&quot;defineClassNative&quot;</span>)) &#123;</span><br><span class="line">      defineClass_method = field;</span><br><span class="line">      defineClass_method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个用来保存整个dex的,是fart里面的代码</span></span><br><span class="line">    <span class="keyword">if</span> (field.getName().equals(<span class="string">&quot;dumpDexFile&quot;</span>)) &#123;</span><br><span class="line">      dumpDexFile_method = field;</span><br><span class="line">      dumpDexFile_method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个应该是用来保存函数代码的，也是fart里面的代码</span></span><br><span class="line">    <span class="keyword">if</span> (field.getName().equals(<span class="string">&quot;dumpMethodCode&quot;</span>)) &#123;</span><br><span class="line">      dumpMethodCode_method = field;</span><br><span class="line">      dumpMethodCode_method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//这个是获取mCookie字段。不过后面也是没有用到的</span></span><br><span class="line">  Field mCookiefield = getClassField(appClassloader, <span class="string">&quot;dalvik.system.DexFile&quot;</span>, <span class="string">&quot;mCookie&quot;</span>);</span><br><span class="line">  Log.v(<span class="string">&quot;ActivityThread-&gt;methods&quot;</span>, <span class="string">&quot;dalvik.system.DexPathList.ElementsArray.length:&quot;</span> + ElementsArray.length);<span class="comment">//5个</span></span><br><span class="line">  <span class="comment">//下面是遍历所有dexfile，然后主动调用所有函数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ElementsArray.length; j++) &#123;</span><br><span class="line">    Object element = ElementsArray[j];</span><br><span class="line">    Object dexfile = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//先是反射取出每个dexfile</span></span><br><span class="line">      dexfile = (Object) dexFile_fileField.get(element);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dexfile == <span class="keyword">null</span>) &#123;</span><br><span class="line">      Log.e(<span class="string">&quot;ActivityThread&quot;</span>, <span class="string">&quot;dexfile is null&quot;</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dexfile != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//然后取出dexfile中的mcookie，这里为什么从mInternalCookie可以在android源码中看到mCookie本身就是由mInternalCookie赋值的</span></span><br><span class="line">      dexFilesArray.add(dexfile);</span><br><span class="line">      Object mcookie = getClassFieldObject(appClassloader, <span class="string">&quot;dalvik.system.DexFile&quot;</span>, dexfile, <span class="string">&quot;mCookie&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (mcookie == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Object mInternalCookie = getClassFieldObject(appClassloader, <span class="string">&quot;dalvik.system.DexFile&quot;</span>, dexfile, <span class="string">&quot;mInternalCookie&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(mInternalCookie!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          mcookie=mInternalCookie;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          Log.v(<span class="string">&quot;ActivityThread-&gt;err&quot;</span>, <span class="string">&quot;get mInternalCookie is null&quot;</span>);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//再根据mcookie获取dexfile的所有类名</span></span><br><span class="line">      String[] classnames = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        classnames = (String[]) getClassNameList_method.invoke(dexfile, mcookie);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//最后遍历所有类，调用每个类中的所有函数</span></span><br><span class="line">      <span class="keyword">if</span> (classnames != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String eachclassname : classnames) &#123;</span><br><span class="line">          loadClassAndInvoke(appClassloader, eachclassname, dumpMethodCode_method);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看看fart怎么做到的调用每个类中的所有函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadClassAndInvoke</span><span class="params">(ClassLoader appClassloader, String eachclassname, Method dumpMethodCode_method)</span> </span>&#123;</span><br><span class="line">  Class resultclass = <span class="keyword">null</span>;</span><br><span class="line">  Log.i(<span class="string">&quot;ActivityThread&quot;</span>, <span class="string">&quot;go into loadClassAndInvoke-&gt;&quot;</span> + <span class="string">&quot;classname:&quot;</span> + eachclassname);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//由于我们反射取到了类名，所以这里直接用我们前面看到的loadClass就可以取到对应的classloader了</span></span><br><span class="line">    resultclass = appClassloader.loadClass(eachclassname);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//反射遍历所有构造函数，并且调用前面准备好了传过来的保存构造函数代码的方法，直接调用就可以dump每个构造函数的代码了</span></span><br><span class="line">  <span class="keyword">if</span> (resultclass != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Constructor&lt;?&gt; cons[] = resultclass.getDeclaredConstructors();</span><br><span class="line">      <span class="keyword">for</span> (Constructor&lt;?&gt; constructor : cons) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dumpMethodCode_method != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            dumpMethodCode_method.invoke(<span class="keyword">null</span>, constructor);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          Log.e(<span class="string">&quot;ActivityThread&quot;</span>, <span class="string">&quot;dumpMethodCode_method is null &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里反射获取所有的函数，然后用前面准备的dump方法把所有函数都dump下来</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Method[] methods = resultclass.getDeclaredMethods();</span><br><span class="line">      <span class="keyword">if</span> (methods != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">          <span class="keyword">if</span> (dumpMethodCode_method != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              dumpMethodCode_method.invoke(<span class="keyword">null</span>, m);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.e(<span class="string">&quot;ActivityThread&quot;</span>, <span class="string">&quot;dumpMethodCode_method is null &quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就看看我们提前准备的dumpMethod是如何dump函数的了。找到DexFile里面的native实现的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> native <span class="keyword">void</span> <span class="title">dumpMethodCode</span><span class="params">(Object m)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DexFile_dumpMethodCode</span><span class="params">(JNIEnv* env, jclass,jobject method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(method!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ArtMethod* proxy_method = jobject2ArtMethod(env, method);</span><br><span class="line">        myfartInvoke(proxy_method);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先是把java传递过来的函数指针转换成了ArtMethod了。然后myfartInvoke来处理每个函数。继续看看里面怎么做的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">myfartInvoke</span><span class="params">(ArtMethod* artmethod)</span>  <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">  JValue *result=<span class="literal">nullptr</span>;</span><br><span class="line">  Thread *self=<span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> temp=<span class="number">6</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span>* args=&amp;temp;</span><br><span class="line">  <span class="keyword">uint32_t</span> args_size=<span class="number">6</span>;</span><br><span class="line">  artmethod-&gt;Invoke(self, args, args_size, result, <span class="string">&quot;fart&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到是调用了artmethod的Invoke。然后最后一个参数来告知里面，这是一个fart主动调用的函数。继续看看里面处理。代码有点多，下，面代码只放上和fart相关的处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArtMethod::Invoke</span><span class="params">(Thread* self, <span class="keyword">uint32_t</span>* args, <span class="keyword">uint32_t</span> args_size, JValue* result,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> <span class="keyword">char</span>* shorty)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (self== <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        dumpArtMethod(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里看到。其实他虽然传了个fart字符串进来想作为判断的。但是实际上没有使用。最后还是根据第一个参数self是否为nullptr来判断用不用dump这个函数的。继续看dumpArtMethod的处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">dumpArtMethod</span><span class="params">(ArtMethod* artmethod)</span>  <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> *dexfilepath=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span>(dexfilepath==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; <span class="string">&quot;ArtMethod::dumpArtMethodinvoked,methodname:&quot;</span>&lt;&lt;artmethod-&gt;PrettyMethod().c_str()&lt;&lt;<span class="string">&quot;malloc 1000 byte failed&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fcmdline =<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">char</span> szCmdline[<span class="number">64</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span> szProcName[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> procid = getpid();</span><br><span class="line">            <span class="comment">//我查了下，/proc/pid/cmdline 是可以读取到进程的启动参数。启动参数的默认第一个一般都是进程的完整路径</span></span><br><span class="line">        <span class="built_in">sprintf</span>(szCmdline,<span class="string">&quot;/proc/%d/cmdline&quot;</span>, procid);</span><br><span class="line">        fcmdline = <span class="built_in">open</span>(szCmdline, O_RDONLY,<span class="number">0644</span>);</span><br><span class="line">        <span class="keyword">if</span>(fcmdline &gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result=<span class="built_in">read</span>(fcmdline, szProcName,<span class="number">256</span>);</span><br><span class="line">            <span class="keyword">if</span>(result&lt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                LOG(ERROR) &lt;&lt; <span class="string">&quot;ArtMethod::dumpdexfilebyArtMethod,open cmdline file file error&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">close</span>(fcmdline);</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span>(szProcName[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> DexFile* dex_file = artmethod-&gt;GetDexFile();</span><br><span class="line">              <span class="comment">//要保存dexfile的起始位置</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">uint8_t</span>* begin_=dex_file-&gt;Begin();  <span class="comment">// Start of data.</span></span><br><span class="line">              <span class="comment">//要保存dexfile的大小</span></span><br><span class="line">            <span class="keyword">size_t</span> size_=dex_file-&gt;Size();  <span class="comment">// Length of data.</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">memset</span>(dexfilepath,<span class="number">0</span>,<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">int</span> size_int_=(<span class="keyword">int</span>)size_;</span><br><span class="line">                        <span class="comment">//先初始化目录/sdcard/fart  创建目录并给0777的权限</span></span><br><span class="line">            <span class="built_in">memset</span>(dexfilepath,<span class="number">0</span>,<span class="number">1000</span>);</span><br><span class="line">            <span class="built_in">sprintf</span>(dexfilepath,<span class="string">&quot;%s&quot;</span>,<span class="string">&quot;/sdcard/fart&quot;</span>);</span><br><span class="line">            <span class="built_in">mkdir</span>(dexfilepath,<span class="number">0777</span>);</span><br><span class="line">                      <span class="comment">//然后把cmdline中读取到的路径在fart中同样创建目录，这样就可以区分不同的apk的结果写在不同目录</span></span><br><span class="line">            <span class="built_in">memset</span>(dexfilepath,<span class="number">0</span>,<span class="number">1000</span>);</span><br><span class="line">            <span class="built_in">sprintf</span>(dexfilepath,<span class="string">&quot;/sdcard/fart/%s&quot;</span>,szProcName);</span><br><span class="line">            <span class="built_in">mkdir</span>(dexfilepath,<span class="number">0777</span>);</span><br><span class="line">                        <span class="comment">//最后创建要写入保存的文件</span></span><br><span class="line">            <span class="built_in">memset</span>(dexfilepath,<span class="number">0</span>,<span class="number">1000</span>);</span><br><span class="line">            <span class="built_in">sprintf</span>(dexfilepath,<span class="string">&quot;/sdcard/fart/%s/%d_dexfile.dex&quot;</span>,szProcName,size_int_);</span><br><span class="line">            <span class="keyword">int</span> dexfilefp=<span class="built_in">open</span>(dexfilepath,O_RDONLY,<span class="number">0666</span>);</span><br><span class="line">              <span class="comment">//这里相当于是查一下这个文件是否存在。如果fp大于0表示存在，则不用再dump了。</span></span><br><span class="line">            <span class="keyword">if</span>(dexfilefp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">close</span>(dexfilefp);</span><br><span class="line">                dexfilefp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> fp=<span class="built_in">open</span>(dexfilepath,O_CREAT|O_APPEND|O_RDWR,<span class="number">0666</span>);</span><br><span class="line">                <span class="keyword">if</span>(fp&gt;<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                      <span class="comment">//将要保存的数据写入文件，这种应该是属于整体dump</span></span><br><span class="line">                    result=<span class="built_in">write</span>(fp,(<span class="keyword">void</span>*)begin_,size_);</span><br><span class="line">                    <span class="keyword">if</span>(result&lt;<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        LOG(ERROR) &lt;&lt; <span class="string">&quot;ArtMethod::dumpdexfilebyArtMethod,open dexfilepath file error&quot;</span>;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    fsync(fp);</span><br><span class="line">                    <span class="built_in">close</span>(fp);</span><br><span class="line">                      <span class="comment">//下面是把所有类名写入文件保存。方便搜索。可能修复的时候也会用到这个文件</span></span><br><span class="line">                    <span class="built_in">memset</span>(dexfilepath,<span class="number">0</span>,<span class="number">1000</span>);</span><br><span class="line">                    <span class="built_in">sprintf</span>(dexfilepath,<span class="string">&quot;/sdcard/fart/%s/%d_classlist.txt&quot;</span>,szProcName,size_int_);</span><br><span class="line">                    <span class="keyword">int</span> classlistfile=<span class="built_in">open</span>(dexfilepath,O_CREAT|O_APPEND|O_RDWR,<span class="number">0666</span>);</span><br><span class="line">                    <span class="keyword">if</span>(classlistfile&gt;<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                          <span class="comment">//这里我瞅着眼熟，然后翻了下。其实就是参考GetClassNames的处理。获取了所有的类名列表，然后写入文件</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">size_t</span> ii= <span class="number">0</span>; ii&lt; dex_file-&gt;NumClassDefs(); ++ii)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">const</span> DexFile::ClassDef&amp; class_def = dex_file-&gt;GetClassDef(ii);</span><br><span class="line">                            <span class="keyword">const</span> <span class="keyword">char</span>* descriptor = dex_file-&gt;GetClassDescriptor(class_def);</span><br><span class="line">                            result=<span class="built_in">write</span>(classlistfile,(<span class="keyword">void</span>*)descriptor,<span class="built_in">strlen</span>(descriptor));</span><br><span class="line">                            <span class="keyword">if</span>(result&lt;<span class="number">0</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                                LOG(ERROR) &lt;&lt; <span class="string">&quot;ArtMethod::dumpdexfilebyArtMethod,write classlistfile file error&quot;</span>;</span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">const</span> <span class="keyword">char</span>* temp=<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                            result=<span class="built_in">write</span>(classlistfile,(<span class="keyword">void</span>*)temp,<span class="number">1</span>);</span><br><span class="line">                            <span class="keyword">if</span>(result&lt;<span class="number">0</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                                LOG(ERROR) &lt;&lt; <span class="string">&quot;ArtMethod::dumpdexfilebyArtMethod,write classlistfile file error&quot;</span>;</span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        fsync(classlistfile);</span><br><span class="line">                        <span class="built_in">close</span>(classlistfile);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">              <span class="comment">//下面是要对函数进行dump</span></span><br><span class="line">            <span class="keyword">const</span> DexFile::CodeItem* code_item = artmethod-&gt;GetCodeItem();</span><br><span class="line">            <span class="keyword">if</span> (LIKELY(code_item != <span class="literal">nullptr</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> code_item_len = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">uint8_t</span> *item=(<span class="keyword">uint8_t</span> *) code_item;</span><br><span class="line">                  <span class="comment">//这里表示是否有try，因为try的数量会影响函数的大小，我们dump需要函数的位置和计算出函数大小。</span></span><br><span class="line">                <span class="keyword">if</span> (code_item-&gt;tries_size_&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                      <span class="comment">//有try的情况计算比较复杂，这个codeitem_end里面封装了一系列的计算，我感觉好像是获取了try的数量，然后再一系列的计算，最终得到的函数大小</span></span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">uint8_t</span> *handler_data = (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)(DexFile::GetTryItems(*code_item, code_item-&gt;tries_size_));</span><br><span class="line">                    <span class="keyword">uint8_t</span> * tail = codeitem_end(&amp;handler_data);</span><br><span class="line">                    code_item_len = (<span class="keyword">int</span>)(tail - item);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                      <span class="comment">//如果没有try的情况。就简单的可以计算出来。</span></span><br><span class="line">                    code_item_len = <span class="number">16</span>+code_item-&gt;insns_size_in_code_units_*<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                  <span class="comment">//有了函数的大小和位置后，这里又获取了函数的index</span></span><br><span class="line">                <span class="built_in">memset</span>(dexfilepath,<span class="number">0</span>,<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">int</span> size_int=(<span class="keyword">int</span>)dex_file-&gt;Size();</span><br><span class="line">                <span class="keyword">uint32_t</span> method_idx=artmethod-&gt;GetDexMethodIndexUnchecked();</span><br><span class="line">                  <span class="comment">//最后把获取到的相关数据按照特定的格式写入.bin的文件中。这个文件后面就可以拿来做修复dex。因为已经有了对每个函数的详细描述了。</span></span><br><span class="line">                <span class="built_in">sprintf</span>(dexfilepath,<span class="string">&quot;/sdcard/fart/%s/%d_ins_%d.bin&quot;</span>,szProcName,size_int,(<span class="keyword">int</span>)gettidv1());</span><br><span class="line">                <span class="keyword">int</span> fp2=<span class="built_in">open</span>(dexfilepath,O_CREAT|O_APPEND|O_RDWR,<span class="number">0666</span>);</span><br><span class="line">                <span class="keyword">if</span>(fp2&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    lseek(fp2,<span class="number">0</span>,SEEK_END);</span><br><span class="line">                    <span class="built_in">memset</span>(dexfilepath,<span class="number">0</span>,<span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">int</span> offset=(<span class="keyword">int</span>)(item - begin_);</span><br><span class="line">                    <span class="built_in">sprintf</span>(dexfilepath,<span class="string">&quot;&#123;name:%s,method_idx:%d,offset:%d,code_item_len:%d,ins:&quot;</span>,artmethod-&gt;PrettyMethod().c_str(),method_idx,offset,code_item_len);</span><br><span class="line">                    <span class="keyword">int</span> contentlength=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span>(dexfilepath[contentlength]!=<span class="number">0</span>) contentlength++;</span><br><span class="line">                    result=<span class="built_in">write</span>(fp2,(<span class="keyword">void</span>*)dexfilepath,contentlength);</span><br><span class="line">                    <span class="keyword">if</span>(result&lt;<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        LOG(ERROR) &lt;&lt; <span class="string">&quot;ArtMethod::dumpdexfilebyArtMethod,write ins file error&quot;</span>;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">long</span> outlen=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">char</span>* base64result=base64_encode((<span class="keyword">char</span>*)item,(<span class="keyword">long</span>)code_item_len,&amp;outlen);</span><br><span class="line">                    result=<span class="built_in">write</span>(fp2,base64result,outlen);</span><br><span class="line">                    <span class="keyword">if</span>(result&lt;<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        LOG(ERROR) &lt;&lt; <span class="string">&quot;ArtMethod::dumpdexfilebyArtMethod,write ins file error&quot;</span>;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    result=<span class="built_in">write</span>(fp2,<span class="string">&quot;&#125;;&quot;</span>,<span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">if</span>(result&lt;<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        LOG(ERROR) &lt;&lt; <span class="string">&quot;ArtMethod::dumpdexfilebyArtMethod,write ins file error&quot;</span>;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    fsync(fp2);</span><br><span class="line">                    <span class="built_in">close</span>(fp2);</span><br><span class="line">                    <span class="keyword">if</span>(base64result!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                        <span class="built_in">free</span>(base64result);</span><br><span class="line">                        base64result=<span class="literal">nullptr</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dexfilepath!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(dexfilepath);</span><br><span class="line">            dexfilepath=<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再贴一个codeitem_end是怎么计算包含try的函数大小</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint8_t</span>* <span class="title">codeitem_end</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span> **pData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> num_of_list = DecodeUnsignedLeb128(pData);</span><br><span class="line">  <span class="keyword">for</span> (;num_of_list&gt;<span class="number">0</span>;num_of_list--) &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> num_of_handlers=DecodeSignedLeb128(pData);</span><br><span class="line">    <span class="keyword">int</span> num=num_of_handlers;</span><br><span class="line">    <span class="keyword">if</span> (num_of_handlers&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">      num=-num_of_handlers;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; num &gt; <span class="number">0</span>; num--) &#123;</span><br><span class="line">      DecodeUnsignedLeb128(pData);</span><br><span class="line">      DecodeUnsignedLeb128(pData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num_of_handlers&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">      DecodeUnsignedLeb128(pData);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">uint8_t</span>*)(*pData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里fart的主动调用脱壳流程基本完成。当然还有一些辅助frida的处理函数，下面贴一些大神为了方便我们使用frida来处理而包装的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反射获取指定类的指定字段</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Field <span class="title">getClassField</span><span class="params">(ClassLoader classloader, String class_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      String filedName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class obj_class = classloader.loadClass(class_name);<span class="comment">//Class.forName(class_name);</span></span><br><span class="line">            Field field = obj_class.getDeclaredField(filedName);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> field;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//反射获取指定对象的指定字段的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getClassFieldObject</span><span class="params">(ClassLoader classloader, String class_name, Object obj,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             String filedName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class obj_class = classloader.loadClass(class_name);<span class="comment">//Class.forName(class_name);</span></span><br><span class="line">            Field field = obj_class.getDeclaredField(filedName);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Object result = <span class="keyword">null</span>;</span><br><span class="line">            result = field.get(obj);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//反射获取指定对象的指定字段的值。这里注意和上面一个函数的区别是，上面使用了loadClass获取类，这里使用forName获取的，两者获取的class对象是不同的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getFieldOjbect</span><span class="params">(String class_name, Object obj,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        String filedName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class obj_class = Class.forName(class_name);</span><br><span class="line">            Field field = obj_class.getDeclaredField(filedName);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> field.get(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//反射调用指定类的指定函数,并返回结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">invokeStaticMethod</span><span class="params">(String class_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            String method_name, Class[] pareTyple, Object[] pareVaules)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class obj_class = Class.forName(class_name);</span><br><span class="line">            Method method = obj_class.getMethod(method_name, pareTyple);</span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">null</span>, pareVaules);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>最后贴一下简单的流程图。</p><p><img src="/2020/11/03/fart/image-20201112222727442.png" alt="image-20201112222727442"></p><p>如果写的有啥问题。希望大佬们能指正。</p>]]></content>
      
      
      <categories>
          
          <category> fart </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AndroidNativeEmu和unidbg对抗ollvm的字符串混淆</title>
      <link href="/2020/11/03/unicorn2/"/>
      <url>/2020/11/03/unicorn2/</url>
      
        <content type="html"><![CDATA[<p>AndroidNativeEmu和unidbg都是对unicorn进行了一定程度封装的开源项目，让我们可以很方便的调用jni函数，以及对没有实现的函数进行hook实现处理。并且让我们可以实现so里面模拟调用java函数。下面首先使用AndroidNativeEmu来对抗ollvm的字符串混淆。对so进行修复。让我们可以更加便捷的进行静态分析。</p><p>在实现之前，先总结下原理。</p><p>ollvm的字符串混淆，我们使用ida的时候。看到的结果如下。</p><p><img src="/2020/11/03/unicorn2/image-20201226224303113.png" alt="image-20201226224303113"></p><p>这里相当于是一个解密函数。通过这个函数将会还原成正常的字符串。然后我们看看在哪里调用到了这个解密函数</p><p><img src="/2020/11/03/unicorn2/image-20201226224514551.png" alt="image-20201226224514551"></p><p>可以看到是在.init_array中使用解密函数对字符串进行还原。也就是说。当我们执行完.init_array后。就会将正常的字符串写入内存中。这时我们就得到了真正的字符串了。所以根据这个情况。</p><a id="more"></a><p>第一步，我们需要监控内存的读写，然后运行.init_array。这样发生的内存写入时，基本可以确定是字符串还原函数在写入恢复的字符串。</p><p>写之前我们先看看unicorn的内存写入的相关注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">  Callback function for hooking memory (READ, WRITE &amp; FETCH)</span><br><span class="line">  @type: this memory is being READ, or WRITE</span><br><span class="line">  @address: address where the code is being executed</span><br><span class="line">  @size: size of data being read or written</span><br><span class="line">  @value: value of data being written to memory, or irrelevant if type &#x3D; READ.</span><br><span class="line">  @user_data: user data passed to tracing APIs</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p>这里就知道了。size是写入或读取数据的长度,value是写入或读取的数据。那么开始写我们第一步的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> unicorn <span class="keyword">import</span> UC_HOOK_MEM_WRITE</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> androidemu.emulator <span class="keyword">import</span> Emulator</span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure logging</span></span><br><span class="line">logging.basicConfig(</span><br><span class="line">    stream=sys.stdout,</span><br><span class="line">    level=logging.DEBUG,</span><br><span class="line">    format=<span class="string">&quot;%(asctime)s %(levelname)7s %(name)34s | %(message)s&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook_mem_write</span>(<span class="params">uc,type,address,size,value,userdata</span>):</span></span><br><span class="line">    curdata=struct.pack(<span class="string">&quot;I&quot;</span>,value)[:size]</span><br><span class="line">    print(curdata)</span><br><span class="line"></span><br><span class="line">emulator = Emulator(vfp_inst_set=<span class="literal">True</span>)</span><br><span class="line">emulator.load_library(<span class="string">&quot;example_binaries/libc.so&quot;</span>, do_init=<span class="literal">False</span>)</span><br><span class="line"><span class="comment">#设置内存的写入监控</span></span><br><span class="line">emulator.mu.hook_add(UC_HOOK_MEM_WRITE, hook_mem_write)</span><br><span class="line"><span class="comment">#后面的do_init为true就会调用.init_array</span></span><br><span class="line">lib_module = emulator.load_library(<span class="string">&quot;example_binaries/obf.so&quot;</span>, do_init=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出的结果如下</p><p><img src="/2020/11/03/unicorn2/image-20201226230857391.png" alt="image-20201226230857391"></p><p>这里能看到。真实的字符串已经能在回调监控中打印出来了。接下来的第二步，我们需要把所有真实字符串以及写入真实字符串的位置给保存下来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dstr_datas=&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook_mem_write</span>(<span class="params">uc,type,address,size,value,userdata</span>):</span></span><br><span class="line">    curdata=struct.pack(<span class="string">&quot;I&quot;</span>,value)[:size]</span><br><span class="line">    dstr_datas[address]=curdata</span><br><span class="line">    print(curdata)</span><br></pre></td></tr></table></figure><p>这样我们就将init_array过程中所有还原出来的真实字符串给保存下来了。最后我们要将我们的真实字符串再写回so中。那么写回到哪里呢？我们监控内存写入时，当时是给什么地址写入数据。我们就写入到哪里。这样我们写入的so就能直接在ida中打开就看到真实字符串了。在写入时需要注意的是。我们保存的address是有一个基址的。也就是说。我们写入时需要减掉基址。才是真正应该写入的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取到基址</span></span><br><span class="line">base_addr=lib_module.base</span><br><span class="line">sofile=open(<span class="string">&quot;example_binaries/obf.so&quot;</span>,<span class="string">&quot;rb&quot;</span>)</span><br><span class="line"><span class="comment">#我们要将真实的字符串回填到sodata中。然后再保存</span></span><br><span class="line">sodata=sofile.read()</span><br><span class="line"><span class="keyword">for</span> address,v <span class="keyword">in</span> dstr_datas.items():</span><br><span class="line">    <span class="comment">#仅仅将so范围内的保存原字符串进行写回</span></span><br><span class="line">    <span class="keyword">if</span> address &gt; base_addr <span class="keyword">and</span> address &lt; base_addr+lib_module.size:</span><br><span class="line">        offset=address-base_addr</span><br><span class="line">        print(<span class="string">&quot;address:0x%x data:%s offset:0x%x&quot;</span> % (address, v,offset))</span><br></pre></td></tr></table></figure><p>然后我贴上几行打印的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">address:0xcbc6a004 data:b&#39;j&#39; offset:0x4004</span><br><span class="line">address:0xcbc6a005 data:b&#39;n&#39; offset:0x4005</span><br><span class="line">address:0xcbc6a006 data:b&#39;i&#39; offset:0x4006</span><br><span class="line">address:0xcbc6a007 data:b&#39;\x00&#39; offset:0x4007</span><br><span class="line">address:0xcbc6a008 data:b&#39;g&#39; offset:0x4008</span><br></pre></td></tr></table></figure><p>第一个offset的偏移是0x4004。那么我们打开ida检查一下。是否对的上</p><p><img src="/2020/11/03/unicorn2/image-20201226233552569.png" alt="image-20201226233552569"></p><p>能看到ida里面显示的确实是对的上的。但是这里要留意最左下角的00003004。实际这个才是文件中的真实位置。所以我们这里直接写回so要再将offset-0x1000。下面我们开始将so的数据修改。并且保存成一个新的文件。最后贴上完整代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> unicorn <span class="keyword">import</span> UC_HOOK_MEM_WRITE</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> androidemu.emulator <span class="keyword">import</span> Emulator</span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure logging</span></span><br><span class="line">logging.basicConfig(</span><br><span class="line">    stream=sys.stdout,</span><br><span class="line">    level=logging.DEBUG,</span><br><span class="line">    format=<span class="string">&quot;%(asctime)s %(levelname)7s %(name)34s | %(message)s&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line">dstr_datas=&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook_mem_write</span>(<span class="params">uc,type,address,size,value,userdata</span>):</span></span><br><span class="line">    curdata=struct.pack(<span class="string">&quot;I&quot;</span>,value)[:size]</span><br><span class="line">    dstr_datas[address]=curdata</span><br><span class="line">    <span class="comment"># print(curdata)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">emulator = Emulator(vfp_inst_set=<span class="literal">True</span>)</span><br><span class="line">emulator.load_library(<span class="string">&quot;example_binaries/libc.so&quot;</span>, do_init=<span class="literal">False</span>)</span><br><span class="line"><span class="comment">#设置内存的写入监控</span></span><br><span class="line">emulator.mu.hook_add(UC_HOOK_MEM_WRITE, hook_mem_write)</span><br><span class="line"><span class="comment">#后面的do_init为true就会调用.init_array</span></span><br><span class="line">modulePath=<span class="string">&quot;example_binaries/obf.so&quot;</span></span><br><span class="line">lib_module = emulator.load_library(modulePath, do_init=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#获取到基址</span></span><br><span class="line">base_addr=lib_module.base</span><br><span class="line">sofile=open(<span class="string">&quot;example_binaries/obf.so&quot;</span>,<span class="string">&quot;rb&quot;</span>)</span><br><span class="line"><span class="comment">#我们要将真实的字符串回填到sodata中。然后再保存</span></span><br><span class="line">sodata=sofile.read()</span><br><span class="line">sofile.close()</span><br><span class="line"><span class="keyword">for</span> address,v <span class="keyword">in</span> dstr_datas.items():</span><br><span class="line">    <span class="comment">#仅仅将so范围内的保存原字符串进行写回</span></span><br><span class="line">    <span class="keyword">if</span> address &gt; base_addr <span class="keyword">and</span> address &lt; base_addr+lib_module.size:</span><br><span class="line">        offset=address-base_addr<span class="number">-0x1000</span></span><br><span class="line">        print(<span class="string">&quot;address:0x%x data:%s offset:0x%x&quot;</span> % (address, v,offset))</span><br><span class="line">        sodata=sodata[:offset]+v+sodata[offset+len(v):]</span><br><span class="line"><span class="comment">#保存成一个新的so</span></span><br><span class="line">savepath=modulePath+<span class="string">&quot;.new&quot;</span></span><br><span class="line">nfile=open(savepath,<span class="string">&quot;wb&quot;</span>)</span><br><span class="line">nfile.write(sodata)</span><br><span class="line">nfile.close()</span><br></pre></td></tr></table></figure><p>那么实际效果怎么样呢。我们打开ida来对比一下修改前和修改后的效果</p><p>修改前</p><p><img src="/2020/11/03/unicorn2/image-20201226235237400.png" alt="image-20201226235237400"></p><p>修改后</p><p><img src="/2020/11/03/unicorn2/image-20201226235259045.png" alt="image-20201226235259045"></p><p>接着再使用unidbg来实现一次字符串的反混淆</p><p>按照上面的思路。我们首先设置内存写入的监控，然后加载so。而unidbg在加载的时候。就会自动的执行init和init_array。所以我们接下来看看unidbg是怎么进行内存的写入监控的。搜索一下unidbg源码。就能找到是如何使用的了。我们搜索hook_add_new</p><p><img src="/2020/11/03/unicorn2/image-20201227140011353.png" alt="image-20201227140011353"></p><p>这里我们就知道了是设置了一个TraceMemoryHook对象进行监控的。由于我们是需要自己修改里面监控后的逻辑。所以不要变动他原有的。拷贝一份出来。然后删除里面原有的打印逻辑。再加上我们之前逻辑。也就是打印一下写入的数据。将监控到的写入数据和写入地址给保存起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeStrWriteHook</span> <span class="keyword">implements</span> <span class="title">WriteHook</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> read;</span><br><span class="line"></span><br><span class="line">    DeStrWriteHook(<span class="keyword">boolean</span> read) &#123;</span><br><span class="line">        <span class="keyword">this</span>.read = read;</span><br><span class="line">    &#125;</span><br><span class="line">    PrintStream redirect;</span><br><span class="line">    TraceWriteListener traceWriteListener;</span><br><span class="line">      <span class="comment">//保存的写入数据地址和写入的数据</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;Long,<span class="keyword">byte</span>[]&gt; dstr_datas=<span class="keyword">new</span> HashMap&lt;Long,<span class="keyword">byte</span>[]&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * long类型转byte[] (大端)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] longToBytesBig(<span class="keyword">long</span> n) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line">        b[<span class="number">7</span>] = (<span class="keyword">byte</span>) (n &amp; <span class="number">0xff</span>);</span><br><span class="line">        b[<span class="number">6</span>] = (<span class="keyword">byte</span>) (n &gt;&gt; <span class="number">8</span>  &amp; <span class="number">0xff</span>);</span><br><span class="line">        b[<span class="number">5</span>] = (<span class="keyword">byte</span>) (n &gt;&gt; <span class="number">16</span> &amp; <span class="number">0xff</span>);</span><br><span class="line">        b[<span class="number">4</span>] = (<span class="keyword">byte</span>) (n &gt;&gt; <span class="number">24</span> &amp; <span class="number">0xff</span>);</span><br><span class="line">        b[<span class="number">3</span>] = (<span class="keyword">byte</span>) (n &gt;&gt; <span class="number">32</span> &amp; <span class="number">0xff</span>);</span><br><span class="line">        b[<span class="number">2</span>] = (<span class="keyword">byte</span>) (n &gt;&gt; <span class="number">40</span> &amp; <span class="number">0xff</span>);</span><br><span class="line">        b[<span class="number">1</span>] = (<span class="keyword">byte</span>) (n &gt;&gt; <span class="number">48</span> &amp; <span class="number">0xff</span>);</span><br><span class="line">        b[<span class="number">0</span>] = (<span class="keyword">byte</span>) (n &gt;&gt; <span class="number">56</span> &amp; <span class="number">0xff</span>);</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * long类型转byte[] (小端)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] longToBytesLittle(<span class="keyword">long</span> n) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line">        b[<span class="number">0</span>] = (<span class="keyword">byte</span>) (n &amp; <span class="number">0xff</span>);</span><br><span class="line">        b[<span class="number">1</span>] = (<span class="keyword">byte</span>) (n &gt;&gt; <span class="number">8</span>  &amp; <span class="number">0xff</span>);</span><br><span class="line">        b[<span class="number">2</span>] = (<span class="keyword">byte</span>) (n &gt;&gt; <span class="number">16</span> &amp; <span class="number">0xff</span>);</span><br><span class="line">        b[<span class="number">3</span>] = (<span class="keyword">byte</span>) (n &gt;&gt; <span class="number">24</span> &amp; <span class="number">0xff</span>);</span><br><span class="line">        b[<span class="number">4</span>] = (<span class="keyword">byte</span>) (n &gt;&gt; <span class="number">32</span> &amp; <span class="number">0xff</span>);</span><br><span class="line">        b[<span class="number">5</span>] = (<span class="keyword">byte</span>) (n &gt;&gt; <span class="number">40</span> &amp; <span class="number">0xff</span>);</span><br><span class="line">        b[<span class="number">6</span>] = (<span class="keyword">byte</span>) (n &gt;&gt; <span class="number">48</span> &amp; <span class="number">0xff</span>);</span><br><span class="line">        b[<span class="number">7</span>] = (<span class="keyword">byte</span>) (n &gt;&gt; <span class="number">56</span> &amp; <span class="number">0xff</span>);</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hook</span><span class="params">(Backend backend, <span class="keyword">long</span> address, <span class="keyword">int</span> size, <span class="keyword">long</span> value, Object user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (read) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Emulator&lt;?&gt; emulator = (Emulator&lt;?&gt;) user;</span><br><span class="line">            <span class="keyword">if</span> (traceWriteListener == <span class="keyword">null</span> || traceWriteListener.onWrite(emulator, address, size, value)) &#123;</span><br><span class="line">                <span class="comment">//将写入的地址和写入的数据保存下来，先转long为小端序</span></span><br><span class="line">                <span class="keyword">byte</span>[] writedata=longToBytesLittle(value);</span><br><span class="line">                <span class="keyword">byte</span>[] resizeWriteData=<span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">                  <span class="comment">//将指定大小的数据保存</span></span><br><span class="line">                System.arraycopy(writedata,<span class="number">0</span>,resizeWriteData,<span class="number">0</span>,size);</span><br><span class="line">                dstr_datas.put(address,resizeWriteData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BackendException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们按之前的步骤。使用这个类来hook。并且遍历一下我们保存出来的结果看和AndroidNativeEmu是不是一致的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DestrOllvm</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AndroidEmulator emulator;</span><br><span class="line">    <span class="keyword">public</span> DeStrWriteHook trace;</span><br><span class="line">    <span class="keyword">public</span> Module <span class="keyword">module</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DestrOllvm</span><span class="params">()</span></span>&#123;</span><br><span class="line">        emulator=<span class="keyword">new</span> AndroidARMEmulator(<span class="string">&quot;com.example.unicorncourse08&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            trace = <span class="keyword">new</span> DeStrWriteHook(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">final</span> Memory memory=emulator.getMemory();</span><br><span class="line">            LibraryResolver resolver = <span class="keyword">new</span> AndroidResolver(<span class="number">23</span>);</span><br><span class="line">            memory.setLibraryResolver(resolver);</span><br><span class="line">            emulator.getBackend().hook_add_new(trace,<span class="number">1</span>,<span class="number">0</span>,emulator);</span><br><span class="line">            <span class="keyword">module</span>=emulator.loadLibrary(<span class="keyword">new</span> File(<span class="string">&quot;unidbg-android/src/test/resources/example_binaries/obf.so&quot;</span>));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] readFile(String strFile)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            InputStream is = <span class="keyword">new</span> FileInputStream(strFile);</span><br><span class="line">            <span class="keyword">int</span> iAvail = is.available();</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[iAvail];</span><br><span class="line">            is.read(bytes);</span><br><span class="line">            is.close();</span><br><span class="line">            <span class="keyword">return</span> bytes;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        DestrOllvm destr=<span class="keyword">new</span> DestrOllvm();</span><br><span class="line">        String savepath=<span class="string">&quot;unidbg-android/src/test/resources/example_binaries/obf.so.new&quot;</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] sodata=readFile(<span class="string">&quot;unidbg-android/src/test/resources/example_binaries/obf.so&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> base_addr=destr.<span class="keyword">module</span>.base;</span><br><span class="line">        <span class="keyword">long</span> module_size=destr.<span class="keyword">module</span>.size;</span><br><span class="line">        <span class="comment">//遍历保存的写入地址和写入数据</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Long, <span class="keyword">byte</span>[]&gt; item : destr.trace.dstr_datas.entrySet())&#123;</span><br><span class="line">            <span class="comment">//如果范围是在模块内的。则进行处理</span></span><br><span class="line">            <span class="keyword">if</span>(item.getKey()&gt;base_addr &amp;&amp; item.getKey()&lt;base_addr+module_size)&#123;</span><br><span class="line">                <span class="keyword">long</span> offset=item.getKey()-base_addr-<span class="number">0x1000</span>;</span><br><span class="line">                System.out.println(String.format(<span class="string">&quot;address:0x%x data:%s&quot;</span>,offset, OtherTools.byteToString(item.getValue())));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后看看打印的结果和之前是不是差不多的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">address:0x3004 data:6A</span><br><span class="line">address:0x3005 data:6E</span><br><span class="line">address:0x3006 data:69</span><br><span class="line">address:0x3007 data:00</span><br><span class="line">address:0x3008 data:67</span><br><span class="line">address:0x3009 data:6F</span><br><span class="line">address:0x300a data:20</span><br><span class="line">address:0x300b data:69</span><br><span class="line">address:0x300c data:6E</span><br></pre></td></tr></table></figure><p>对比AndroidNativeEmu的日志是正确的。那么我们完成最后的步骤。生成新的so文件，下面贴上完整代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DestrOllvm</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AndroidEmulator emulator;</span><br><span class="line">    <span class="keyword">public</span> DeStrWriteHook trace;</span><br><span class="line">    <span class="keyword">public</span> Module <span class="keyword">module</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DestrOllvm</span><span class="params">()</span></span>&#123;</span><br><span class="line">        emulator=<span class="keyword">new</span> AndroidARMEmulator(<span class="string">&quot;com.example.unicorncourse08&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            trace = <span class="keyword">new</span> DeStrWriteHook(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">final</span> Memory memory=emulator.getMemory();</span><br><span class="line">              <span class="comment">//这里的android版本指定后会自动load相关的so</span></span><br><span class="line">            LibraryResolver resolver = <span class="keyword">new</span> AndroidResolver(<span class="number">23</span>);</span><br><span class="line">            memory.setLibraryResolver(resolver);</span><br><span class="line">              <span class="comment">//设置内存写入的监控</span></span><br><span class="line">            emulator.getBackend().hook_add_new(trace,<span class="number">1</span>,<span class="number">0</span>,emulator);</span><br><span class="line">            <span class="keyword">module</span>=emulator.loadLibrary(<span class="keyword">new</span> File(<span class="string">&quot;unidbg-android/src/test/resources/example_binaries/obf.so&quot;</span>));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] readFile(String strFile)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            InputStream is = <span class="keyword">new</span> FileInputStream(strFile);</span><br><span class="line">            <span class="keyword">int</span> iAvail = is.available();</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[iAvail];</span><br><span class="line">            is.read(bytes);</span><br><span class="line">            is.close();</span><br><span class="line">            <span class="keyword">return</span> bytes;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">(<span class="keyword">byte</span>[] data,String savefile)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileOutputStream fos=<span class="keyword">new</span> FileOutputStream(savefile);</span><br><span class="line">            BufferedOutputStream bos=<span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line">            bos.write(data,<span class="number">0</span>,data.length);</span><br><span class="line">            bos.flush();</span><br><span class="line">            bos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        DestrOllvm destr=<span class="keyword">new</span> DestrOllvm();</span><br><span class="line">        String savepath=<span class="string">&quot;unidbg-android/src/test/resources/example_binaries/obf.so.new&quot;</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] sodata=readFile(<span class="string">&quot;unidbg-android/src/test/resources/example_binaries/obf.so&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> base_addr=destr.<span class="keyword">module</span>.base;</span><br><span class="line">        <span class="keyword">long</span> module_size=destr.<span class="keyword">module</span>.size;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="comment">//遍历保存的写入地址和写入数据</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Long, <span class="keyword">byte</span>[]&gt; item : destr.trace.dstr_datas.entrySet())&#123;</span><br><span class="line">            <span class="comment">//如果范围是在模块内的。则进行处理</span></span><br><span class="line">            <span class="keyword">if</span>(item.getKey()&gt;base_addr &amp;&amp; item.getKey()&lt;base_addr+module_size)&#123;</span><br><span class="line">                <span class="comment">//获取到正确的写入的偏移位置</span></span><br><span class="line">                baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                Long offset=item.getKey()-base_addr-<span class="number">0x1000</span>;</span><br><span class="line">                System.out.println(String.format(<span class="string">&quot;address:0x%x data:%s&quot;</span>,offset, OtherTools.byteToString(item.getValue())));</span><br><span class="line">                <span class="comment">//先把前半部分取出来</span></span><br><span class="line">                <span class="keyword">byte</span>[] start=<span class="keyword">new</span> <span class="keyword">byte</span>[offset.intValue()];</span><br><span class="line">                System.arraycopy(sodata,<span class="number">0</span>,start,<span class="number">0</span>,offset.intValue());</span><br><span class="line">                <span class="comment">//然后把后半部分的大小计算出来</span></span><br><span class="line">                <span class="keyword">int</span> endsize=sodata.length-offset.intValue()-item.getValue().length;</span><br><span class="line">                <span class="comment">//把后半部分的数据填充上</span></span><br><span class="line">                <span class="keyword">byte</span>[] end=<span class="keyword">new</span> <span class="keyword">byte</span>[endsize];</span><br><span class="line">                System.arraycopy(sodata,offset.intValue()+item.getValue().length,end,<span class="number">0</span>,endsize);</span><br><span class="line">                <span class="comment">//将三块位置的数据填充上</span></span><br><span class="line">                baos.write(start,<span class="number">0</span>,start.length);</span><br><span class="line">                baos.write(item.getValue(),<span class="number">0</span>,item.getValue().length);</span><br><span class="line">                baos.write(end,<span class="number">0</span>,end.length);</span><br><span class="line">                <span class="comment">//最后把so保存起来</span></span><br><span class="line">                sodata=baos.toByteArray();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        writeFile(baos.toByteArray(),savepath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后ida打开一下生成的so看看结果</p><p><img src="/2020/11/03/unicorn2/image-20201227174742591.png" alt="image-20201227174742591"></p><p>最后我们将libcrypt.so以及libcrack.so都直接用unidbg跑一次。然后下面贴上ida查看这两个so的结果</p><p>Libcrypt.so的ida结果如下</p><p><img src="/2020/11/03/unicorn2/image-20201227175609064.png" alt="image-20201227175609064"></p><p>Libcrack.so的ida结果如下</p><p><img src="/2020/11/03/unicorn2/image-20201227233004184.png" alt="image-20201227233004184"></p>]]></content>
      
      
      <categories>
          
          <category> unicorn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unicorn初学</title>
      <link href="/2020/10/16/unicorn1/"/>
      <url>/2020/10/16/unicorn1/</url>
      
        <content type="html"><![CDATA[<p>unicorn相当于是一个cpu的模拟器，可以用来执行so中的代码段，一般不要直接使用apk中的so文件，直接使用是需要修复上下文的，这样会比较复杂。最好是直接从内存中直接dump一个so出来。然后就可以直接执行so里面的代码段。然后看一个例子ollvm9.apk</p><p>样品下载地址: <a href="https://pan.baidu.com/s/1ynsGvKAUbmvodvjG0mlLVg">https://pan.baidu.com/s/1ynsGvKAUbmvodvjG0mlLVg</a>  密码: wu45</p><p>解密案例:<a href="https://github.com/dqzg12300/unicornDemo">https://github.com/dqzg12300/unicornDemo</a></p><a id="more"></a><p>首先用jadx打开这个apk。看看里面的按钮的功能</p><p><img src="/2020/10/16/unicorn1/image-20201016210946663.png" alt="image-20201016210946663"></p><p>然后看到这里主要用到了UUIDCheckSum这个函数来进行加密</p><p>解压这个apk。用ida打开libnative-lib.so找到UUIDCheckSum函数。发现这个函数是ollvm混淆的。然后找入参的使用，发现了一个关键函数。</p><p><img src="/2020/10/16/unicorn1/image-20201016211429655.png" alt="image-20201016211429655"></p><p>然后我们想要用unicorn来执行这个函数。首先找到函数的起始和终止位置，这个函数我找到是start:0xfcb4  end:0xff2c</p><p>直接使用我们这个ida查看的so文件是不行了。最好是在真机执行时从内存中dump这个so出来。就是拥有完整上下文信息的。这里我使用了大佬的工具来dump</p><p><a href="https://github.com/lasting-yang/frida_dump">https://github.com/lasting-yang/frida_dump</a></p><p>使用起来也是非常简单</p><p><code>frida -U com.kanxue.ollvm_ndk_9 -l dump_so.js</code></p><p><code>dump_so(&quot;libnative-lib.so&quot;)</code></p><p>执行后生成了一个so文件libnative-lib.so_0x7eae047000_0x38000.so。将这个文件拷贝到py项目下。</p><p>接着梳理一下想要写一个使用unicorn来执行的流程。</p><p>1、创建一个unicorn对象</p><p>2、使用unicorn创建一块内存，用来存放这个so代码</p><p>3、使用unicorn创建一块内存，用来存放栈空间</p><p>4、使用unicorn创建一块内存，用来存放要执行函数的参数</p><p>5、读取so，将so写入到上面预先创建的内存中。</p><p>6、给参数的那块内存赋值</p><p>7、给寄存器赋值（x0,x1,sp），X0就是ida函数中看到的第一个参数，X1就是第二个参数</p><p>8、unicorn启动执行指定片段的代码</p><p>9、读取执行结果</p><p>10、释放创建的内存</p><p>然后下面看一下实现的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    initGlobalData()</span><br><span class="line">    <span class="comment">#创建uc对象</span></span><br><span class="line">    uc=unicorn.Uc(unicorn.UC_ARCH_ARM64,unicorn.UC_MODE_ARM)</span><br><span class="line">    <span class="comment">#从内存中dump下来so的基址</span></span><br><span class="line">    code_addr=<span class="number">0x7eae047000</span></span><br><span class="line">    <span class="comment">#用来存放so代码的大小，尽量大一点。内存不值钱</span></span><br><span class="line">    code_size=<span class="number">8</span>*<span class="number">0x1000</span>*<span class="number">0x1000</span></span><br><span class="line">    <span class="comment">#创建一块内存</span></span><br><span class="line">    uc.mem_map(code_addr,code_size)</span><br><span class="line">    <span class="comment">#在上面那块内存后面继续划一片内存来当做栈空间</span></span><br><span class="line">    stack_addr=code_addr+code_size</span><br><span class="line">    stack_size=<span class="number">0x1000</span></span><br><span class="line">    <span class="comment">#栈顶的位置，这里是64位的，所以偏移8个字节</span></span><br><span class="line">    stack_top=stack_addr+stack_size<span class="number">-0x8</span></span><br><span class="line">    <span class="comment">#申请一块栈空间</span></span><br><span class="line">    uc.mem_map(stack_addr,stack_size)</span><br><span class="line">    <span class="comment">#栈空间往后继续划一块空间用来存放参数</span></span><br><span class="line">    args_addr=stack_addr+stack_size</span><br><span class="line">    args_size=<span class="number">0x1000</span></span><br><span class="line">    uc.mem_map(args_addr, args_size)</span><br><span class="line">    <span class="comment">#设置每句汇编执行都会调用hook_code</span></span><br><span class="line">    <span class="comment">#uc.hook_add(unicorn.UC_HOOK_CODE,hook_code)</span></span><br><span class="line">    <span class="comment">#读取so</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&quot;./libnative-lib.so_0x7eae047000_0x38000.so&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        sodata=f.read()</span><br><span class="line">        <span class="comment">#给前面创建的空间写入so的数据</span></span><br><span class="line">        uc.mem_write(code_addr,sodata)</span><br><span class="line">        <span class="comment">#要执行的代码开始位置</span></span><br><span class="line">        start_addr=code_addr+<span class="number">0xFCB4</span></span><br><span class="line">        <span class="comment">#要执行的代码结束位置</span></span><br><span class="line">        end_addr=code_addr+<span class="number">0xFF2C</span></span><br><span class="line">        <span class="comment">#随机生成一个入参</span></span><br><span class="line">        input_str = ranstr(<span class="number">36</span>)</span><br><span class="line">        print(<span class="string">&quot;input:%s input_addr:0x%x&quot;</span> % (input_str,args_addr))</span><br><span class="line">        input_byte=str.encode(input_str)</span><br><span class="line">        <span class="comment">#将生成的入参写入前面创建的内存空间</span></span><br><span class="line">        uc.mem_write(args_addr,input_byte)</span><br><span class="line">        <span class="comment">#ida中看到的函数有参数1、2，然后分别对应X0和X1，写入对应数据，栈寄存器给一个栈顶的地址</span></span><br><span class="line">        uc.reg_write(unicorn.arm64_const.UC_ARM64_REG_X0,args_addr)</span><br><span class="line">        uc.reg_write(unicorn.arm64_const.UC_ARM64_REG_X1,len(input_str))</span><br><span class="line">        uc.reg_write(unicorn.arm64_const.UC_ARM64_REG_SP,stack_top)</span><br><span class="line">        <span class="comment">#开始执行代码段</span></span><br><span class="line">        uc.emu_start(start_addr,end_addr)</span><br><span class="line">        <span class="comment">#ida中看到返回值是直接写在入参中，所以结果我们直接从入参的内存中读取</span></span><br><span class="line">        result=uc.mem_read(args_addr,args_size)</span><br><span class="line">        print(<span class="string">&quot;result:&quot;</span>,result.decode(encoding=<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    <span class="comment">#最后释放创建的内存</span></span><br><span class="line">    uc.mem_unmap(args_addr, args_size)</span><br><span class="line">    uc.mem_unmap(stack_addr,stack_size)</span><br><span class="line">    uc.mem_unmap(code_addr,code_size)</span><br></pre></td></tr></table></figure><p>执行后，得到下面的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input:nxRH3WwuTJgUfqcOS94CM5QEkoPeF0sZ8mGj input_addr:0x7eb6048000</span><br><span class="line">result: oySI2Vvt-KfTg-4NR8-BL4Pj-nQdG1r[9laf</span><br></pre></td></tr></table></figure><p>执行这个代码段成功后，我们想的是能够将每行执行的汇编代码都打印一下。可以使用hook_add来添加一个指令执行时的回调函数，我们解开上面代码的这句注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uc.hook_add(unicorn.UC_HOOK_CODE,hook_code)</span><br></pre></td></tr></table></figure><p>然后先设置一个最简单的打印看看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook_code</span>(<span class="params">uc: unicorn.Uc, address, size, user_data</span>):</span></span><br><span class="line">    inst_code=uc.mem_read(address,size)</span><br><span class="line">    <span class="keyword">for</span> inst <span class="keyword">in</span> cs.disasm(inst_code,size):</span><br><span class="line">        print(<span class="string">&quot;0x%x:\t%s\t%s&quot;</span> % (address, inst.mnemonic, inst.op_str))</span><br></pre></td></tr></table></figure><p>设置之后的打印效果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0x7eae056f08:    ldr    x25, [sp, #0x10]</span><br><span class="line">0x7eae056f0c:    sub    w9, w10, w9</span><br><span class="line">0x7eae056f10:    strb    w8, [x0, #0x23]</span><br><span class="line">0x7eae056f14:    ldrb    w8, [x11, w9, uxtw]</span><br><span class="line">0x7eae056f18:    strb    w8, [x0, #0x22]</span><br><span class="line">0x7eae056f1c:    ldp    x20, x19, [sp, #0x40]</span><br><span class="line">0x7eae056f20:    ldp    x22, x21, [sp, #0x30]</span><br><span class="line">0x7eae056f24:    ldp    x24, x23, [sp, #0x20]</span><br><span class="line">0x7eae056f28:    add    sp, sp, #0x50</span><br></pre></td></tr></table></figure><p>但是仅仅是这样的效果还是没办法拿来分析算法，必须将每个寄存器的结果在后面打印出来，所以要改造下,下面是我根据自己的需求定制的一个trace打印</p><p>1、在每行的汇编后面打印该行中所有使用到的寄存器数据</p><p>2、在每行的最后再打印这个寄存器在计算后的结果值</p><p>3、监控指定地址的内存变动。如果数据发生改变。则打印这块内存的数据</p><p>下面看具体实现。</p><p>首先创建一个全局文件globalData.py用来存放全局变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#上一次汇编指令</span></span><br><span class="line"><span class="keyword">global</span> pre_codestr</span><br><span class="line"><span class="comment">#上一次汇编的第一个寄存器名称</span></span><br><span class="line"><span class="keyword">global</span> pre_regname</span><br><span class="line"><span class="comment">#是否有记录上一次的数据</span></span><br><span class="line"><span class="keyword">global</span> has_pre</span><br><span class="line"><span class="comment">#监控的地址</span></span><br><span class="line"><span class="keyword">global</span> watch_addrs</span><br></pre></td></tr></table></figure><p>下面贴上完整例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> unicorn</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> capstone</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> globalData</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ranstr</span>(<span class="params">num</span>):</span></span><br><span class="line">    salt = <span class="string">&#x27;&#x27;</span>.join(random.sample(string.ascii_letters + string.digits, num))</span><br><span class="line">    <span class="keyword">return</span> salt</span><br><span class="line"></span><br><span class="line">cs = capstone.Cs(capstone.CS_ARCH_ARM64, capstone.CS_MODE_ARM)</span><br><span class="line">cs.detail = <span class="literal">True</span></span><br><span class="line">all_regs = <span class="literal">None</span></span><br><span class="line">reg_names = &#123;</span><br><span class="line">    <span class="string">&quot;X0&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_X0,</span><br><span class="line">    <span class="string">&quot;X1&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_X1,</span><br><span class="line">    <span class="string">&quot;X2&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_X2,</span><br><span class="line">    <span class="string">&quot;X3&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_X3,</span><br><span class="line">    <span class="string">&quot;X4&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_X4,</span><br><span class="line">    <span class="string">&quot;X5&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_X5,</span><br><span class="line">    <span class="string">&quot;X6&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_X6,</span><br><span class="line">    <span class="string">&quot;X7&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_X7,</span><br><span class="line">    <span class="string">&quot;X8&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_X8,</span><br><span class="line">    <span class="string">&quot;X9&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_X9,</span><br><span class="line">    <span class="string">&quot;X10&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_X10,</span><br><span class="line">    <span class="string">&quot;X11&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_X11,</span><br><span class="line">    <span class="string">&quot;X12&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_X12,</span><br><span class="line">    <span class="string">&quot;X13&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_X13,</span><br><span class="line">    <span class="string">&quot;X14&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_X14,</span><br><span class="line">    <span class="string">&quot;X15&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_X15,</span><br><span class="line">    <span class="string">&quot;X16&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_X16,</span><br><span class="line">    <span class="string">&quot;X17&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_X17,</span><br><span class="line">    <span class="string">&quot;X18&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_X18,</span><br><span class="line">    <span class="string">&quot;X19&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_X19,</span><br><span class="line">    <span class="string">&quot;X20&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_X20,</span><br><span class="line">    <span class="string">&quot;X21&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_X21,</span><br><span class="line">    <span class="string">&quot;X22&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_X22,</span><br><span class="line">    <span class="string">&quot;X23&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_X23,</span><br><span class="line">    <span class="string">&quot;X24&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_X24,</span><br><span class="line">    <span class="string">&quot;X25&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_X25,</span><br><span class="line">    <span class="string">&quot;X26&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_X26,</span><br><span class="line">    <span class="string">&quot;X27&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_X27,</span><br><span class="line">    <span class="string">&quot;X28&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_X28,</span><br><span class="line">    <span class="string">&quot;W0&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_W0,</span><br><span class="line">    <span class="string">&quot;W1&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_W1,</span><br><span class="line">    <span class="string">&quot;W2&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_W2,</span><br><span class="line">    <span class="string">&quot;W3&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_W3,</span><br><span class="line">    <span class="string">&quot;W4&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_W4,</span><br><span class="line">    <span class="string">&quot;W5&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_W5,</span><br><span class="line">    <span class="string">&quot;W6&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_W6,</span><br><span class="line">    <span class="string">&quot;W7&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_W7,</span><br><span class="line">    <span class="string">&quot;W8&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_W8,</span><br><span class="line">    <span class="string">&quot;W9&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_W9,</span><br><span class="line">    <span class="string">&quot;W10&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_W10,</span><br><span class="line">    <span class="string">&quot;W11&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_W11,</span><br><span class="line">    <span class="string">&quot;W12&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_W12,</span><br><span class="line">    <span class="string">&quot;W13&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_W13,</span><br><span class="line">    <span class="string">&quot;W14&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_W14,</span><br><span class="line">    <span class="string">&quot;W15&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_W15,</span><br><span class="line">    <span class="string">&quot;W16&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_W16,</span><br><span class="line">    <span class="string">&quot;W17&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_W17,</span><br><span class="line">    <span class="string">&quot;W18&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_W18,</span><br><span class="line">    <span class="string">&quot;W19&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_W19,</span><br><span class="line">    <span class="string">&quot;W20&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_W20,</span><br><span class="line">    <span class="string">&quot;W21&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_W21,</span><br><span class="line">    <span class="string">&quot;W22&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_W22,</span><br><span class="line">    <span class="string">&quot;W23&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_W23,</span><br><span class="line">    <span class="string">&quot;W24&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_W24,</span><br><span class="line">    <span class="string">&quot;W25&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_W25,</span><br><span class="line">    <span class="string">&quot;W26&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_W26,</span><br><span class="line">    <span class="string">&quot;W27&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_W27,</span><br><span class="line">    <span class="string">&quot;W28&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_W28,</span><br><span class="line">    <span class="string">&quot;SP&quot;</span>: unicorn.arm64_const.UC_ARM64_REG_SP,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化全局数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initGlobalData</span>():</span></span><br><span class="line">    globalData.has_pre=<span class="literal">False</span></span><br><span class="line">    globalData.pre_codestr=<span class="string">&quot;&quot;</span></span><br><span class="line">    globalData.pre_regname=<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="comment">#添加监视列表,trace时打印该内存的变动</span></span><br><span class="line">    globalData.watch_addrs= &#123;<span class="number">0x7eae07e060</span>:<span class="string">&quot;&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook_code</span>(<span class="params">uc: unicorn.Uc, address, size, user_data</span>):</span></span><br><span class="line">    inst_code=uc.mem_read(address,size)</span><br><span class="line">    <span class="keyword">for</span> inst <span class="keyword">in</span> cs.disasm(inst_code,size):</span><br><span class="line">        <span class="comment">#判断是否保存有上次的指令，有的话，则先打印上次的指令，并且查询上次的第一个寄存器的新数值</span></span><br><span class="line">        <span class="keyword">if</span> globalData.has_pre <span class="keyword">and</span> globalData.pre_regname:</span><br><span class="line">            regindex = reg_names[globalData.pre_regname.upper()]</span><br><span class="line">            regvalue = uc.reg_read(regindex)</span><br><span class="line">            globalData.pre_codestr+=<span class="string">&quot;\t//%s=0x%x&quot;</span> % (globalData.pre_regname,regvalue)</span><br><span class="line">            print(globalData.pre_codestr)</span><br><span class="line">            globalData.pre_codestr=<span class="string">&quot;&quot;</span></span><br><span class="line">            globalData.has_pre=<span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#监控我关心的内存空间，如果发生变动会再打印</span></span><br><span class="line">        <span class="keyword">if</span> len(globalData.watch_addrs)&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i,v <span class="keyword">in</span> globalData.watch_addrs.items():</span><br><span class="line">                idata= uc.mem_read(i,<span class="number">0x10</span>)</span><br><span class="line">                buf= binascii.b2a_hex(idata)</span><br><span class="line">                hexstr=buf.decode(encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> globalData.watch_addrs[i]==hexstr:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                globalData.watch_addrs[i]=hexstr</span><br><span class="line">                print(<span class="string">&quot;0x%x\t%s&quot;</span> % (i, hexstr))</span><br><span class="line"></span><br><span class="line">        <span class="comment">#拼接当前行的汇编指令</span></span><br><span class="line">        opstr=<span class="string">&quot;0x%x:\t%s\t%s&quot;</span> % (address, inst.mnemonic, inst.op_str)</span><br><span class="line">        <span class="comment">#从当前行指令中匹配出所有的寄存器</span></span><br><span class="line">        res = re.findall(<span class="string">r&#x27;[^0]([wx][0-9]+)&#x27;</span>, <span class="string">&quot; &quot;</span> + inst.op_str, re.I | re.M)</span><br><span class="line">        <span class="comment">#如果有多个寄存器，取第一个为数值被改变的寄存器</span></span><br><span class="line">        <span class="keyword">if</span> len(res)&gt;<span class="number">0</span>:</span><br><span class="line">            globalData.pre_regname = res[<span class="number">0</span>]</span><br><span class="line">        res=list(set(res))</span><br><span class="line">        <span class="comment">#如果有sp寄存器，则单独插入</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;sp&quot;</span> <span class="keyword">in</span> inst.op_str:</span><br><span class="line">            res.append(<span class="string">&quot;sp&quot;</span>)</span><br><span class="line">        <span class="comment">#如果没有寄存器，则不需要记录为上次的，直接打印即可</span></span><br><span class="line">        <span class="keyword">if</span> len(res)&lt;=<span class="number">0</span>:</span><br><span class="line">            has_pre=<span class="literal">False</span></span><br><span class="line">            print(opstr)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment">#记录数据为上次的指令</span></span><br><span class="line">        fenge = <span class="string">&quot;\t\t------&quot;</span></span><br><span class="line">        curreg=<span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> regname <span class="keyword">in</span> res:</span><br><span class="line">            regindex=reg_names[regname.upper()]</span><br><span class="line">            regvalue=uc.reg_read(regindex)</span><br><span class="line">            curreg+=<span class="string">&quot;%s=0x%x\t&quot;</span> % (regname,regvalue)</span><br><span class="line">        globalData.pre_codestr=opstr +fenge+ curreg</span><br><span class="line">        globalData.has_pre=<span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Press the green button in the gutter to run the script.</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    initGlobalData()</span><br><span class="line">    <span class="comment">#创建uc对象</span></span><br><span class="line">    uc=unicorn.Uc(unicorn.UC_ARCH_ARM64,unicorn.UC_MODE_ARM)</span><br><span class="line">    <span class="comment">#从内存中dump下来so的基址</span></span><br><span class="line">    code_addr=<span class="number">0x7eae047000</span></span><br><span class="line">    <span class="comment">#用来存放so代码的大小，尽量大一点。内存不值钱</span></span><br><span class="line">    code_size=<span class="number">8</span>*<span class="number">0x1000</span>*<span class="number">0x1000</span></span><br><span class="line">    <span class="comment">#创建一块内存</span></span><br><span class="line">    uc.mem_map(code_addr,code_size)</span><br><span class="line">    <span class="comment">#在上面那块内存后面继续划一片内存来当做栈空间</span></span><br><span class="line">    stack_addr=code_addr+code_size</span><br><span class="line">    stack_size=<span class="number">0x1000</span></span><br><span class="line">    <span class="comment">#栈顶的位置，这里是64位的，所以偏移8个字节</span></span><br><span class="line">    stack_top=stack_addr+stack_size<span class="number">-0x8</span></span><br><span class="line">    <span class="comment">#申请一块栈空间</span></span><br><span class="line">    uc.mem_map(stack_addr,stack_size)</span><br><span class="line">    <span class="comment">#栈空间往后继续划一块空间用来存放参数</span></span><br><span class="line">    args_addr=stack_addr+stack_size</span><br><span class="line">    args_size=<span class="number">0x1000</span></span><br><span class="line">    uc.mem_map(args_addr, args_size)</span><br><span class="line">    <span class="comment">#设置每句汇编执行都会调用hook_code</span></span><br><span class="line">    uc.hook_add(unicorn.UC_HOOK_CODE,hook_code)</span><br><span class="line">    <span class="comment">#读取so</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&quot;./libnative-lib.so_0x7eae047000_0x38000.so&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        sodata=f.read()</span><br><span class="line">        <span class="comment">#给前面创建的空间写入so的数据</span></span><br><span class="line">        uc.mem_write(code_addr,sodata)</span><br><span class="line">        <span class="comment">#要执行的代码开始位置</span></span><br><span class="line">        start_addr=code_addr+<span class="number">0xFCB4</span></span><br><span class="line">        <span class="comment">#要执行的代码结束位置</span></span><br><span class="line">        end_addr=code_addr+<span class="number">0xFF2C</span></span><br><span class="line">        <span class="comment">#随机生成一个入参</span></span><br><span class="line">        input_str = ranstr(<span class="number">36</span>)</span><br><span class="line">        print(<span class="string">&quot;input:%s input_addr:0x%x&quot;</span> % (input_str,args_addr))</span><br><span class="line">        input_byte=str.encode(input_str)</span><br><span class="line">        <span class="comment">#将生成的入参写入前面创建的内存空间</span></span><br><span class="line">        uc.mem_write(args_addr,input_byte)</span><br><span class="line">        <span class="comment">#ida中看到的函数有参数1、2，然后分别对应X0和X1，写入对应数据，栈寄存器给一个栈顶的地址</span></span><br><span class="line">        uc.reg_write(unicorn.arm64_const.UC_ARM64_REG_X0,args_addr)</span><br><span class="line">        uc.reg_write(unicorn.arm64_const.UC_ARM64_REG_X1,len(input_str))</span><br><span class="line">        uc.reg_write(unicorn.arm64_const.UC_ARM64_REG_SP,stack_top)</span><br><span class="line">        <span class="comment">#开始执行代码段</span></span><br><span class="line">        uc.emu_start(start_addr,end_addr)</span><br><span class="line">        <span class="comment">#ida中看到返回值是直接写在入参中，所以结果我们直接从入参的内存中读取</span></span><br><span class="line">        result=uc.mem_read(args_addr,args_size)</span><br><span class="line">        print(<span class="string">&quot;result:&quot;</span>,result.decode(encoding=<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    <span class="comment">#最后释放创建的内存</span></span><br><span class="line">    uc.mem_unmap(args_addr, args_size)</span><br><span class="line">    uc.mem_unmap(stack_addr,stack_size)</span><br><span class="line">    uc.mem_unmap(code_addr,code_size)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面贴个打印的效果片段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">input:L8Cs5ntgNWiPMQRUKYXva0juFw9JqI4ApyZT input_addr:0x7eb6048000</span><br><span class="line">0x7eae07e060    30313233343536373839616263646566</span><br><span class="line">0x7eae056cb8:    str    x25, [sp, #0x10]        ------x25&#x3D;0x0    sp&#x3D;0x7eb6047fa8        &#x2F;&#x2F;x25&#x3D;0x0</span><br><span class="line">0x7eae056cbc:    stp    x24, x23, [sp, #0x20]        ------x23&#x3D;0x0    x24&#x3D;0x0    sp&#x3D;0x7eb6047fa8        &#x2F;&#x2F;x24&#x3D;0x0</span><br><span class="line">0x7eae056cc0:    stp    x22, x21, [sp, #0x30]        ------x21&#x3D;0x0    x22&#x3D;0x0    sp&#x3D;0x7eb6047fa8        &#x2F;&#x2F;x22&#x3D;0x0</span><br><span class="line">0x7eae056cc4:    stp    x20, x19, [sp, #0x40]        ------x19&#x3D;0x0    x20&#x3D;0x0    sp&#x3D;0x7eb6047fa8        &#x2F;&#x2F;x20&#x3D;0x0</span><br><span class="line">0x7eae056cc8:    ldrb    w22, [x0, #0x18]        ------x0&#x3D;0x7eb6048000    w22&#x3D;0x0        &#x2F;&#x2F;w22&#x3D;0x46</span><br><span class="line">0x7eae056ccc:    movz    w8, #0xf6c3        ------w8&#x3D;0x0        &#x2F;&#x2F;w8&#x3D;0xf6c3</span><br><span class="line">0x7eae056cd0:    movz    w9, #0xa29a        ------w9&#x3D;0x0        &#x2F;&#x2F;w9&#x3D;0xa29a</span><br><span class="line">0x7eae056cd4:    movz    w13, #0x4941        ------w13&#x3D;0x0        &#x2F;&#x2F;w13&#x3D;0x4941</span><br><span class="line">0x7eae056cd8:    movz    w14, #0x7f29        ------w14&#x3D;0x0        &#x2F;&#x2F;w14&#x3D;0x7f29</span><br><span class="line">0x7eae056cdc:    movz    w15, #0x57d9        ------w15&#x3D;0x0        &#x2F;&#x2F;w15&#x3D;0x57d9</span><br><span class="line">0x7eae056ce0:    movz    w16, #0xcdcc        ------w16&#x3D;0x0        &#x2F;&#x2F;w16&#x3D;0xcdcc</span><br><span class="line">0x7eae056ce4:    movz    w17, #0x425b        ------w17&#x3D;0x0        &#x2F;&#x2F;w17&#x3D;0x425b</span><br><span class="line">0x7eae056ce8:    movz    w2, #0x30e6        ------w2&#x3D;0x0        &#x2F;&#x2F;w2&#x3D;0x30e6</span><br><span class="line">0x7eae056cec:    movz    w3, #0x7f2a        ------w3&#x3D;0x0        &#x2F;&#x2F;w3&#x3D;0x7f2a</span><br></pre></td></tr></table></figure><p>有了这份寄存器的变动，然后再根据我们的参数的指针在这份代码中查找。我搜索一下0x7eb6048000这个使用到的地方，然后就可以找到关于input的每个字节是怎么变换的规则了。这个例子的难度在于最后两个字节的变动。我只说一下最后两个字节的计算是怎么来的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0x7eae056ee8:    ldrb    w8, [sp, #0xc]        ------w8&#x3D;0x6cdff6c3    sp&#x3D;0x7eb6047fa8        &#x2F;&#x2F;w8&#x3D;0x90</span><br><span class="line">0x7eae056eec:    adrp    x11, #0x28000        ------x11&#x3D;0x9db        &#x2F;&#x2F;x11&#x3D;0x7eae07e000</span><br><span class="line">0x7eae056ef0:    ldr    w9, [sp, #0x1c]        ------w9&#x3D;0x6594a29a    sp&#x3D;0x7eb6047fa8        &#x2F;&#x2F;w9&#x3D;0x9db</span><br><span class="line">0x7eae056ef4:    add    x11, x11, #0x60        ------x11&#x3D;0x7eae07e000        &#x2F;&#x2F;x11&#x3D;0x7eae07e060</span><br><span class="line">0x7eae056ef8:    and    x8, x8, #0xf        ------x8&#x3D;0x90        &#x2F;&#x2F;x8&#x3D;0x0</span><br><span class="line">0x7eae056efc:    ldr    w10, [sp, #0x1c]        ------w10&#x3D;0x22    sp&#x3D;0x7eb6047fa8        &#x2F;&#x2F;w10&#x3D;0x9db</span><br><span class="line">0x7eae056f00:    ldrb    w8, [x11, x8]        ------w8&#x3D;0x0    x8&#x3D;0x0    x11&#x3D;0x7eae07e060        &#x2F;&#x2F;w8&#x3D;0x30</span><br><span class="line">0x7eae056f04:    and    w9, w9, #0xfffffff0        ------w9&#x3D;0x9db        &#x2F;&#x2F;w9&#x3D;0x9d0</span><br><span class="line">0x7eae056f08:    ldr    x25, [sp, #0x10]        ------x25&#x3D;0x0    sp&#x3D;0x7eb6047fa8        &#x2F;&#x2F;x25&#x3D;0x0</span><br><span class="line">0x7eae056f0c:    sub    w9, w10, w9        ------w9&#x3D;0x9d0    w10&#x3D;0x9db        &#x2F;&#x2F;w9&#x3D;0xb</span><br><span class="line">0x7eae056f10:    strb    w8, [x0, #0x23]        ------w8&#x3D;0x30    x0&#x3D;0x7eb6048000        &#x2F;&#x2F;w8&#x3D;0x30</span><br><span class="line">0x7eae056f14:    ldrb    w8, [x11, w9, uxtw]        ------w8&#x3D;0x30    w9&#x3D;0xb    x11&#x3D;0x7eae07e060        &#x2F;&#x2F;w8&#x3D;0x62</span><br><span class="line">0x7eae056f18:    strb    w8, [x0, #0x22]        ------w8&#x3D;0x62    x0&#x3D;0x7eb6048000        &#x2F;&#x2F;w8&#x3D;0x62</span><br><span class="line">0x7eae056f1c:    ldp    x20, x19, [sp, #0x40]        ------x20&#x3D;0x9db    x19&#x3D;0xa0504942    sp&#x3D;0x7eb6047fa8        &#x2F;&#x2F;x20&#x3D;0x0</span><br><span class="line">0x7eae056f20:    ldp    x22, x21, [sp, #0x30]        ------x21&#x3D;0x90    x22&#x3D;0xa0504942    sp&#x3D;0x7eb6047fa8        &#x2F;&#x2F;x22&#x3D;0x0</span><br><span class="line">0x7eae056f24:    ldp    x24, x23, [sp, #0x20]        ------x23&#x3D;0x98c    x24&#x3D;0x4e    sp&#x3D;0x7eb6047fa8        &#x2F;&#x2F;x24&#x3D;0x0</span><br></pre></td></tr></table></figure><p>这是最后的一段代码可以看到w8=0x62写入到了0x22的位置，w8=0x30写入到了0x23的位置。那么这两个数值是什么来历呢</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldrb    w8, [x11, w9, uxtw]        ------w8&#x3D;0x30    w9&#x3D;0xb    x11&#x3D;0x7eae07e060        &#x2F;&#x2F;w8&#x3D;0x62</span><br></pre></td></tr></table></figure><p>这里看到是从另外一块内存0x7eae07e060的0xb的位置读取到了0x62。由于我前面已经使用了内存监控。所以这块地址的数据我们可以看到是下面的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x7eae07e060    30313233343536373839616263646566</span><br></pre></td></tr></table></figure><p>这段字节转成字符串之后的结果就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x7eae07e060    0123456789abcdef</span><br></pre></td></tr></table></figure><p>而0xb的位置实际就是62。那么这里的意思就将0xb转成ascii，所以直接找0xb怎么来的就行了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x7eae056f0c:    sub    w9, w10, w9        ------w9&#x3D;0x9d0    w10&#x3D;0x9db        &#x2F;&#x2F;w9&#x3D;0xb</span><br></pre></td></tr></table></figure><p>然后继续找0x9d0和0x9db怎么来的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x7eae056f04:    and    w9, w9, #0xfffffff0        ------w9&#x3D;0x9db        &#x2F;&#x2F;w9&#x3D;0x9d0</span><br></pre></td></tr></table></figure><p>最后只差0x9db是哪里来的，搜索一下0x9db</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x7eae056e34:    add    w20, w23, w20        ------w20&#x3D;0x4f    w23&#x3D;0x98c        &#x2F;&#x2F;w20&#x3D;0x9db</span><br></pre></td></tr></table></figure><p>然后这里我查过0x4f和0x98c了。然后发现上面有长的相同的流程。所以这种遍历的情况。我们直接搜索前面的地址0x7eae056e34就行了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&quot;0x7eae056e34:    add    w20, w23, w20        ------w20&#x3D;0x69    w23&#x3D;0x0        &#x2F;&#x2F;w20&#x3D;0x69&quot;</span><br><span class="line">&quot;0x7eae056e34:    add    w20, w23, w20        ------w20&#x3D;0x6b    w23&#x3D;0x69        &#x2F;&#x2F;w20&#x3D;0xd4&quot;</span><br><span class="line">&quot;0x7eae056e34:    add    w20, w23, w20        ------w20&#x3D;0x6a    w23&#x3D;0xd4        &#x2F;&#x2F;w20&#x3D;0x13e&quot;</span><br><span class="line">&quot;0x7eae056e34:    add    w20, w23, w20        ------w20&#x3D;0x75    w23&#x3D;0x13e        &#x2F;&#x2F;w20&#x3D;0x1b3&quot;</span><br><span class="line">&quot;0x7eae056e34:    add    w20, w23, w20        ------w20&#x3D;0x50    w23&#x3D;0x1b3        &#x2F;&#x2F;w20&#x3D;0x203&quot;</span><br><span class="line">&quot;0x7eae056e34:    add    w20, w23, w20        ------w20&#x3D;0x73    w23&#x3D;0x203        &#x2F;&#x2F;w20&#x3D;0x276&quot;</span><br><span class="line">&quot;0x7eae056e34:    add    w20, w23, w20        ------w20&#x3D;0x37    w23&#x3D;0x276        &#x2F;&#x2F;w20&#x3D;0x2ad&quot;</span><br><span class="line">&quot;0x7eae056e34:    add    w20, w23, w20        ------w20&#x3D;0x62    w23&#x3D;0x2ad        &#x2F;&#x2F;w20&#x3D;0x30f&quot;</span><br><span class="line">&quot;0x7eae056e34:    add    w20, w23, w20        ------w20&#x3D;0x38    w23&#x3D;0x30f        &#x2F;&#x2F;w20&#x3D;0x347&quot;</span><br><span class="line">&quot;0x7eae056e34:    add    w20, w23, w20        ------w20&#x3D;0x46    w23&#x3D;0x347        &#x2F;&#x2F;w20&#x3D;0x38d&quot;</span><br><span class="line">&quot;0x7eae056e34:    add    w20, w23, w20        ------w20&#x3D;0x61    w23&#x3D;0x38d        &#x2F;&#x2F;w20&#x3D;0x3ee&quot;</span><br><span class="line">&quot;0x7eae056e34:    add    w20, w23, w20        ------w20&#x3D;0x68    w23&#x3D;0x3ee        &#x2F;&#x2F;w20&#x3D;0x456&quot;</span><br><span class="line">&quot;0x7eae056e34:    add    w20, w23, w20        ------w20&#x3D;0x4a    w23&#x3D;0x456        &#x2F;&#x2F;w20&#x3D;0x4a0&quot;</span><br><span class="line">&quot;0x7eae056e34:    add    w20, w23, w20        ------w20&#x3D;0x70    w23&#x3D;0x4a0        &#x2F;&#x2F;w20&#x3D;0x510&quot;</span><br><span class="line">&quot;0x7eae056e34:    add    w20, w23, w20        ------w20&#x3D;0x35    w23&#x3D;0x510        &#x2F;&#x2F;w20&#x3D;0x545&quot;</span><br><span class="line">&quot;0x7eae056e34:    add    w20, w23, w20        ------w20&#x3D;0x6e    w23&#x3D;0x545        &#x2F;&#x2F;w20&#x3D;0x5b3&quot;</span><br><span class="line">&quot;0x7eae056e34:    add    w20, w23, w20        ------w20&#x3D;0x48    w23&#x3D;0x5b3        &#x2F;&#x2F;w20&#x3D;0x5fb&quot;</span><br><span class="line">&quot;0x7eae056e34:    add    w20, w23, w20        ------w20&#x3D;0x72    w23&#x3D;0x5fb        &#x2F;&#x2F;w20&#x3D;0x66d&quot;</span><br><span class="line">&quot;0x7eae056e34:    add    w20, w23, w20        ------w20&#x3D;0x67    w23&#x3D;0x66d        &#x2F;&#x2F;w20&#x3D;0x6d4&quot;</span><br><span class="line">&quot;0x7eae056e34:    add    w20, w23, w20        ------w20&#x3D;0x52    w23&#x3D;0x6d4        &#x2F;&#x2F;w20&#x3D;0x726&quot;</span><br><span class="line">&quot;0x7eae056e34:    add    w20, w23, w20        ------w20&#x3D;0x4e    w23&#x3D;0x726        &#x2F;&#x2F;w20&#x3D;0x774&quot;</span><br><span class="line">&quot;0x7eae056e34:    add    w20, w23, w20        ------w20&#x3D;0x4c    w23&#x3D;0x774        &#x2F;&#x2F;w20&#x3D;0x7c0&quot;</span><br><span class="line">&quot;0x7eae056e34:    add    w20, w23, w20        ------w20&#x3D;0x30    w23&#x3D;0x7c0        &#x2F;&#x2F;w20&#x3D;0x7f0&quot;</span><br><span class="line">&quot;0x7eae056e34:    add    w20, w23, w20        ------w20&#x3D;0x66    w23&#x3D;0x7f0        &#x2F;&#x2F;w20&#x3D;0x856&quot;</span><br><span class="line">&quot;0x7eae056e34:    add    w20, w23, w20        ------w20&#x3D;0x57    w23&#x3D;0x856        &#x2F;&#x2F;w20&#x3D;0x8ad&quot;</span><br><span class="line">&quot;0x7eae056e34:    add    w20, w23, w20        ------w20&#x3D;0x55    w23&#x3D;0x8ad        &#x2F;&#x2F;w20&#x3D;0x902&quot;</span><br><span class="line">&quot;0x7eae056e34:    add    w20, w23, w20        ------w20&#x3D;0x47    w23&#x3D;0x902        &#x2F;&#x2F;w20&#x3D;0x949&quot;</span><br><span class="line">&quot;0x7eae056e34:    add    w20, w23, w20        ------w20&#x3D;0x43    w23&#x3D;0x949        &#x2F;&#x2F;w20&#x3D;0x98c&quot;</span><br><span class="line">&quot;0x7eae056e34:    add    w20, w23, w20        ------w20&#x3D;0x4f    w23&#x3D;0x98c        &#x2F;&#x2F;w20&#x3D;0x9db&quot;</span><br></pre></td></tr></table></figure><p>到这里就知道了。这个0x9db是input的累加。不过并不是完整的累加。所以这里稍微留意下。就能得出结果了。</p><p>最后0x23位置的字节处理和0x22位置的基本雷同。我就不重复讲了。直接贴上解密后的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getAscii</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> tmp[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(tmp,<span class="number">3</span>,<span class="string">&quot;%x&quot;</span>,num);</span><br><span class="line">    <span class="keyword">return</span> tmp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> input[]=<span class="string">&quot;L8Cs5ntgNWiPMQRUKYXva0juFw9JqI4ApyZT&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> output[<span class="built_in">strlen</span>(input)];</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> eorsum=<span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(input);i++)&#123;</span><br><span class="line">        output[i]=input[i]^<span class="number">0x1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0x8</span>||i==<span class="number">0xd</span>||i==<span class="number">0x12</span>||i==<span class="number">0x18</span>)&#123;</span><br><span class="line">            output[i]=<span class="number">0x2d</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0xe</span>)&#123;</span><br><span class="line">            output[i]=<span class="number">0x34</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0x23</span>)&#123;</span><br><span class="line">            output[i]=input[<span class="number">0x22</span>];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0x22</span>)&#123;</span><br><span class="line">            output[i]=input[<span class="number">0x9</span>];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0x17</span>)&#123;</span><br><span class="line">            output[i]=input[<span class="number">0x18</span>]^<span class="number">0x1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0x22</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> addvalue=input[i];</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0x17</span>)&#123;</span><br><span class="line">                addvalue=input[<span class="number">0x18</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            sum+=addvalue;</span><br><span class="line">            eorsum^=addvalue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> data22=sum-(sum&amp;<span class="number">0xfffffff0</span>);</span><br><span class="line">    <span class="keyword">char</span> tmp22=getAscii(data22);</span><br><span class="line">    <span class="keyword">int</span> data23=eorsum&amp;<span class="number">0xf</span>;</span><br><span class="line">    <span class="keyword">char</span> tmp23=getAscii(data23);</span><br><span class="line">    output[<span class="number">0x22</span>]=tmp22;</span><br><span class="line">    output[<span class="number">0x23</span>]=tmp23;</span><br><span class="line">    output[<span class="built_in">strlen</span>(input)]=<span class="number">0x0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input:%s output:%s\n&quot;</span>,input,output);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input:L8Cs5ntgNWiPMQRUKYXva0juFw9JqI4ApyZT output:M9Br4ouf-VhQL-4TJX-w&#96;1kG-v8KpH5@qx7c</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> unicorn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ollvm自定义string加密pass</title>
      <link href="/2020/10/12/ollvm/"/>
      <url>/2020/10/12/ollvm/</url>
      
        <content type="html"><![CDATA[<p>先贴上测试好的结果: <a href="https://github.com/dqzg12300/kOLLVM.git">https://github.com/dqzg12300/kOLLVM.git</a></p><p>想要写一个字符串加密的pass，第一步就是先实现一遍c++的算法流程，然后再看一看生成的IR文件，然后再写对应的加密pass，下面看一个自己实现的简单c++字符串加密。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>  argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//加密</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str1=<span class="string">&quot;hello world!!!&quot;</span>;</span><br><span class="line">    <span class="comment">//这里是随机的key，先写固定,真实实现的时候再每个字节使用一个随机key</span></span><br><span class="line">    <span class="keyword">int</span> randkey=<span class="number">11</span>;</span><br><span class="line">      <span class="comment">//加密复杂度</span></span><br><span class="line">    <span class="keyword">int</span> kstr_size=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> enclen=randkey+kstr_size;</span><br><span class="line">    <span class="keyword">char</span> encres[str1.<span class="built_in">size</span>()];</span><br><span class="line">    <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(encres,<span class="number">0</span>,enclen);</span><br><span class="line">    <span class="comment">//这里大概就是遍历字符串，每个字符根据加密复杂度进行一定数量迭代异或，最后一次的迭代使用取反再异或</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;cur: %x \r\n&quot;</span>,str1[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y=randkey;y&lt;enclen;y++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(y==randkey)&#123;</span><br><span class="line">                encres[i]=str1[i]^y;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(y==enclen<span class="number">-1</span>)&#123;</span><br><span class="line">                encres[i]=encres[i]^(~y);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                encres[i]=encres[i]^y;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%x &quot;</span>,encres[i]);</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;encdata: %s\r\n&quot;</span>,encres);</span><br><span class="line">    <span class="comment">//下面是解密函数</span></span><br><span class="line">    <span class="keyword">char</span> decres[str1.<span class="built_in">size</span>()];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;cur enc: %x \r\n&quot;</span>,encres[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y=enclen<span class="number">-1</span>;y&gt;=randkey;y--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(y==enclen<span class="number">-1</span>)&#123;</span><br><span class="line">                decres[i]=encres[i]^(~y);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                decres[i]=decres[i]^y;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%x &quot;</span>,decres[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res: %s\r\n&quot;</span>,decres);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个简单加密的意思，就是根据复杂度参数。来进行一定次数的迭代，将当前字符每次都异或一下，最后一次是先去反，再异或，解密就是反之。测试结果能正常加密和解密后，我们就先输出一份ir文件。看看在ir中间语言中是如何进行加密和解密的。</p><a id="more"></a><p><code>clang -emit-llvm -S main.cpp -o main.ll</code></p><p>生成好对应的ir文件后，我们开始写这个加密pass，然后再写的过程中，根据逻辑需要，去ir中找对应的指令处理方式</p><p>在ir文件中的层级划分:Module(模块)的下一层是若干Function(函数),然后在Function的下一层是若干BasicBlock(基本快),再BasicBlock的下一层是若干Instruction(指令块)</p><p>现在准备就绪，下面开始先准备一个加密的pass,基本代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;kllvm/Transforms/Obfuscation/Utils.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kllvm/Transforms/Obfuscation/KStringEncode.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">      <span class="comment">//加密复杂度</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> defaultKStringSize = <span class="number">0x10</span>;</span><br><span class="line">    <span class="keyword">static</span> cl::opt&lt;<span class="keyword">int</span>&gt;</span><br><span class="line">            KStringSize(<span class="string">&quot;kstr_size&quot;</span>, cl::desc(<span class="string">&quot;Choose the probability [%] each basic blocks will be obfuscated by the -kstr pass&quot;</span>), cl::value_desc(<span class="string">&quot;king string encode Encryption length&quot;</span>), cl::init(defaultKStringSize), cl::Optional);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">KStringEncode</span>:</span> <span class="keyword">public</span> FunctionPass&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">char</span> ID; <span class="comment">// Pass identification</span></span><br><span class="line">        <span class="keyword">bool</span> flag;</span><br><span class="line">        KStringEncode() : FunctionPass(ID) &#123;&#125;</span><br><span class="line">        KStringEncode(<span class="keyword">bool</span> flag) : FunctionPass(ID) &#123;<span class="keyword">this</span>-&gt;flag = flag; KStringEncode();&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span></span>&#123;</span><br><span class="line">              <span class="comment">//先检查加密复杂度是否在合法范围</span></span><br><span class="line">            <span class="keyword">if</span> ( !((KStringSize &gt; <span class="number">0</span>) &amp;&amp; (KStringSize &lt;= <span class="number">100</span>)) ) &#123;</span><br><span class="line">                errs()&lt;&lt;<span class="string">&quot;KStringEncode application basic blocks percentage -kstr_size=x must be 0 &lt; x &lt;= 100&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(toObfuscate(flag,&amp;F,<span class="string">&quot;kstr&quot;</span>)) &#123;</span><br><span class="line">                kstr(F);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">kstr</span><span class="params">(Function&amp; func)</span></span>&#123;</span><br><span class="line">            <span class="comment">//todo 这里再写具体的pass逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> KStringEncode::ID = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> RegisterPass&lt;KStringEncode&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;kstr&quot;</span>, <span class="string">&quot;inserting bogus control flow&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Pass *<span class="title">llvm::createKStringEncode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> KStringEncode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Pass *<span class="title">llvm::createKStringEncode</span><span class="params">(<span class="keyword">bool</span> flag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> KStringEncode(flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里准备好了pass的基本代码后，最后就剩下最重要的核心逻辑，如何把c++的加密方式。在pass中实现，我们的功能是实现字符串加密，那么第一步应该是取得这个函数中的全部字符串，那么我们先看看ir中字符串的特征</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@.str &#x3D; private unnamed_addr constant [15 x i8] c&quot;hello world!!!\00&quot;, align 1</span><br></pre></td></tr></table></figure><p>可以看到，这个str是一个操作数，想要获取全部字符串，就得先遍历所有指令块中的操作数。然后再根据字符串的特征来进行过滤。下面先看如何遍历所有指令块。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kstr</span><span class="params">(Function&amp; func)</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(BasicBlock&amp; bb:func)&#123;</span><br><span class="line">                <span class="keyword">for</span>(Instruction&amp; ins :bb)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(Value* val:ins.operands())&#123;</span><br><span class="line">                        Value* stripOp=val-&gt;stripPointerCasts();</span><br><span class="line">                        <span class="keyword">if</span>(stripOp-&gt;getName().contains(<span class="string">&quot;.str&quot;</span>))&#123;</span><br><span class="line">                            errs()&lt;&lt;ins&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                            errs()&lt;&lt;*val&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                            errs()&lt;&lt;*stripOp&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>上面遍历了函数中的所有基本快，然后遍历所有指令块，然后遍历所有操作数，然后获取操作数的值，判断该操作数是否是一个字符串，并且打印这个指令块，操作数，以及取到的操作数的值，下面看看打印的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  store i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i64 0, i64 0), i8** %str, align 8</span><br><span class="line">i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i64 0, i64 0)</span><br><span class="line">@.str &#x3D; private unnamed_addr constant [7 x i8] c&quot;kanxue\00&quot;, align 1</span><br></pre></td></tr></table></figure><p>那么看到了，我们想获取的字符串是在stripOp中。那么接下来就把所有字符串全部获取出来并转换成string</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装一个转换操作数值为字符串的函数</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">ConvertOpToString</span><span class="params">(Value* op)</span></span>&#123;</span><br><span class="line">            GlobalVariable* globalVar= dyn_cast&lt;GlobalVariable&gt;(op);</span><br><span class="line">            <span class="keyword">if</span>(!globalVar)&#123;</span><br><span class="line">                errs()&lt;&lt;<span class="string">&quot;dyn cast gloabl err&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ConstantDataSequential* cds=dyn_cast&lt;ConstantDataSequential&gt;(globalVar-&gt;getInitializer());</span><br><span class="line">            <span class="keyword">if</span>(!cds)&#123;</span><br><span class="line">                errs()&lt;&lt;<span class="string">&quot;dyn cast constant data err&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cds-&gt;getRawDataValues();;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">kstr</span><span class="params">(Function&amp; func)</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(BasicBlock&amp; bb:func)&#123;</span><br><span class="line">                <span class="keyword">for</span>(Instruction&amp; ins :bb)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(Value* val:ins.operands())&#123;</span><br><span class="line">                        Value* stripOp=val-&gt;stripPointerCasts();</span><br><span class="line">                        <span class="keyword">if</span>(stripOp-&gt;getName().contains(<span class="string">&quot;.str&quot;</span>))&#123;</span><br><span class="line">                            <span class="built_in">std</span>::<span class="built_in">string</span> strdata=ConvertOpToString(stripOp);</span><br><span class="line">                            errs()&lt;&lt;strdata&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>之前看到的字符串的ir代码看到所有字符串都是全局的，所以要先转换成全局的对象，然后再转换成数值。然后看这里的打印结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kanxue</span><br><span class="line">hello ollvm:%d</span><br></pre></td></tr></table></figure><p>获取到所有的字符串了之后。接下来。我们要先把这个字符串加密，然后再用插入指令块来进行解密。下面继续完善，先把之前搞好的加密算法迁移进来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转换字符串</span></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">ConvertOpToString</span><span class="params">(Value* op)</span></span>&#123;</span><br><span class="line">            GlobalVariable* globalVar= dyn_cast&lt;GlobalVariable&gt;(op);</span><br><span class="line">            <span class="keyword">if</span>(!globalVar)&#123;</span><br><span class="line">                errs()&lt;&lt;<span class="string">&quot;dyn cast gloabl err&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ConstantDataSequential* cds=dyn_cast&lt;ConstantDataSequential&gt;(globalVar-&gt;getInitializer());</span><br><span class="line">            <span class="keyword">if</span>(!cds)&#123;</span><br><span class="line">                errs()&lt;&lt;<span class="string">&quot;dyn cast constant data err&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cds-&gt;getRawDataValues();;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">kstr</span><span class="params">(Function&amp; func)</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(BasicBlock&amp; bb:func)&#123;</span><br><span class="line">                <span class="keyword">for</span>(Instruction&amp; ins :bb)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(Value* val:ins.operands())&#123;</span><br><span class="line">                        Value* stripOp=val-&gt;stripPointerCasts();</span><br><span class="line">                        <span class="keyword">if</span>(stripOp-&gt;getName().contains(<span class="string">&quot;.str&quot;</span>))&#123;</span><br><span class="line">                            <span class="built_in">std</span>::<span class="built_in">string</span> strdata=ConvertOpToString(stripOp);</span><br><span class="line">                            errs()&lt;&lt;strdata&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//加密流程</span></span><br><span class="line">                            <span class="keyword">uint8_t</span> keys[strdata.<span class="built_in">size</span>()];</span><br><span class="line">                            <span class="keyword">char</span> encres[strdata.<span class="built_in">size</span>()];</span><br><span class="line">                            <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">                            <span class="built_in">memset</span>(encres,<span class="number">0</span>,strdata.<span class="built_in">size</span>());</span><br><span class="line">                            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strdata.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                                <span class="keyword">uint8_t</span> randkey=llvm::cryptoutils-&gt;<span class="keyword">get_uint8_t</span>();</span><br><span class="line">                                keys[i]=randkey;</span><br><span class="line">                                <span class="keyword">int</span> enclen=randkey+defaultKStringSize;</span><br><span class="line">                                <span class="keyword">for</span>(<span class="keyword">int</span> y=randkey;y&lt;enclen;y++)&#123;</span><br><span class="line">                                    <span class="keyword">if</span>(y==randkey)&#123;</span><br><span class="line">                                        encres[i]=strdata[i]^y;</span><br><span class="line">                                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(y==enclen<span class="number">-1</span>)&#123;</span><br><span class="line">                                        encres[i]=encres[i]^(~y);</span><br><span class="line">                                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                        encres[i]=encres[i]^y;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    idx++;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这里大致流程和之前一样。只是key我们装起来了。然后每个字节处理都随机一次key。接下来的处理就是插入指令块来对这个加密数据encres进行解密还原处理。</p><p>我们想要处理这个加密的数据，首先要先创建一个内存指令，来存放这个加密后的数据。然后再对加密后的数据遍历。进行还原。所以，我们的下一步先创建一个BitCastInst。并且我们需要用一个int8的array来给这个内存指令进行赋值。下面的代码是先创建array指令，然后用array指令创建一个内存指令</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayType* arrType=ArrayType::<span class="built_in">get</span>(Type::getInt8Ty(func.getContext()),strdata.<span class="built_in">size</span>());</span><br><span class="line">                            AllocaInst* arrayInst=<span class="keyword">new</span> AllocaInst(arrType,<span class="number">0</span>,<span class="literal">nullptr</span>,<span class="number">1</span>,Twine(stripOp-&gt;getName()+<span class="string">&quot;.arr&quot;</span>),&amp;ins);</span><br><span class="line">                            BitCastInst* bitInst=<span class="keyword">new</span> BitCastInst(arrayInst,Type::getInt8PtrTy(func.getParent()-&gt;getContext()),Twine(stripOp-&gt;getName()+<span class="string">&quot;bitcast&quot;</span>),&amp;ins);</span><br></pre></td></tr></table></figure><p>上面的就是先创建一个int8的array类型，然后用这个类型创建一个array，然后再用这个array创建内存指令，这些指令都插入在遍历到字符串指令的当前行的前方。这个bitcast将用来存放加密后的字符串数据</p><p>接下来就是解密的逻辑处理。和我们之前c++的流程一样，只不过这里需要换成插入指令块的形式来进行加密数据的还原，我直接贴上解密的代码部分，然后里面有详细的注释。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">ArrayType* arrType=ArrayType::<span class="built_in">get</span>(Type::getInt8Ty(func.getContext()),strdata.<span class="built_in">size</span>());</span><br><span class="line">AllocaInst* arrayInst=<span class="keyword">new</span> AllocaInst(arrType,<span class="number">0</span>,<span class="literal">nullptr</span>,<span class="number">1</span>,Twine(stripOp-&gt;getName()+<span class="string">&quot;.arr&quot;</span>),&amp;ins);</span><br><span class="line">BitCastInst* bitInst=<span class="keyword">new</span> BitCastInst(arrayInst,Type::getInt8PtrTy(func.getParent()-&gt;getContext()),Twine(stripOp-&gt;getName()+<span class="string">&quot;.bitcast&quot;</span>),&amp;ins);</span><br><span class="line"><span class="comment">//创建一个对象用来存放当前加密字节解密时每次异或的结果</span></span><br><span class="line">AllocaInst* eor_res=<span class="keyword">new</span> AllocaInst(Type::getInt8Ty(func.getContext()),<span class="number">0</span>,<span class="literal">nullptr</span>,<span class="number">1</span>,Twine(stripOp-&gt;getName()+<span class="string">&quot;.alloc.res&quot;</span>),&amp;ins);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strdata.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> randkey=keys[i];</span><br><span class="line">    <span class="keyword">int</span> enclen=randkey+defaultKStringSize;</span><br><span class="line">    ConstantInt* enc_const=ConstantInt::<span class="built_in">get</span>(Type::getInt8Ty(func.getContext()),encres[i]);</span><br><span class="line">    <span class="comment">//用来存放解密结果的bitcat</span></span><br><span class="line">    ConstantInt* i_const=ConstantInt::<span class="built_in">get</span>(Type::getInt8Ty(func.getContext()),i);</span><br><span class="line">    GetElementPtrInst* element=GetElementPtrInst::CreateInBounds(bitInst,i_const);</span><br><span class="line">    element-&gt;insertBefore(&amp;ins);</span><br><span class="line">    StoreInst* last_store=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y=enclen<span class="number">-1</span>;y&gt;=randkey;y--)&#123;</span><br><span class="line">        <span class="comment">/*下面是获取y的指令块*/</span></span><br><span class="line">        <span class="comment">//先是创建一个数值y</span></span><br><span class="line">        ConstantInt *eor_data = ConstantInt::<span class="built_in">get</span>(Type::getInt8Ty(func.getContext()),y);</span><br><span class="line">        <span class="comment">//申请一个int8的内存来存放数值y</span></span><br><span class="line">        AllocaInst* eor_alloc=<span class="keyword">new</span> AllocaInst(Type::getInt8Ty(func.getContext()),<span class="number">0</span>,<span class="literal">nullptr</span>,<span class="number">1</span>,Twine(stripOp-&gt;getName()+<span class="string">&quot;.alloc.y&quot;</span>),&amp;ins);</span><br><span class="line">        <span class="comment">//将数值y赋值给申请的内存空间</span></span><br><span class="line">        StoreInst* store_eor=<span class="keyword">new</span> StoreInst(eor_data,eor_alloc);</span><br><span class="line">        store_eor-&gt;insertAfter(eor_alloc);</span><br><span class="line">        <span class="comment">//从内存空间中加载里面的数值y</span></span><br><span class="line">        LoadInst* eor_load=<span class="keyword">new</span> LoadInst(eor_alloc,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        eor_load-&gt;insertAfter(store_eor);</span><br><span class="line">        <span class="comment">//如果是第一次异或</span></span><br><span class="line">        <span class="keyword">if</span>(y==enclen<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">//然后进行取反计算</span></span><br><span class="line">            BinaryOperator* binNotOp=BinaryOperator::CreateNot(eor_load);</span><br><span class="line">            binNotOp-&gt;insertAfter(eor_load);</span><br><span class="line">              <span class="comment">//然后异或</span></span><br><span class="line">            BinaryOperator* binXorOp=BinaryOperator::CreateXor(enc_const,binNotOp);</span><br><span class="line">            binXorOp-&gt;insertAfter(binNotOp);</span><br><span class="line">            <span class="comment">//将加密字节设置为上次异或的结果</span></span><br><span class="line">            StoreInst* store_eor_res=<span class="keyword">new</span> StoreInst(binXorOp,eor_res);</span><br><span class="line">            store_eor_res-&gt;insertAfter(store_data);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//加载获取上次异或的结果</span></span><br><span class="line">            LoadInst* eor_load_res=<span class="keyword">new</span> LoadInst(eor_res,stripOp-&gt;getName()+<span class="string">&quot;.load&quot;</span>);</span><br><span class="line">            eor_load_res-&gt;insertAfter(store_eor);</span><br><span class="line">            <span class="comment">//然后再进行异或计算</span></span><br><span class="line">            BinaryOperator* binXorOp=BinaryOperator::CreateXor(eor_load_res,eor_load);</span><br><span class="line">            binXorOp-&gt;insertAfter(eor_load);</span><br><span class="line">            <span class="comment">//将计算后的结果存放回数组中</span></span><br><span class="line">            StoreInst* store_data=<span class="keyword">new</span> StoreInst(binXorOp,eor_res);</span><br><span class="line">            store_data-&gt;insertAfter(binXorOp);</span><br><span class="line">            <span class="comment">//当循环到最后一次时，获取一下最后一次赋值的指令块地址。方便后面接着往后插指令块</span></span><br><span class="line">            <span class="keyword">if</span>(y==randkey)&#123;</span><br><span class="line">                last_store=store_data;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">//读取这个字节经过多次异或后的最终结果</span></span><br><span class="line">    LoadInst* dec_res=<span class="keyword">new</span> LoadInst(eor_res,stripOp-&gt;getName()+<span class="string">&quot;.dec.res&quot;</span>);</span><br><span class="line">    dec_res-&gt;insertAfter(last_store);</span><br><span class="line">    <span class="comment">//将这个结果写入到前面用来存放的解密结果bitcat处</span></span><br><span class="line">    StoreInst* store_data=<span class="keyword">new</span> StoreInst(dec_res,element);</span><br><span class="line">    store_data-&gt;insertAfter(dec_res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面就是把c++的解密流程用插入指令块的方式实现的方式。流程比较繁琐，但是大概意思是差不多的。</p><p>最后这里完成后，我们就可以删除指令块中的字符串明文部分。然后只保留密文</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将字符串操作数替换为我们准备好的解密结果的bitInst</span></span><br><span class="line">val-&gt;replaceAllUsesWith(bitInst);</span><br><span class="line"><span class="comment">//然后再删掉之前我们获取到的字符串的明文部分。这样就只有密文数据和密文解密的流程，最后动态执行拿到解密字符串了</span></span><br><span class="line">GlobalVariable* globalVar= dyn_cast&lt;GlobalVariable&gt;(stripOp);</span><br><span class="line">globalVar-&gt;eraseFromParent();</span><br></pre></td></tr></table></figure><p>到这里整个流程就完成了。这里还有一个点需要注意的是，由于字符串的特性，当使用了多个相同的字符串，实际在汇编层的代码中，会优化为一个字符串，所以在字符串加密的时候，我们要留意解密字符串的作用域。下面举一个例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>  argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = argc;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中使用了两个hello。如果我们在使用这个字符串时，调用的解密。那么下面else中的代码则会无法访问到bitcat。因为不在同一个作用域，所以为了防止出现这种情况，我在解密时再做一个特殊的处理，我们先获取第一个指令块的位置，然后所有的字符串解密指令块，都插入在最开始的位置，这样就不会出现作用域的问题了。最后贴上完整代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by king on 2020/10/7.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;kllvm/Transforms/Obfuscation/Utils.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kllvm/Transforms/Obfuscation/KStringEncode.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> defaultKStringSize = <span class="number">0x3</span>;</span><br><span class="line">    <span class="keyword">static</span> cl::opt&lt;<span class="keyword">int</span>&gt;</span><br><span class="line">            KStringSize(<span class="string">&quot;kstr_size&quot;</span>, cl::desc(<span class="string">&quot;Choose the probability [%] each basic blocks will be obfuscated by the -kstr pass&quot;</span>), cl::value_desc(<span class="string">&quot;king string encode Encryption length&quot;</span>), cl::init(defaultKStringSize), cl::Optional);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">KStringEncode</span>:</span> <span class="keyword">public</span> FunctionPass&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">char</span> ID; <span class="comment">// Pass identification</span></span><br><span class="line">        <span class="keyword">bool</span> flag;</span><br><span class="line">        KStringEncode() : FunctionPass(ID) &#123;&#125;</span><br><span class="line">        KStringEncode(<span class="keyword">bool</span> flag) : FunctionPass(ID) &#123;<span class="keyword">this</span>-&gt;flag = flag; KStringEncode();&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ( !((KStringSize &gt; <span class="number">0</span>) &amp;&amp; (KStringSize &lt;= <span class="number">0x20</span>)) ) &#123;</span><br><span class="line">                errs()&lt;&lt;<span class="string">&quot;KStringEncode application basic blocks percentage -kstr_size=x must be 0 &lt; x &lt;= 100&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(toObfuscate(flag,&amp;F,<span class="string">&quot;kstr&quot;</span>)) &#123;</span><br><span class="line">                kstr(F);</span><br><span class="line"><span class="comment">//                printFunction(F);</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//转换字符串</span></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">ConvertOpToString</span><span class="params">(Value* op)</span></span>&#123;</span><br><span class="line">            GlobalVariable* globalVar= dyn_cast&lt;GlobalVariable&gt;(op);</span><br><span class="line">            <span class="keyword">if</span>(!globalVar)&#123;</span><br><span class="line">                errs()&lt;&lt;<span class="string">&quot;dyn cast gloabl err&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ConstantDataSequential* cds=dyn_cast&lt;ConstantDataSequential&gt;(globalVar-&gt;getInitializer());</span><br><span class="line">            <span class="keyword">if</span>(!cds)&#123;</span><br><span class="line">                errs()&lt;&lt;<span class="string">&quot;dyn cast constant data err&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cds-&gt;getRawDataValues();;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">kstr</span><span class="params">(Function&amp; func)</span></span>&#123;</span><br><span class="line">            Instruction* begin_ins=<span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">for</span>(BasicBlock&amp; bb:func)&#123;</span><br><span class="line">                <span class="keyword">for</span>(Instruction&amp; ins :bb)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(begin_ins==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                        begin_ins=&amp;ins;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(Value* val:ins.operands())&#123;</span><br><span class="line">                        Value* stripOp=val-&gt;stripPointerCasts();</span><br><span class="line">                        <span class="keyword">if</span>(stripOp-&gt;getName().contains(<span class="string">&quot;.str&quot;</span>))&#123;</span><br><span class="line">                            <span class="built_in">std</span>::<span class="built_in">string</span> strdata=ConvertOpToString(stripOp);</span><br><span class="line">                            errs()&lt;&lt;strdata&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                            <span class="keyword">if</span>(strdata.<span class="built_in">size</span>()&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//加密流程</span></span><br><span class="line">                            <span class="keyword">uint8_t</span> keys[strdata.<span class="built_in">size</span>()];</span><br><span class="line">                            <span class="keyword">char</span> encres[strdata.<span class="built_in">size</span>()];</span><br><span class="line">                            <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">                            <span class="built_in">memset</span>(encres,<span class="number">0</span>,strdata.<span class="built_in">size</span>());</span><br><span class="line">                            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strdata.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                                <span class="keyword">uint8_t</span> randkey=llvm::cryptoutils-&gt;<span class="keyword">get_uint8_t</span>();</span><br><span class="line">                                keys[i]=randkey;</span><br><span class="line">                                <span class="keyword">int</span> enclen=randkey+defaultKStringSize;</span><br><span class="line">                                <span class="keyword">for</span>(<span class="keyword">int</span> y=randkey;y&lt;enclen;y++)&#123;</span><br><span class="line">                                    <span class="keyword">if</span>(y==randkey)&#123;</span><br><span class="line">                                        encres[i]=strdata[i]^y;</span><br><span class="line">                                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(y==enclen<span class="number">-1</span>)&#123;</span><br><span class="line">                                        encres[i]=encres[i]^(~y);</span><br><span class="line">                                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                        encres[i]=encres[i]^y;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    <span class="built_in">printf</span>(<span class="string">&quot;%x &quot;</span>,encres[i]);</span><br><span class="line">                                    idx++;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            ArrayType* arrType=ArrayType::<span class="built_in">get</span>(Type::getInt8Ty(func.getContext()),strdata.<span class="built_in">size</span>());</span><br><span class="line">                            AllocaInst* arrayInst=<span class="keyword">new</span> AllocaInst(arrType,<span class="number">0</span>,<span class="literal">nullptr</span>,<span class="number">1</span>,Twine(stripOp-&gt;getName()+<span class="string">&quot;.arr&quot;</span>),begin_ins);</span><br><span class="line">                            BitCastInst* bitInst=<span class="keyword">new</span> BitCastInst(arrayInst,Type::getInt8PtrTy(func.getParent()-&gt;getContext()),Twine(stripOp-&gt;getName()+<span class="string">&quot;.bitcast&quot;</span>),begin_ins);</span><br><span class="line">                            <span class="comment">//创建一个对象用来存放当前加密字节解密时每次异或的结果</span></span><br><span class="line">                            AllocaInst* eor_res=<span class="keyword">new</span> AllocaInst(Type::getInt8Ty(func.getContext()),<span class="number">0</span>,<span class="literal">nullptr</span>,<span class="number">1</span>,Twine(stripOp-&gt;getName()+<span class="string">&quot;.alloc.res&quot;</span>),begin_ins);</span><br><span class="line">                            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strdata.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                                <span class="keyword">uint8_t</span> randkey=keys[i];</span><br><span class="line">                                <span class="keyword">int</span> enclen=randkey+defaultKStringSize;</span><br><span class="line">                                ConstantInt* enc_const=ConstantInt::<span class="built_in">get</span>(Type::getInt8Ty(func.getContext()),encres[i]);</span><br><span class="line">                                <span class="comment">//用来存放解密结果的bitcat</span></span><br><span class="line">                                ConstantInt* i_const=ConstantInt::<span class="built_in">get</span>(Type::getInt8Ty(func.getContext()),i);</span><br><span class="line">                                GetElementPtrInst* element=GetElementPtrInst::CreateInBounds(bitInst,i_const);</span><br><span class="line">                                element-&gt;insertBefore(begin_ins);</span><br><span class="line">                                StoreInst* last_store=<span class="literal">nullptr</span>;</span><br><span class="line">                                <span class="keyword">for</span>(<span class="keyword">int</span> y=enclen<span class="number">-1</span>;y&gt;=randkey;y--)&#123;</span><br><span class="line">                                    <span class="comment">/*下面是获取y的指令块*/</span></span><br><span class="line">                                    <span class="comment">//先是创建一个数值y</span></span><br><span class="line">                                    ConstantInt *eor_data = ConstantInt::<span class="built_in">get</span>(Type::getInt8Ty(func.getContext()),y);</span><br><span class="line">                                    <span class="comment">//申请一个int8的内存来存放数值y</span></span><br><span class="line">                                    AllocaInst* eor_alloc=<span class="keyword">new</span> AllocaInst(Type::getInt8Ty(func.getContext()),<span class="number">0</span>,<span class="literal">nullptr</span>,<span class="number">1</span>,Twine(stripOp-&gt;getName()+<span class="string">&quot;.alloc.y&quot;</span>),begin_ins);</span><br><span class="line">                                    <span class="comment">//将数值y赋值给申请的内存空间</span></span><br><span class="line">                                    StoreInst* store_eor=<span class="keyword">new</span> StoreInst(eor_data,eor_alloc);</span><br><span class="line">                                    store_eor-&gt;insertAfter(eor_alloc);</span><br><span class="line">                                    <span class="comment">//从内存空间中加载里面的数值y</span></span><br><span class="line">                                    LoadInst* eor_load=<span class="keyword">new</span> LoadInst(eor_alloc,<span class="string">&quot;&quot;</span>);</span><br><span class="line">                                    eor_load-&gt;insertAfter(store_eor);</span><br><span class="line">                                    <span class="comment">//</span></span><br><span class="line">                                    <span class="keyword">if</span>(y==enclen<span class="number">-1</span>)&#123;</span><br><span class="line">                                        <span class="comment">//然后进行取反计算</span></span><br><span class="line">                                        BinaryOperator* binNotOp=BinaryOperator::CreateNot(eor_load);</span><br><span class="line">                                        binNotOp-&gt;insertAfter(eor_load);</span><br><span class="line">                                        <span class="comment">//然后异或</span></span><br><span class="line">                                        BinaryOperator* binXorOp=BinaryOperator::CreateXor(enc_const,binNotOp);</span><br><span class="line">                                        binXorOp-&gt;insertAfter(binNotOp);</span><br><span class="line">                                        <span class="comment">//将加密字节设置为上次异或的结果</span></span><br><span class="line">                                        StoreInst* store_eor_res=<span class="keyword">new</span> StoreInst(binXorOp,eor_res);</span><br><span class="line">                                        store_eor_res-&gt;insertAfter(binXorOp);</span><br><span class="line">                                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                        LoadInst* eor_load_res=<span class="keyword">new</span> LoadInst(eor_res,stripOp-&gt;getName()+<span class="string">&quot;.load&quot;</span>);</span><br><span class="line">                                        eor_load_res-&gt;insertAfter(store_eor);</span><br><span class="line">                                        <span class="comment">//然后进行异或计算</span></span><br><span class="line">                                        BinaryOperator* binXorOp=BinaryOperator::CreateXor(eor_load_res,eor_load);</span><br><span class="line">                                        binXorOp-&gt;insertAfter(eor_load);</span><br><span class="line">                                        <span class="comment">//将计算后的结果存放回数组中</span></span><br><span class="line">                                        StoreInst* store_data=<span class="keyword">new</span> StoreInst(binXorOp,eor_res);</span><br><span class="line">                                        store_data-&gt;insertAfter(binXorOp);</span><br><span class="line">                                        <span class="keyword">if</span>(y==randkey)&#123;</span><br><span class="line">                                            last_store=store_data;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">//读取这个字节经过多次异或后的最终结果</span></span><br><span class="line">                                LoadInst* dec_res=<span class="keyword">new</span> LoadInst(eor_res,stripOp-&gt;getName()+<span class="string">&quot;.dec.res&quot;</span>);</span><br><span class="line">                                dec_res-&gt;insertAfter(last_store);</span><br><span class="line">                                <span class="comment">//将这个结果写入到前面用来存放的解密结果bitcat处</span></span><br><span class="line">                                StoreInst* store_data=<span class="keyword">new</span> StoreInst(dec_res,element);</span><br><span class="line">                                store_data-&gt;insertAfter(dec_res);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//将字符串操作数替换为我们准备好的解密结果的bitInst</span></span><br><span class="line">                            val-&gt;replaceAllUsesWith(bitInst);</span><br><span class="line">                            <span class="comment">//然后再删掉之前我们获取到的字符串的明文部分。这样就只有密文数据和密文解密的流程，最后动态执行拿到解密字符串了</span></span><br><span class="line">                            GlobalVariable* globalVar= dyn_cast&lt;GlobalVariable&gt;(stripOp);</span><br><span class="line">                            globalVar-&gt;eraseFromParent();</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> KStringEncode::ID = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> RegisterPass&lt;KStringEncode&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;kstr&quot;</span>, <span class="string">&quot;inserting bogus control flow&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Pass *<span class="title">llvm::createKStringEncode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> KStringEncode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Pass *<span class="title">llvm::createKStringEncode</span><span class="params">(<span class="keyword">bool</span> flag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> KStringEncode(flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后我们来执行测试一下,执行下面的命令使用这个pass进行加密</p><p><code>clang -Xclang -load -Xclang /mnt/hgfs/kali_share/kOLLVM/cmake-build-debug/ollvm/lib/Transforms/Obfuscation/LLVMObfuscation.so -mllvm -kstr -mllvm -kstr_size=10 -emit-llvm -S  main.cpp -o main_ollvm_kstr.ll</code></p><p>检查下这个ir文件没啥问题。那么编译成二进制。</p><p><code>clang main_ollvm_kstr.ll -o main</code></p><p>接着我们再用ida打开看看这个二进制文件的main函数里面的字符串是否已经被混淆了</p><p>先看看测试混淆的目标代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* str = <span class="string">&quot;kanxue&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> n = argc;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello ollvm:%d\r\n&quot;</span>, n);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再看看混淆后，使用ida打开的结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// [rsp+3Bh] [rbp-65h]</span></span><br><span class="line">  <span class="keyword">char</span> v5; <span class="comment">// [rsp+3Ch] [rbp-64h]</span></span><br><span class="line">  <span class="keyword">char</span> v6; <span class="comment">// [rsp+3Dh] [rbp-63h]</span></span><br><span class="line">  <span class="keyword">char</span> v7; <span class="comment">// [rsp+3Eh] [rbp-62h]</span></span><br><span class="line">  <span class="keyword">char</span> v8; <span class="comment">// [rsp+3Fh] [rbp-61h]</span></span><br><span class="line">  <span class="keyword">char</span> v9; <span class="comment">// [rsp+40h] [rbp-60h]</span></span><br><span class="line">  <span class="keyword">char</span> v10; <span class="comment">// [rsp+41h] [rbp-5Fh]</span></span><br><span class="line">  <span class="keyword">char</span> v11; <span class="comment">// [rsp+42h] [rbp-5Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v12; <span class="comment">// [rsp+43h] [rbp-5Dh]</span></span><br><span class="line">  <span class="keyword">char</span> v13; <span class="comment">// [rsp+44h] [rbp-5Ch]</span></span><br><span class="line">  <span class="keyword">char</span> v14; <span class="comment">// [rsp+45h] [rbp-5Bh]</span></span><br><span class="line">  <span class="keyword">char</span> v15; <span class="comment">// [rsp+46h] [rbp-5Ah]</span></span><br><span class="line">  <span class="keyword">char</span> v16; <span class="comment">// [rsp+47h] [rbp-59h]</span></span><br><span class="line">  <span class="keyword">char</span> v17; <span class="comment">// [rsp+48h] [rbp-58h]</span></span><br><span class="line">  <span class="keyword">char</span> v18; <span class="comment">// [rsp+49h] [rbp-57h]</span></span><br><span class="line">  <span class="keyword">char</span> v19; <span class="comment">// [rsp+4Ah] [rbp-56h]</span></span><br><span class="line">  <span class="keyword">char</span> v20; <span class="comment">// [rsp+4Bh] [rbp-55h]</span></span><br><span class="line">  <span class="keyword">char</span> v21; <span class="comment">// [rsp+4Ch] [rbp-54h]</span></span><br><span class="line">  <span class="keyword">char</span> v22; <span class="comment">// [rsp+4Dh] [rbp-53h]</span></span><br><span class="line">  <span class="keyword">char</span> v23; <span class="comment">// [rsp+4Eh] [rbp-52h]</span></span><br><span class="line">  <span class="keyword">char</span> v24; <span class="comment">// [rsp+4Fh] [rbp-51h]</span></span><br><span class="line">  <span class="keyword">char</span> v25; <span class="comment">// [rsp+50h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">char</span> v26; <span class="comment">// [rsp+51h] [rbp-4Fh]</span></span><br><span class="line">  <span class="keyword">char</span> v27; <span class="comment">// [rsp+52h] [rbp-4Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v28; <span class="comment">// [rsp+53h] [rbp-4Dh]</span></span><br><span class="line">  <span class="keyword">char</span> v29; <span class="comment">// [rsp+54h] [rbp-4Ch]</span></span><br><span class="line">  <span class="keyword">char</span> v30; <span class="comment">// [rsp+55h] [rbp-4Bh]</span></span><br><span class="line">  <span class="keyword">char</span> v31; <span class="comment">// [rsp+56h] [rbp-4Ah]</span></span><br><span class="line">  <span class="keyword">char</span> v32; <span class="comment">// [rsp+57h] [rbp-49h]</span></span><br><span class="line">  <span class="keyword">char</span> v33; <span class="comment">// [rsp+58h] [rbp-48h]</span></span><br><span class="line">  <span class="keyword">char</span> v34; <span class="comment">// [rsp+59h] [rbp-47h]</span></span><br><span class="line">  <span class="keyword">char</span> v35; <span class="comment">// [rsp+5Ah] [rbp-46h]</span></span><br><span class="line">  <span class="keyword">char</span> v36; <span class="comment">// [rsp+5Bh] [rbp-45h]</span></span><br><span class="line">  <span class="keyword">char</span> v37; <span class="comment">// [rsp+5Ch] [rbp-44h]</span></span><br><span class="line">  <span class="keyword">char</span> v38; <span class="comment">// [rsp+5Dh] [rbp-43h]</span></span><br><span class="line">  <span class="keyword">char</span> v39; <span class="comment">// [rsp+5Eh] [rbp-42h]</span></span><br><span class="line">  <span class="keyword">char</span> v40; <span class="comment">// [rsp+5Fh] [rbp-41h]</span></span><br><span class="line">  <span class="keyword">char</span> v41; <span class="comment">// [rsp+60h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">char</span> v42; <span class="comment">// [rsp+61h] [rbp-3Fh]</span></span><br><span class="line">  <span class="keyword">char</span> v43; <span class="comment">// [rsp+62h] [rbp-3Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v44; <span class="comment">// [rsp+63h] [rbp-3Dh]</span></span><br><span class="line">  <span class="keyword">char</span> v45; <span class="comment">// [rsp+64h] [rbp-3Ch]</span></span><br><span class="line">  <span class="keyword">char</span> v46; <span class="comment">// [rsp+65h] [rbp-3Bh]</span></span><br><span class="line">  <span class="keyword">char</span> v47; <span class="comment">// [rsp+66h] [rbp-3Ah]</span></span><br><span class="line">  <span class="keyword">char</span> v48; <span class="comment">// [rsp+67h] [rbp-39h]</span></span><br><span class="line">  <span class="keyword">char</span> v49; <span class="comment">// [rsp+68h] [rbp-38h]</span></span><br><span class="line">  <span class="keyword">char</span> v50; <span class="comment">// [rsp+69h] [rbp-37h]</span></span><br><span class="line">  <span class="keyword">char</span> v51; <span class="comment">// [rsp+6Ah] [rbp-36h]</span></span><br><span class="line">  <span class="keyword">char</span> v52; <span class="comment">// [rsp+6Bh] [rbp-35h]</span></span><br><span class="line">  <span class="keyword">char</span> v53; <span class="comment">// [rsp+6Ch] [rbp-34h]</span></span><br><span class="line">  <span class="keyword">char</span> v54; <span class="comment">// [rsp+6Dh] [rbp-33h]</span></span><br><span class="line">  <span class="keyword">char</span> v55; <span class="comment">// [rsp+6Eh] [rbp-32h]</span></span><br><span class="line">  <span class="keyword">char</span> v56; <span class="comment">// [rsp+6Fh] [rbp-31h]</span></span><br><span class="line">  <span class="keyword">char</span> v57; <span class="comment">// [rsp+70h] [rbp-30h]</span></span><br><span class="line">  <span class="keyword">char</span> v58; <span class="comment">// [rsp+71h] [rbp-2Fh]</span></span><br><span class="line">  <span class="keyword">char</span> v59; <span class="comment">// [rsp+72h] [rbp-2Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v60; <span class="comment">// [rsp+73h] [rbp-2Dh]</span></span><br><span class="line">  <span class="keyword">char</span> v61; <span class="comment">// [rsp+74h] [rbp-2Ch]</span></span><br><span class="line">  <span class="keyword">char</span> v62; <span class="comment">// [rsp+75h] [rbp-2Bh]</span></span><br><span class="line">  <span class="keyword">char</span> v63; <span class="comment">// [rsp+76h] [rbp-2Ah]</span></span><br><span class="line">  <span class="keyword">char</span> v64; <span class="comment">// [rsp+77h] [rbp-29h]</span></span><br><span class="line">  <span class="keyword">char</span> v65; <span class="comment">// [rsp+78h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">char</span> v66; <span class="comment">// [rsp+79h] [rbp-27h]</span></span><br><span class="line">  <span class="keyword">char</span> v67; <span class="comment">// [rsp+7Ah] [rbp-26h]</span></span><br><span class="line">  <span class="keyword">char</span> v68; <span class="comment">// [rsp+7Bh] [rbp-25h]</span></span><br><span class="line">  <span class="keyword">char</span> v69; <span class="comment">// [rsp+7Ch] [rbp-24h]</span></span><br><span class="line">  <span class="keyword">char</span> v70; <span class="comment">// [rsp+7Dh] [rbp-23h]</span></span><br><span class="line">  <span class="keyword">char</span> v71; <span class="comment">// [rsp+7Eh] [rbp-22h]</span></span><br><span class="line">  <span class="keyword">char</span> v72; <span class="comment">// [rsp+7Fh] [rbp-21h]</span></span><br><span class="line">  <span class="keyword">char</span> v73; <span class="comment">// [rsp+80h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">char</span> v74; <span class="comment">// [rsp+81h] [rbp-1Fh]</span></span><br><span class="line">  <span class="keyword">char</span> v75; <span class="comment">// [rsp+82h] [rbp-1Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v76; <span class="comment">// [rsp+83h] [rbp-1Dh]</span></span><br><span class="line">  <span class="keyword">char</span> v77; <span class="comment">// [rsp+84h] [rbp-1Ch]</span></span><br><span class="line">  <span class="keyword">char</span> v78; <span class="comment">// [rsp+85h] [rbp-1Bh]</span></span><br><span class="line">  <span class="keyword">char</span> v79; <span class="comment">// [rsp+86h] [rbp-1Ah]</span></span><br><span class="line">  <span class="keyword">char</span> v80; <span class="comment">// [rsp+87h] [rbp-19h]</span></span><br><span class="line">  <span class="keyword">char</span> v81; <span class="comment">// [rsp+88h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">char</span> v82; <span class="comment">// [rsp+89h] [rbp-17h]</span></span><br><span class="line">  <span class="keyword">char</span> v83; <span class="comment">// [rsp+8Ah] [rbp-16h]</span></span><br><span class="line">  <span class="keyword">char</span> v84; <span class="comment">// [rsp+8Bh] [rbp-15h]</span></span><br><span class="line">  <span class="keyword">char</span> v85; <span class="comment">// [rsp+8Ch] [rbp-14h]</span></span><br><span class="line">  <span class="keyword">char</span> v86; <span class="comment">// [rsp+8Dh] [rbp-13h]</span></span><br><span class="line">  <span class="keyword">char</span> v87; <span class="comment">// [rsp+8Eh] [rbp-12h]</span></span><br><span class="line">  <span class="keyword">char</span> v88; <span class="comment">// [rsp+8Fh] [rbp-11h]</span></span><br><span class="line">  <span class="keyword">char</span> v89; <span class="comment">// [rsp+90h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">char</span> v90; <span class="comment">// [rsp+91h] [rbp-Fh]</span></span><br><span class="line">  <span class="keyword">char</span> v91; <span class="comment">// [rsp+92h] [rbp-Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v92; <span class="comment">// [rsp+93h] [rbp-Dh]</span></span><br><span class="line">  <span class="keyword">char</span> v93; <span class="comment">// [rsp+94h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">char</span> v94; <span class="comment">// [rsp+95h] [rbp-Bh]</span></span><br><span class="line">  <span class="keyword">char</span> v95; <span class="comment">// [rsp+96h] [rbp-Ah]</span></span><br><span class="line">  <span class="keyword">char</span> v96; <span class="comment">// [rsp+97h] [rbp-9h]</span></span><br><span class="line">  <span class="keyword">char</span> v97; <span class="comment">// [rsp+98h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">char</span> v98; <span class="comment">// [rsp+99h] [rbp-7h]</span></span><br><span class="line">  <span class="keyword">char</span> v99; <span class="comment">// [rsp+9Ah] [rbp-6h]</span></span><br><span class="line">  <span class="keyword">char</span> v100; <span class="comment">// [rsp+9Bh] [rbp-5h]</span></span><br><span class="line">  <span class="keyword">char</span> v101; <span class="comment">// [rsp+9Ch] [rbp-4h]</span></span><br><span class="line">  <span class="keyword">char</span> v102; <span class="comment">// [rsp+9Dh] [rbp-3h]</span></span><br><span class="line">  <span class="keyword">char</span> v103; <span class="comment">// [rsp+9Eh] [rbp-2h]</span></span><br><span class="line">  <span class="keyword">char</span> v104; <span class="comment">// [rsp+9Fh] [rbp-1h]</span></span><br><span class="line"></span><br><span class="line">  v96 = <span class="number">94</span>;</span><br><span class="line">  v95 = <span class="number">93</span>;</span><br><span class="line">  v94 = <span class="number">92</span>;</span><br><span class="line">  v98 = <span class="number">107</span>;</span><br><span class="line">  v93 = <span class="number">237</span>;</span><br><span class="line">  v92 = <span class="number">236</span>;</span><br><span class="line">  v91 = <span class="number">235</span>;</span><br><span class="line">  v99 = <span class="number">97</span>;</span><br><span class="line">  v90 = <span class="number">122</span>;</span><br><span class="line">  v89 = <span class="number">121</span>;</span><br><span class="line">  v88 = <span class="number">120</span>;</span><br><span class="line">  v100 = <span class="number">110</span>;</span><br><span class="line">  v87 = <span class="number">129</span>;</span><br><span class="line">  v86 = <span class="number">128</span>;</span><br><span class="line">  v85 = <span class="number">127</span>;</span><br><span class="line">  v101 = <span class="number">120</span>;</span><br><span class="line">  v84 = <span class="number">-55</span>;</span><br><span class="line">  v83 = <span class="number">-56</span>;</span><br><span class="line">  v82 = <span class="number">-57</span>;</span><br><span class="line">  v102 = <span class="number">117</span>;</span><br><span class="line">  v81 = <span class="number">-100</span>;</span><br><span class="line">  v80 = <span class="number">-101</span>;</span><br><span class="line">  v79 = <span class="number">-102</span>;</span><br><span class="line">  v103 = <span class="number">101</span>;</span><br><span class="line">  v78 = <span class="number">87</span>;</span><br><span class="line">  v77 = <span class="number">86</span>;</span><br><span class="line">  v76 = <span class="number">85</span>;</span><br><span class="line">  v97 = <span class="number">0</span>;</span><br><span class="line">  v104 = <span class="number">0</span>;</span><br><span class="line">  v57 = <span class="number">-104</span>;</span><br><span class="line">  v56 = <span class="number">-105</span>;</span><br><span class="line">  v55 = <span class="number">-106</span>;</span><br><span class="line">  v59 = <span class="number">104</span>;</span><br><span class="line">  v54 = <span class="number">73</span>;</span><br><span class="line">  v53 = <span class="number">72</span>;</span><br><span class="line">  v52 = <span class="number">71</span>;</span><br><span class="line">  v60 = <span class="number">101</span>;</span><br><span class="line">  v51 = <span class="number">-109</span>;</span><br><span class="line">  v50 = <span class="number">-110</span>;</span><br><span class="line">  v49 = <span class="number">-111</span>;</span><br><span class="line">  v61 = <span class="number">108</span>;</span><br><span class="line">  v48 = <span class="number">42</span>;</span><br><span class="line">  v47 = <span class="number">41</span>;</span><br><span class="line">  v46 = <span class="number">40</span>;</span><br><span class="line">  v62 = <span class="number">108</span>;</span><br><span class="line">  v45 = <span class="number">-81</span>;</span><br><span class="line">  v44 = <span class="number">-82</span>;</span><br><span class="line">  v43 = <span class="number">-83</span>;</span><br><span class="line">  v63 = <span class="number">111</span>;</span><br><span class="line">  v42 = <span class="number">-78</span>;</span><br><span class="line">  v41 = <span class="number">-79</span>;</span><br><span class="line">  v40 = <span class="number">-80</span>;</span><br><span class="line">  v64 = <span class="number">32</span>;</span><br><span class="line">  v39 = <span class="number">-116</span>;</span><br><span class="line">  v38 = <span class="number">-117</span>;</span><br><span class="line">  v37 = <span class="number">-118</span>;</span><br><span class="line">  v65 = <span class="number">111</span>;</span><br><span class="line">  v36 = <span class="number">99</span>;</span><br><span class="line">  v35 = <span class="number">98</span>;</span><br><span class="line">  v34 = <span class="number">97</span>;</span><br><span class="line">  v66 = <span class="number">108</span>;</span><br><span class="line">  v33 = <span class="number">12</span>;</span><br><span class="line">  v32 = <span class="number">11</span>;</span><br><span class="line">  v31 = <span class="number">10</span>;</span><br><span class="line">  v67 = <span class="number">108</span>;</span><br><span class="line">  v30 = <span class="number">95</span>;</span><br><span class="line">  v29 = <span class="number">94</span>;</span><br><span class="line">  v28 = <span class="number">93</span>;</span><br><span class="line">  v68 = <span class="number">118</span>;</span><br><span class="line">  v27 = <span class="number">9</span>;</span><br><span class="line">  v26 = <span class="number">8</span>;</span><br><span class="line">  v25 = <span class="number">7</span>;</span><br><span class="line">  v69 = <span class="number">109</span>;</span><br><span class="line">  v24 = <span class="number">26</span>;</span><br><span class="line">  v23 = <span class="number">25</span>;</span><br><span class="line">  v22 = <span class="number">24</span>;</span><br><span class="line">  v70 = <span class="number">58</span>;</span><br><span class="line">  v21 = <span class="number">109</span>;</span><br><span class="line">  v20 = <span class="number">108</span>;</span><br><span class="line">  v19 = <span class="number">107</span>;</span><br><span class="line">  v71 = <span class="number">37</span>;</span><br><span class="line">  v18 = <span class="number">92</span>;</span><br><span class="line">  v17 = <span class="number">91</span>;</span><br><span class="line">  v16 = <span class="number">90</span>;</span><br><span class="line">  v72 = <span class="number">100</span>;</span><br><span class="line">  v15 = <span class="number">-50</span>;</span><br><span class="line">  v14 = <span class="number">-51</span>;</span><br><span class="line">  v13 = <span class="number">-52</span>;</span><br><span class="line">  v73 = <span class="number">13</span>;</span><br><span class="line">  v12 = <span class="number">119</span>;</span><br><span class="line">  v11 = <span class="number">118</span>;</span><br><span class="line">  v10 = <span class="number">117</span>;</span><br><span class="line">  v74 = <span class="number">10</span>;</span><br><span class="line">  v9 = <span class="number">4</span>;</span><br><span class="line">  v8 = <span class="number">3</span>;</span><br><span class="line">  v7 = <span class="number">2</span>;</span><br><span class="line">  v58 = <span class="number">0</span>;</span><br><span class="line">  v75 = <span class="number">0</span>;</span><br><span class="line">  v4 = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">  v5 = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( argc &lt; <span class="number">2</span> )</span><br><span class="line">    <span class="built_in">printf</span>(&amp;v4, &amp;v98, &amp;v4);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(&amp;v59, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)argc, &amp;v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管看起来好像已经混淆成功了，但是实际上依然可以看到ida给我们自动解析了很多，字符串基本被还原了一些，比如找到&amp;98然后往后的几个字节存放的就已经是明文了。这里我们只要再加一层混淆。让代码的结构更加混乱。ida就无法自动还原出我们的字符串明文了。再增加一些参数混淆下。</p><p><code>clang -Xclang -load -Xclang /mnt/hgfs/kali_share/kOLLVM/cmake-build-debug/ollvm/lib/Transforms/Obfuscation/LLVMObfuscation.so -mllvm -kstr -mllvm -kstr_size=10 -mllvm -bcf -mllvm -bcf_loop=3 -mllvm -fla -emit-llvm -S  main.cpp -o main_ollvm_kstr.ll</code></p>]]></content>
      
      
      <categories>
          
          <category> ollve </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>llvm的pass</title>
      <link href="/2020/09/11/llvm2/"/>
      <url>/2020/09/11/llvm2/</url>
      
        <content type="html"><![CDATA[<h2 id="llvm中的pass例子"><a href="#llvm中的pass例子" class="headerlink" title="llvm中的pass例子"></a>llvm中的pass例子</h2><p>llvm中最重要的部分就是pass，llvm主要就是通过pass来对代码进行优化工作。然后先看怎么使用pass。官方有默认注册很多种pass。所有pass都是在<code>llvm/lib/Transforms</code>目录下，可以通过opt来使用pass,先看官方例子最简单的pass,路径是<code>llvm/lib/Transforms/Hello/Hello.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/ADT/Statistic.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/Function.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Pass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Support/raw_ostream.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG_TYPE <span class="meta-string">&quot;hello&quot;</span></span></span><br><span class="line"></span><br><span class="line">STATISTIC(HelloCounter, <span class="string">&quot;Counts number of functions greeted&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">  <span class="comment">// Hello - The first implementation, without getAnalysisUsage.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Hello</span> :</span> <span class="keyword">public</span> FunctionPass &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> ID; <span class="comment">// Pass identification, replacement for typeid</span></span><br><span class="line">    Hello() : FunctionPass(ID) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">      ++HelloCounter;</span><br><span class="line">      errs() &lt;&lt; <span class="string">&quot;Hello: &quot;</span>;</span><br><span class="line">      errs().write_escaped(F.getName()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> Hello::ID = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> RegisterPass&lt;Hello&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;Hello World Pass&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>这里最重要的就是runOnFunction函数，所有函数都会经过里进行处理，这个例子只是简单的打印了一个hello和函数名。下面的RegisterPass是这个pass的名称和描述，然后可以搜一下这个例子编译的文件路径，我的该文件路径如下，由于我是mac的，所以是dylib的动态库</p><a id="more"></a><p><code>/llvm/cmake-build-debug/lib/LLVMHello.dylib</code></p><p>然后写一个简单的项目测试一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!!&quot;</span>);</span><br><span class="line">    test1();</span><br><span class="line">    test2();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把c文件编译成bc二进制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -emit-llvm -c main.c -o main.bc</span><br></pre></td></tr></table></figure><p>然后用opt指定pass来处理这个main.bc，格式如下 opt -load &lt;pass动态库路径&gt;  -pass名称  要进行优化的对象</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opt -load /Volumes/my_source/ollvm/llvm-project-llvmorg-9.0.1/llvm/cmake-build-debug/lib/LLVMHello.dylib -hello /Volumes/mac_disk/src/vscode_project/main.bc</span><br></pre></td></tr></table></figure><p>最后看到的结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello: test1</span><br><span class="line">Hello: test2</span><br><span class="line">Hello: main</span><br></pre></td></tr></table></figure><h2 id="自己写一个pass加密函数名称"><a href="#自己写一个pass加密函数名称" class="headerlink" title="自己写一个pass加密函数名称"></a>自己写一个pass加密函数名称</h2><p>先贴个官网文档的地址<a href="https://releases.llvm.org/9.0.0/docs/WritingAnLLVMPass.html">https://releases.llvm.org/9.0.0/docs/WritingAnLLVMPass.html</a></p><p>在官方文档中有详细描述怎么写个pass，下面先贴一下原文</p><p><img src="/2020/09/11/llvm2/image-20200911214739897.png" alt="image-20200911214739897"></p><p><img src="/2020/09/11/llvm2/image-20200911214816004.png" alt="image-20200911214816004"></p><p><img src="/2020/09/11/llvm2/image-20200911214848705.png" alt="image-20200911214848705"></p><p>按照文档的的描述，大概就是，在Transforms下新建一个目录，用来存放我们自己的pass，这里我建一个KingEncode目录，然后在这个目录下面创建两个文件,KingEncode.cpp和CMakeLists.txt。</p><p>然后一顿复制粘贴，将Hello的地方替换成我们自己的pass名称即可,下面贴上我的两个文件内容，我们自己的这个pass简单的用md5对函数名加密了一下。然后再设置回去。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by king on 2020/9/10.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Pass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/Function.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Support/raw_ostream.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/LegacyPassManager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KingEncode</span> :</span> <span class="keyword">public</span> FunctionPass &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> ID;</span><br><span class="line">  KingEncode() : FunctionPass(ID) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    errs() &lt;&lt; <span class="string">&quot;KingEncode: &quot;</span>;</span><br><span class="line">    MD5 Hasher;</span><br><span class="line">    MD5::MD5Result Result;</span><br><span class="line">    Hasher.update(F.getName());</span><br><span class="line">    Hasher.<span class="keyword">final</span>(Result);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> md5=Result.digest().str().str();</span><br><span class="line">    F.setName(md5);</span><br><span class="line">    errs().write_escaped(F.getName()) &lt;&lt;<span class="string">&quot;--&gt;&quot;</span>&lt;&lt;md5&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> KingEncode::ID = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> RegisterPass&lt;KingEncode&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;kingencode&quot;</span>, <span class="string">&quot;king encode Pass&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="literal">false</span> <span class="comment">/* Only looks at CFG */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="literal">false</span> <span class="comment">/* Analysis Pass */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> llvm::RegisterStandardPasses <span class="title">Y</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    llvm::PassManagerBuilder::EP_EarlyAsPossible,</span></span></span><br><span class="line"><span class="function"><span class="params">[](<span class="keyword">const</span> llvm::PassManagerBuilder &amp;Builder,</span></span></span><br><span class="line"><span class="function"><span class="params">   llvm::legacy::PassManagerBase &amp;PM) &#123; PM.add(<span class="keyword">new</span> KingEncode()); &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一个CMakeLists.txt的文件如下</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_llvm_library( LLVMKingEncode MODULE</span><br><span class="line">        KingEncode.cpp</span><br><span class="line"></span><br><span class="line">        PLUGIN_TOOL</span><br><span class="line">        opt</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>除了这两个外，再修改下Transforms下的CMakeLists.txt，在最后的位置将我们这个新增的pass加进去</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(KingEncode)</span><br></pre></td></tr></table></figure><p>然后单独编译一下ninja LLVMKingEncode</p><p>编译完后，再用opt使用这个pass处理我们的简单例子，先把例子编译成IR文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -emit-llvm -S main.c -o main.ll</span><br></pre></td></tr></table></figure><p>然后使用opt生成bc文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opt -load /Volumes/my_source/ollvm/llvm-project-llvmorg-9.0.1/llvm/cmake-build-debug/lib/LLVMKingEncode.dylib -kingencode /Volumes/mac_disk/src/vscode_project/main.ll -o /Volumes/mac_disk/src/vscode_project/main.bc</span><br></pre></td></tr></table></figure><p>然后贴上执行的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">KingEncode: test1--&gt;5a105e8b9d40e1329780d62ea2265d8a</span><br><span class="line">KingEncode: test2--&gt;ad0234829205b9033196ba818f7a872b</span><br><span class="line">KingEncode: main--&gt;fad58de7366495db4650cfefac2fcd61</span><br></pre></td></tr></table></figure><p>最后用clang编译成可执行程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang main.bc -o main</span><br></pre></td></tr></table></figure><p>意外发生了，编译失败，看看错误信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Undefined symbols for architecture x86_64:</span><br><span class="line">  &quot;_main&quot;, referenced from:</span><br><span class="line">     implicit entry&#x2F;start for main executable</span><br><span class="line">ld: symbol(s) not found for architecture x86_64</span><br><span class="line">clang-9: error: linker command failed with exit code 1 (use -v to see invocation)</span><br></pre></td></tr></table></figure><p>这个错误是因为，所有函数都会进入到runOnFunction，然后都被修改了名称，但是main函数是个特殊的函数，名称被修改后，就找不到入口了。所以这里得修改下pass，判断函数名非main的情况，我才进行修改，下面是修正的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Pass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/Function.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Support/raw_ostream.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/LegacyPassManager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KingEncode</span> :</span> <span class="keyword">public</span> FunctionPass &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> ID;</span><br><span class="line">  KingEncode() : FunctionPass(ID) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    errs() &lt;&lt; <span class="string">&quot;KingEncode: &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(F.getName().compare(<span class="string">&quot;main&quot;</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">      MD5 Hasher;</span><br><span class="line">      MD5::MD5Result Result;</span><br><span class="line">      Hasher.update(F.getName());</span><br><span class="line">      Hasher.<span class="keyword">final</span>(Result);</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> md5=Result.digest().str().str();</span><br><span class="line">      errs().write_escaped(F.getName()) &lt;&lt;<span class="string">&quot;--&gt;&quot;</span>&lt;&lt;md5&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      F.setName(md5);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      errs().write_escaped(F.getName()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> KingEncode::ID = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> RegisterPass&lt;KingEncode&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;kingencode&quot;</span>, <span class="string">&quot;king encode Pass&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="literal">false</span> <span class="comment">/* Only looks at CFG */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="literal">false</span> <span class="comment">/* Analysis Pass */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> llvm::RegisterStandardPasses <span class="title">Y</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    llvm::PassManagerBuilder::EP_EarlyAsPossible,</span></span></span><br><span class="line"><span class="function"><span class="params">[](<span class="keyword">const</span> llvm::PassManagerBuilder &amp;Builder,</span></span></span><br><span class="line"><span class="function"><span class="params">   llvm::legacy::PassManagerBase &amp;PM) &#123; PM.add(<span class="keyword">new</span> KingEncode()); &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们重新来一次编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ninja LLVMKingEncode</span><br><span class="line">clang -emit-llvm -S main.c -o main.ll</span><br><span class="line">opt -load /Volumes/my_source/ollvm/llvm-project-llvmorg-9.0.1/llvm/cmake-build-debug/lib/LLVMKingEncode.dylib -kingencode /Volumes/mac_disk/src/vscode_project/main.ll -o main.bc</span><br><span class="line">clang main.bc -o main</span><br></pre></td></tr></table></figure><p>编译完后，再用ida打开这个main看看我们处理过的函数是什么样子</p><p><img src="/2020/09/11/llvm2/image-20200911222848851.png" alt="image-20200911222848851"></p><p>可以看到这个函数名称就被加密成MD5了。</p><h2 id="外部项目写pass"><a href="#外部项目写pass" class="headerlink" title="外部项目写pass"></a>外部项目写pass</h2><p>很多时候开发pass都是想单独在外面新建一个项目，并不是想直接在llvm内部写一个pass。这样也是可以的。并且这样更方便调试。这里官方文档也是有说明，同样先贴一段官方文档的描述</p><p><img src="/2020/09/11/llvm2/image-20200911223236520.png" alt="image-20200911223236520"></p><p>这里有清楚描述项目的层级，新建一个项目叫MyPass，然后在KingPass下新建一个CMakeList.txt和一个空目录KingEncrypt，结构如下图</p><p><img src="/2020/09/11/llvm2/image-20200921221821761.png" alt="image-20200921221821761"></p><p>然后把以下代码复制到KingPass下的CMakeList.txt中</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>.<span class="number">3</span>)</span><br><span class="line"><span class="keyword">project</span>(KingEncrypt)</span><br><span class="line"><span class="keyword">set</span>(LLVM_DIR /home/king/ollvm/llvm-<span class="keyword">project</span>-llvmorg-<span class="number">9.0</span>.<span class="number">1</span>/llvm/cmake-build-debug/lib/cmake/llvm)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11&quot;</span>)</span><br><span class="line"><span class="keyword">find_package</span>(LLVM REQUIRED CONFIG)</span><br><span class="line"><span class="keyword">list</span>(APPEND CMAKE_MODULE_PATH <span class="string">&quot;$&#123;LLVM_CMAKE_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">include</span>(AddLLVM)</span><br><span class="line"><span class="keyword">add_definitions</span>(<span class="variable">$&#123;LLVM_DEFINITIONS&#125;</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;LLVM_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(KingEncrypt)</span><br></pre></td></tr></table></figure><p>然后把之前上面写的pass和CMakeLists.txt直接放到KingEncrypt目录中即可，这里有个坑是不要在mac环境中搭建。否则会出现各种意外的错误。另外就是注意LLVM_DIR如果没有设置，虽然可以编译成功，但是使用时会报异常。</p><p>这样子编译后虽然可以用。但是每次使用都要用opt -load so的路径，这种方式太麻烦，所以最好还是在clang里面直接注册这个pass。注册后，就可以直接<code>clang -mllvm -king_encode main.cpp</code>这种方式来编译</p><p>主要是要改两点：编译成静态库、注册pass。</p><p>先是调整成静态库，修改KingEncode下的cmake</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">add_llvm_library( LLVMKingEncode</span><br><span class="line">        KingEncode.cpp</span><br><span class="line"></span><br><span class="line">        ADDITIONAL_HEADER_DIRS</span><br><span class="line">        <span class="variable">$&#123;LLVM_MAIN_INCLUDE_DIR&#125;</span>/llvm/Transforms</span><br><span class="line">        <span class="variable">$&#123;LLVM_MAIN_INCLUDE_DIR&#125;</span>/llvm/Transforms/KingEncode</span><br><span class="line"></span><br><span class="line">        DEPENDS</span><br><span class="line">        intrinsics_gen</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>然后再KingEncode目录下新增LLVMBuild.txt文件，下面是文件的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[component_0]</span><br><span class="line">type &#x3D; Library</span><br><span class="line">name &#x3D; KingEncode</span><br><span class="line">parent &#x3D; Transforms</span><br><span class="line">library_name &#x3D; KingEncode</span><br></pre></td></tr></table></figure><p>然后修改Transforms下的LLVMBuild.txt，在里面加上KingEncode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">subdirectories &#x3D; AggressiveInstCombine Coroutines IPO InstCombine Instrumentation Scalar Utils Vectorize ObjCARC KingEncode</span><br><span class="line"></span><br><span class="line">[component_0]</span><br><span class="line">type &#x3D; Group</span><br><span class="line">name &#x3D; Transforms</span><br><span class="line">parent &#x3D; Libraries</span><br></pre></td></tr></table></figure><p>然后这个pass是要在IPO中注册，所以Transforms/IPO下的LLVMBuild.txt也要修改，加上KingEncode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[component_0]</span><br><span class="line">type &#x3D; Library</span><br><span class="line">name &#x3D; IPO</span><br><span class="line">parent &#x3D; Transforms</span><br><span class="line">library_name &#x3D; ipo</span><br><span class="line">required_libraries &#x3D; AggressiveInstCombine Analysis BitReader BitWriter Core InstCombine IRReader Linker Object ProfileData Scalar Support TransformUtils Vectorize Instrumentation KingEncode</span><br></pre></td></tr></table></figure><p>静态编译的大概就是改这些地方，然后就是加上注册的逻辑，注册是在Transforms/IPO/PassManagerBuilder.cpp中处理</p><p>首先是在PassManagerBuilder.cpp中新增一个opt的参数判断</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> cl::opt&lt;<span class="keyword">bool</span>&gt; <span class="title">EnableKingEncode</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">&quot;king_encode&quot;</span>, cl::init(<span class="literal">false</span>), cl::Hidden,</span></span></span><br><span class="line"><span class="function"><span class="params">        cl::desc(<span class="string">&quot;king encode (default = off)&quot;</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>调用EnableKingEncode则会获取到是否有设置使用king_encode这个参数，如果有设置，我们就注册这个pass</p><p>为了方便给注册的地方调用，新增一个头文件KingEncode.h在目录/llvm/include/llvm/Transforms/KingEncode/中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LLVM_KINGENCODE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LLVM_KINGENCODE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;llvm/Pass.h&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> llvm&#123;</span><br><span class="line">    <span class="function">Pass* <span class="title">createKingEncode</span><span class="params">(<span class="keyword">bool</span> flag)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//LLVM_KINGENCODE_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后修改我们的pass提供一个注册的函数，以及使用参数进行判断，是否要使用该pass。下面是修改后的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Pass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/Function.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Support/raw_ostream.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/LegacyPassManager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Transforms/KingEncode/KingEncode.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KingEncode</span> :</span> <span class="keyword">public</span> FunctionPass &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> ID;</span><br><span class="line">  <span class="keyword">bool</span> enable_flag;</span><br><span class="line">  KingEncode() : FunctionPass(ID) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  KingEncode(<span class="keyword">bool</span> flag) : FunctionPass(ID) &#123;</span><br><span class="line">      enable_flag=flag;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(enable_flag)&#123;</span><br><span class="line">        errs() &lt;&lt; <span class="string">&quot;KingEncode: &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(F.getName().compare(<span class="string">&quot;main&quot;</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">            MD5 Hasher;</span><br><span class="line">            MD5::MD5Result Result;</span><br><span class="line">            Hasher.update(F.getName());</span><br><span class="line">            Hasher.<span class="keyword">final</span>(Result);</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> md5=Result.digest().str().str();</span><br><span class="line">            errs().write_escaped(F.getName()) &lt;&lt;<span class="string">&quot;--&gt;&quot;</span>&lt;&lt;md5&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            F.setName(md5);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            errs().write_escaped(F.getName()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">char</span> KingEncode::ID = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Pass* <span class="title">llvm::createKingEncode</span><span class="params">(<span class="keyword">bool</span> flag)</span></span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> KingEncode(flag);&#125;</span><br></pre></td></tr></table></figure><p>当我们注册的使用就是调用createKingEncode来返回一个pass。写好调用的函数后，再写注册的逻辑</p><p>注册的逻辑可以写在PassManagerBuilder.cpp里面的populateModulePassManager函数中，直接新增一段代码即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MPM.add(createKingEncode(EnableKingEncode));</span><br></pre></td></tr></table></figure><p>最后编译后直接调用命令即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -mllvm -king_encode main.cpp</span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KingEncode: _Z5test1v--&gt;40219bf854b4ca32a3c34d9c4b5abade</span><br><span class="line">KingEncode: main</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> llvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>llvm简单的使用</title>
      <link href="/2020/09/10/llvm1/"/>
      <url>/2020/09/10/llvm1/</url>
      
        <content type="html"><![CDATA[<p>学习记录</p><p>llvm是一款跨平台的编译器，我们可以用它来优化编译代码，让代码执行的更加高效，而ollvm是将代码进行编译混淆，增加代码的不可读性。它的官方网站是<a href="http://llvm.org/">http://llvm.org/</a></p><p>llvm中有一个中间语言是LLVM IR，这里看一段官方的说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The LLVM Core libraries provide a modern source- and target-independent optimizer, along with code generation support for many popular CPUs (as well as some less common ones!) These libraries are built around a well specified code representation known as the LLVM intermediate representation (&quot;LLVM IR&quot;). The LLVM Core libraries are well documented, and it is particularly easy to invent your own language (or port an existing compiler) to use LLVM as an optimizer and code generator.</span><br></pre></td></tr></table></figure><p>大概意思就是，LLVM IR是核心库的一个中间的语言，主要用来跨平台针对不同cpu的。在跨平台的时候我们可以这样编译，c源码编译成IR文件，然后IR是平台无关性的，我们在linux下编译的IR文件可以拿到win上面，然后再将IR文件编译成当前cpu的汇编。然后再由汇编编译成可执行二进制。这样就达到了跨平台的目的。</p><a id="more"></a><p>再看看另外一个llvm中的重要部分clang，先看一段官方说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Clang is an &quot;LLVM native&quot; C&#x2F;C++&#x2F;Objective-C compiler, which aims to deliver amazingly fast compiles, extremely useful error and warning messages and to provide a platform for building great source level tools. The Clang Static Analyzer and clang-tidy are tools that automatically find bugs in your code, and are great examples of the sort of tools that can be built using the Clang frontend as a library to parse C&#x2F;C++ code.</span><br></pre></td></tr></table></figure><p>clang是llvm中的一个c编译器，可以支持大多数和c相关的语言编译，比如C, C++, Objective C/C++, OpenCL, CUDA, and RenderScript。用gcc可以编译的，基本clang都可以。</p><p>然后看看llvm的编译，先放上官方的编译说明文档地址</p><p><code>http://llvm.org/docs/GettingStarted.html#getting-the-source-code-and-building-llvm</code></p><p>然后就可以看着说明文档编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Checkout LLVM (including related subprojects like Clang):</span><br><span class="line"></span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project.git</span><br><span class="line">Or, on windows, git clone --config core.autocrlf&#x3D;false https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project.git</span><br><span class="line">Configure and build LLVM and Clang:</span><br><span class="line"></span><br><span class="line">cd llvm-project</span><br><span class="line"></span><br><span class="line">mkdir build</span><br><span class="line"></span><br><span class="line">cd build</span><br><span class="line"></span><br><span class="line">cmake -G &lt;generator&gt; [options] ..&#x2F;llvm</span><br></pre></td></tr></table></figure><p>这里要注意的是cmake时的参数，第一个参数<generator> 这里是编译方式，默认是使用make，也可以设置使用Ninja。这里看官方的说明即可</generator></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ninja — for generating Ninja build files. Most llvm developers use Ninja.</span><br><span class="line">Unix Makefiles — for generating make-compatible parallel makefiles.</span><br><span class="line">Visual Studio — for generating Visual Studio projects and solutions.</span><br><span class="line">Xcode — for generating Xcode projects.</span><br></pre></td></tr></table></figure><p>另外一个参数<options> 可以设置编译的类型是debug还是release，编译哪些子项。</options></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-DLLVM_ENABLE_PROJECTS&#x3D;&#39;...&#39; — semicolon-separated list of the LLVM subprojects you’d like to additionally build. Can include any of: clang, clang-tools-extra, libcxx, libcxxabi, libunwind, lldb, compiler-rt, lld, polly, or debuginfo-tests.</span><br><span class="line"></span><br><span class="line">For example, to build LLVM, Clang, libcxx, and libcxxabi, use -DLLVM_ENABLE_PROJECTS&#x3D;&quot;clang;libcxx;libcxxabi&quot;.</span><br><span class="line"></span><br><span class="line">-DCMAKE_INSTALL_PREFIX&#x3D;directory — Specify for directory the full pathname of where you want the LLVM tools and libraries to be installed (default &#x2F;usr&#x2F;local).</span><br><span class="line"></span><br><span class="line">-DCMAKE_BUILD_TYPE&#x3D;type — Valid options for type are Debug, Release, RelWithDebInfo, and MinSizeRel. Default is Debug.</span><br><span class="line"></span><br><span class="line">-DLLVM_ENABLE_ASSERTIONS&#x3D;On — Compile with assertion checks enabled (default is Yes for Debug builds, No for all other build types).</span><br></pre></td></tr></table></figure><p>默认不填写编译类型是debug，下面是一个debug的编译</p><p><code>cmake -G Ninja -DCMAKE_BUILD_TYPE=Debug -DLLVM_ENABLE_PROJECTS=&quot;clang&quot; ../llvm</code></p><p>如果要编译release直接修改编译类型就可以了。这里完成之后。直接ninja -j4就开始编译了。如果不想完整编译可以直接ninja &lt;模块名&gt;这样能进行编译，比如只编译clang就是ninja clang</p><p>然后写个例子试一下clang的编译和中间语言IR</p><p>先写一个简单的hello world代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把这段代码用clang编译成IR中间语言</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -emit-llvm -S main.c -o main.ll</span><br></pre></td></tr></table></figure><p>编译出来的这个main.ll就是IR中间语言，是和cpu无关性的。下面是IR的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">; ModuleID &#x3D; &#39;main.c&#39;</span><br><span class="line">source_filename &#x3D; &quot;main.c&quot;</span><br><span class="line">target datalayout &#x3D; &quot;e-m:o-i64:64-f80:128-n8:16:32:64-S128&quot;</span><br><span class="line">target triple &#x3D; &quot;x86_64-apple-macosx10.15.0&quot;</span><br><span class="line"></span><br><span class="line">@.str &#x3D; private unnamed_addr constant [14 x i8] c&quot;hello world!!\00&quot;, align 1</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind optnone ssp uwtable</span><br><span class="line">define i32 @main(i32 %argc, i8** %argv) #0 &#123;</span><br><span class="line">entry:</span><br><span class="line">  %retval &#x3D; alloca i32, align 4</span><br><span class="line">  %argc.addr &#x3D; alloca i32, align 4</span><br><span class="line">  %argv.addr &#x3D; alloca i8**, align 8</span><br><span class="line">  store i32 0, i32* %retval, align 4</span><br><span class="line">  store i32 %argc, i32* %argc.addr, align 4</span><br><span class="line">  store i8** %argv, i8*** %argv.addr, align 8</span><br><span class="line">  %call &#x3D; call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str, i64 0, i64 0))</span><br><span class="line">  ret i32 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare i32 @printf(i8*, ...) #1</span><br><span class="line"></span><br><span class="line">attributes #0 &#x3D; &#123; noinline nounwind optnone ssp uwtable &quot;correctly-rounded-divide-sqrt-fp-math&quot;&#x3D;&quot;false&quot; &quot;disable-tail-calls&quot;&#x3D;&quot;false&quot; &quot;less-precise-fpmad&quot;&#x3D;&quot;false&quot; &quot;min-legal-vector-width&quot;&#x3D;&quot;0&quot; &quot;no-frame-pointer-elim&quot;&#x3D;&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-jump-tables&quot;&#x3D;&quot;false&quot; &quot;no-nans-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-trapping-math&quot;&#x3D;&quot;false&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;penryn&quot; &quot;target-features&quot;&#x3D;&quot;+cx16,+cx8,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&quot; &quot;unsafe-fp-math&quot;&#x3D;&quot;false&quot; &quot;use-soft-float&quot;&#x3D;&quot;false&quot; &#125;</span><br><span class="line">attributes #1 &#x3D; &#123; &quot;correctly-rounded-divide-sqrt-fp-math&quot;&#x3D;&quot;false&quot; &quot;disable-tail-calls&quot;&#x3D;&quot;false&quot; &quot;less-precise-fpmad&quot;&#x3D;&quot;false&quot; &quot;no-frame-pointer-elim&quot;&#x3D;&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-nans-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-trapping-math&quot;&#x3D;&quot;false&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;penryn&quot; &quot;target-features&quot;&#x3D;&quot;+cx16,+cx8,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&quot; &quot;unsafe-fp-math&quot;&#x3D;&quot;false&quot; &quot;use-soft-float&quot;&#x3D;&quot;false&quot; &#125;</span><br><span class="line"></span><br><span class="line">!llvm.module.flags &#x3D; !&#123;!0, !1, !2&#125;</span><br><span class="line">!llvm.ident &#x3D; !&#123;!3&#125;</span><br><span class="line"></span><br><span class="line">!0 &#x3D; !&#123;i32 2, !&quot;SDK Version&quot;, [3 x i32] [i32 10, i32 15, i32 6]&#125;</span><br><span class="line">!1 &#x3D; !&#123;i32 1, !&quot;wchar_size&quot;, i32 4&#125;</span><br><span class="line">!2 &#x3D; !&#123;i32 7, !&quot;PIC Level&quot;, i32 2&#125;</span><br><span class="line">!3 &#x3D; !&#123;!&quot;clang version 9.0.1 &quot;&#125;</span><br></pre></td></tr></table></figure><p>然后将这个IR文件转成bcode二进制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llvm-as main.ll -o main.bc</span><br></pre></td></tr></table></figure><p>同时也可以直接将c文件生成bc文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -emit-llvm -c main.c -o main.bc</span><br></pre></td></tr></table></figure><p>这个bc二进制文件是可以再重新转回IR文件的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llvm-dis main.dc -o main.ll</span><br></pre></td></tr></table></figure><p>也可以直接bc文件转换成当前cpu的汇编文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llc main.bc -o main.s</span><br></pre></td></tr></table></figure><p>这个时候的就是当前cpu的汇编文件了，下面列下main.s</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    .section    __TEXT,__text,regular,pure_instructions</span><br><span class="line">    .macosx_version_min 10, 15    sdk_version 10, 15, 6</span><br><span class="line">    .globl    _main                   ## -- Begin function main</span><br><span class="line">    .p2align    4, 0x90</span><br><span class="line">_main:                                  ## @main</span><br><span class="line">    .cfi_startproc</span><br><span class="line">## %bb.0:                               ## %entry</span><br><span class="line">    pushq    %rbp</span><br><span class="line">    .cfi_def_cfa_offset 16</span><br><span class="line">    .cfi_offset %rbp, -16</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register %rbp</span><br><span class="line">    subq    $16, %rsp</span><br><span class="line">    movl    $0, -8(%rbp)</span><br><span class="line">    movl    %edi, -4(%rbp)</span><br><span class="line">    movq    %rsi, -16(%rbp)</span><br><span class="line">    leaq    L_.str(%rip), %rdi</span><br><span class="line">    movb    $0, %al</span><br><span class="line">    callq    _printf</span><br><span class="line">    xorl    %eax, %eax</span><br><span class="line">    addq    $16, %rsp</span><br><span class="line">    popq    %rbp</span><br><span class="line">    retq</span><br><span class="line">    .cfi_endproc</span><br><span class="line">                                        ## -- End function</span><br><span class="line">    .section    __TEXT,__cstring,cstring_literals</span><br><span class="line">L_.str:                                 ## @.str</span><br><span class="line">    .asciz    &quot;hello world!!&quot;</span><br><span class="line">.subsections_via_symbols</span><br></pre></td></tr></table></figure><p>最后就可以直接生成可执行二进制了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang main.s -o main</span><br></pre></td></tr></table></figure><p>然后这个main就可以直接运行了，当文件还是IR文件或者是bc二进制时，也是可以使用lli来运行的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lli main.ll</span><br><span class="line">lli main.bc</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> llvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用frida hook解释器Interpreter</title>
      <link href="/2020/09/03/Hook-Interpreter/"/>
      <url>/2020/09/03/Hook-Interpreter/</url>
      
        <content type="html"><![CDATA[<p>学习的记录</p><p>准备hook一下Interpreter解释器的所有执行函数。先看下art/runtime/interpreter/interpreter.cc这个主要文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> InterpreterImplKind &#123;</span><br><span class="line">  kSwitchImplKind,        <span class="comment">// Switch-based interpreter implementation.</span></span><br><span class="line">  kMterpImplKind          <span class="comment">// Assembly interpreter</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> InterpreterImplKind kInterpreterImplKind = kMterpImplKind;</span><br></pre></td></tr></table></figure><p>然后在中间看到了这个枚举，就是说我当前这个8.1的有两种解释器，一个是switch的，另一个是Assembly汇编的，然后看到当前选择的是汇编解释器，继续看下面如果是汇编解释器就怎么处理，代码太长，只截取中间关键的部分了。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (kInterpreterImplKind == kMterpImplKind) &#123;</span><br><span class="line">      <span class="keyword">if</span> (transaction_active) &#123;</span><br><span class="line">        <span class="comment">// No Mterp variant - just use the switch interpreter.</span></span><br><span class="line">        <span class="keyword">return</span> ExecuteSwitchImpl&lt;<span class="literal">false</span>, <span class="literal">true</span>&gt;(self, code_item, shadow_frame, result_register,</span><br><span class="line">                                              <span class="literal">false</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (UNLIKELY(!Runtime::Current()-&gt;IsStarted())) &#123;</span><br><span class="line">        <span class="keyword">return</span> ExecuteSwitchImpl&lt;<span class="literal">false</span>, <span class="literal">false</span>&gt;(self, code_item, shadow_frame, result_register,</span><br><span class="line">                                               <span class="literal">false</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">          <span class="comment">// Mterp does not support all instrumentation/debugging.</span></span><br><span class="line">          <span class="keyword">if</span> (MterpShouldSwitchInterpreters() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ExecuteSwitchImpl&lt;<span class="literal">false</span>, <span class="literal">false</span>&gt;(self, code_item, shadow_frame, result_register,</span><br><span class="line">                                                   <span class="literal">false</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">bool</span> returned = ExecuteMterpImpl(self, code_item, &amp;shadow_frame, &amp;result_register);</span><br><span class="line">          <span class="keyword">if</span> (returned) &#123;</span><br><span class="line">            <span class="keyword">return</span> result_register;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Mterp didn&#x27;t like that instruction.  Single-step it with the reference interpreter.</span></span><br><span class="line">            result_register = ExecuteSwitchImpl&lt;<span class="literal">false</span>, <span class="literal">false</span>&gt;(self, code_item, shadow_frame,</span><br><span class="line">                                                              result_register, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (shadow_frame.GetDexPC() == DexFile::kDexNoIndex) &#123;</span><br><span class="line">              <span class="comment">// Single-stepped a return or an exception not handled locally.  Return to caller.</span></span><br><span class="line">              <span class="keyword">return</span> result_register;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，有些情况会执行ExecuteSwitchImpl来处理，一般都是使用ExecuteMterpImpl进行处理。然后我们看看这两个函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JValue <span class="title">ExecuteSwitchImpl</span><span class="params">(Thread* self, <span class="keyword">const</span> DexFile::CodeItem* code_item,</span></span></span><br><span class="line"><span class="function"><span class="params">                         ShadowFrame&amp; shadow_frame, JValue result_register,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">bool</span> interpret_one_instruction)</span></span></span><br></pre></td></tr></table></figure><p>这里看到第三个参数是ShadowFrame，这个对象里面有artmethod，我们可以从这里取到artmethod后再用老办法获取函数名称。先看看ShadowFrame的字段部分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ShadowFrame* link_;</span><br><span class="line">ArtMethod* method_;</span><br><span class="line">JValue* result_register_;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint16_t</span>* dex_pc_ptr_;</span><br><span class="line"><span class="keyword">const</span> DexFile::CodeItem* code_item_;</span><br><span class="line">LockCountData lock_count_data_;  <span class="comment">// This may contain GC roots when lock counting is active.</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> number_of_vregs_;</span><br><span class="line"><span class="keyword">uint32_t</span> dex_pc_;</span><br><span class="line"><span class="keyword">int16_t</span> cached_hotness_countdown_;</span><br><span class="line"><span class="keyword">int16_t</span> hotness_countdown_;</span><br></pre></td></tr></table></figure><p>ShadowFrame这个类没有虚函数，第二个字段就是artmethod。然后我们就知道了这个对象偏移一个指针大小就可以去到想要的artmethod了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> artmethod=ptr(shadow).add(Process.pointerSize).readPointer();</span><br></pre></td></tr></table></figure><p>然后再看看另一个函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">bool</span> <span class="title">ExecuteMterpImpl</span><span class="params">(Thread* self,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">const</span> DexFile::CodeItem* code_item,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 ShadowFrame* shadow_frame,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 JValue* result_register)</span> <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span></span>;</span><br></pre></td></tr></table></figure><p>也是一样的，都是取第三个参数。不过这里有一点不同的区别是。这个函数是汇编实现的。我们再看下汇编的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">ExecuteMterpImpl:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    SAVE_TWO_REGS_INCREASE_FRAME xPROFILE, x27, 80</span><br><span class="line">    SAVE_TWO_REGS                xIBASE, xREFS, 16</span><br><span class="line">    SAVE_TWO_REGS                xSELF, xINST, 32</span><br><span class="line">    SAVE_TWO_REGS                xPC, xFP, 48</span><br><span class="line">    SAVE_TWO_REGS                fp, lr, 64</span><br><span class="line">    add     fp, sp, #64</span><br><span class="line"></span><br><span class="line">    &#x2F;* Remember the return register *&#x2F;</span><br><span class="line">    str     x3, [x2, #SHADOWFRAME_RESULT_REGISTER_OFFSET]</span><br><span class="line"></span><br><span class="line">    &#x2F;* Remember the code_item *&#x2F;</span><br><span class="line">    str     x1, [x2, #SHADOWFRAME_CODE_ITEM_OFFSET]</span><br><span class="line"></span><br><span class="line">    &#x2F;* set up &quot;named&quot; registers *&#x2F;</span><br><span class="line">    mov     xSELF, x0</span><br><span class="line">    ldr     w0, [x2, #SHADOWFRAME_NUMBER_OF_VREGS_OFFSET]</span><br><span class="line">    add     xFP, x2, #SHADOWFRAME_VREGS_OFFSET     &#x2F;&#x2F; point to vregs.</span><br><span class="line">    add     xREFS, xFP, w0, lsl #2                 &#x2F;&#x2F; point to reference array in shadow frame</span><br><span class="line">    ldr     w0, [x2, #SHADOWFRAME_DEX_PC_OFFSET]   &#x2F;&#x2F; Get starting dex_pc.</span><br><span class="line">    add     xPC, x1, #CODEITEM_INSNS_OFFSET        &#x2F;&#x2F; Point to base of insns[]</span><br><span class="line">    add     xPC, xPC, w0, lsl #1                   &#x2F;&#x2F; Create direct pointer to 1st dex opcode</span><br><span class="line">    EXPORT_PC</span><br><span class="line"></span><br><span class="line">    &#x2F;* Starting ibase *&#x2F;</span><br><span class="line">    ldr     xIBASE, [xSELF, #THREAD_CURRENT_IBASE_OFFSET]</span><br><span class="line"></span><br><span class="line">    &#x2F;* Set up for backwards branches &amp; osr profiling *&#x2F;</span><br><span class="line">    ldr     x0, [xFP, #OFF_FP_METHOD]</span><br><span class="line">    add     x1, xFP, #OFF_FP_SHADOWFRAME</span><br><span class="line">    bl      MterpSetUpHotnessCountdown</span><br><span class="line">    mov     wPROFILE, w0                &#x2F;&#x2F; Starting hotness countdown to xPROFILE</span><br><span class="line"></span><br><span class="line">    &#x2F;* start executing the instruction at rPC *&#x2F;</span><br><span class="line">    FETCH_INST                          &#x2F;&#x2F; load wINST from rPC</span><br><span class="line">    GET_INST_OPCODE ip                  &#x2F;&#x2F; extract opcode from wINST</span><br><span class="line">    GOTO_OPCODE ip                      &#x2F;&#x2F; jump to next instruction</span><br><span class="line">    &#x2F;* NOTE: no fallthrough *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    .global artMterpAsmInstructionStart</span><br><span class="line">    .type   artMterpAsmInstructionStart, %function</span><br><span class="line">artMterpAsmInstructionStart &#x3D; .L_op_nop</span><br><span class="line">    .text</span><br></pre></td></tr></table></figure><p>这样就导致了我们在ida中看到的结果和hook的方式有一些区别。</p><p>这里列出我测试的一些区别。</p><p><img src="/2020/09/03/Hook-Interpreter/image-20200903225802440.png" alt="image-20200903225911990"></p><p><img src="/2020/09/03/Hook-Interpreter/image-20200903225956560.png" alt="image-20200903225956560"></p><p>可以看出来ExecuteSwitchImpl这个在export中，而ExecuteMterpImpl这个只在symbol中有。</p><p>继续看另外一个区别，下面是ida解析的ExecuteSwitchImpl</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __fastcall art::interpreter::ExecuteSwitchImpl&lt;<span class="literal">true</span>,<span class="literal">true</span>&gt;(<span class="keyword">int</span> a1, art::interpreter *<span class="keyword">this</span>, __int64 a3, __int64 a4, <span class="keyword">int</span> a5)</span><br></pre></td></tr></table></figure><p>另外就是ida解析的ExecuteMterpImpl</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">ExecuteMterpImpl</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, _DWORD *a3, <span class="keyword">int</span> a4)</span></span></span><br></pre></td></tr></table></figure><p>可以看出来，前者多了一个参数。看来汇编的函数里面少了最前面的this。那么当我们hook的时候就要注意了，ExecuteSwitchImpl获取shadow_frame需要取args[3]也就是第4个参数，而ExecuteMterpImpl则需要取args[2]也就是第三个参数</p><p>接着就是开始frida的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callPrettyMethod</span>(<span class="params">artmethod</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prettyMethodPtr=Module.getExportByName(<span class="string">&quot;libart.so&quot;</span>,<span class="string">&quot;_ZN3art9ArtMethod12PrettyMethodEb&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> result=Memory.alloc(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">var</span> prettyMethod=<span class="keyword">new</span> NativeFunction(prettyMethodPtr,<span class="string">&#x27;pointer&#x27;</span>,[<span class="string">&#x27;pointer&#x27;</span>,<span class="string">&#x27;pointer&#x27;</span>,<span class="string">&#x27;bool&#x27;</span>]);</span><br><span class="line">    prettyMethod(ptr(result),ptr(artmethod),<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> methodName=result.add(<span class="number">0x8</span>).readPointer().readCString()</span><br><span class="line">    <span class="keyword">return</span> methodName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_interpreter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">module</span>=Process.getModuleByName(<span class="string">&quot;libart.so&quot;</span>);</span><br><span class="line">    <span class="built_in">module</span>.enumerateSymbols().forEach(<span class="function"><span class="keyword">function</span>(<span class="params">symbol</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(symbol.name.indexOf(<span class="string">&quot;ExecuteSwitchImpl&quot;</span>)!=<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(symbol.name,symbol.address);</span><br><span class="line">            Interceptor.attach(symbol.address,&#123;</span><br><span class="line">                onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">var</span> shadow=args[<span class="number">3</span>];</span><br><span class="line">                    <span class="keyword">var</span> artmethod=ptr(shadow).add(Process.pointerSize).readPointer();</span><br><span class="line">                    <span class="keyword">var</span> methodName= callPrettyMethod(artmethod);</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&quot;ExecuteSwitchImpl methodName:&quot;</span>,methodName);</span><br><span class="line">                &#125;,</span><br><span class="line">                onLeave:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(symbol.name.indexOf(<span class="string">&quot;ExecuteMterpImpl&quot;</span>)!=<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(symbol.name,symbol.address);</span><br><span class="line">            Interceptor.attach(symbol.address,&#123;</span><br><span class="line">                onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">var</span> shadow=args[<span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">var</span> artmethod=ptr(shadow).add(Process.pointerSize).readPointer();</span><br><span class="line">                    <span class="keyword">var</span> methodName= callPrettyMethod(artmethod);</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&quot;ExecuteMterpImpl methodName:&quot;</span>,methodName);</span><br><span class="line">                &#125;,</span><br><span class="line">                onLeave:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    hook_interpreter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></table></figure><p>最后就开始测试</p><p><code>frida -U --no-pause -f com.example.classloadertest -l hookInterpreter.js</code></p><p>执行结果太长了。我就随便放一段了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExecuteMterpImpl methodName: void com.android.internal.os.LoggingPrintStream.println(java.lang.Object)</span><br><span class="line">ExecuteMterpImpl methodName: java.lang.String java.lang.String.toString()</span><br><span class="line">ExecuteMterpImpl methodName: void com.android.internal.os.LoggingPrintStream.flush(boolean)</span><br><span class="line">ExecuteMterpImpl methodName: int java.lang.StringBuilder.length()</span><br><span class="line">ExecuteMterpImpl methodName: int java.lang.AbstractStringBuilder.length()</span><br><span class="line">ExecuteMterpImpl methodName: int java.lang.StringBuilder.indexOf(java.lang.String, int)</span><br><span class="line">ExecuteMterpImpl methodName: java.lang.String java.lang.StringBuilder.substring(int)</span><br><span class="line">ExecuteMterpImpl methodName: java.lang.String java.lang.AbstractStringBuilder.substring(int)</span><br><span class="line">ExecuteMterpImpl methodName: java.lang.String java.lang.StringBuilder.substring(int, int)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础,frida </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用frida来hook artmethod的RegisterNative</title>
      <link href="/2020/09/02/Frida-Native-Register/"/>
      <url>/2020/09/02/Frida-Native-Register/</url>
      
        <content type="html"><![CDATA[<p>继续学习记录</p><p>之前找到了最终有调用到ArtMethod的RegisterNative来进行绑定。现在使用frida来hook打印一下注册的函数名和地址。先用ida找到我们之前找到的ArtMethod下的RegisterNative</p><p>找到了导出函数符号<code>_ZN3art9ArtMethod14RegisterNativeEPKvb</code></p><p>然后这里只有ArtMethod的指针，要获取完整的函数名。要使用ArtMethod的函数PrettyMethod。</p><p>导出函数符号为 <code>_ZN3art9ArtMethod12PrettyMethodEb</code></p><p>然后frida的代码就是先hook到RegisterNative，然后调用PrettyMethod来获取函数名</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_native_register</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">module</span>= Process.getModuleByName(<span class="string">&quot;libart.so&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> ArtMethodRegisterNative=<span class="built_in">module</span>.getExportByName(<span class="string">&quot;_ZN3art9ArtMethod14RegisterNativeEPKvb&quot;</span>);</span><br><span class="line">    Interceptor.attach(ArtMethodRegisterNative,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> curArtMethod=ptr(args[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">var</span> native_method=args[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">var</span> method_idx=ptr(curArtMethod).add(<span class="number">12</span>).readU32();</span><br><span class="line">            <span class="keyword">var</span> prettyMethodPtr=Module.getExportByName(<span class="string">&quot;libart.so&quot;</span>,<span class="string">&quot;_ZN3art9ArtMethod12PrettyMethodEb&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> result=Memory.alloc(<span class="number">0x100</span>);</span><br><span class="line">            <span class="keyword">var</span> prettyMethod=<span class="keyword">new</span> NativeFunction(prettyMethodPtr,<span class="string">&#x27;pointer&#x27;</span>,[<span class="string">&#x27;pointer&#x27;</span>,<span class="string">&#x27;pointer&#x27;</span>,<span class="string">&#x27;bool&#x27;</span>]);</span><br><span class="line">            prettyMethod(ptr(result),ptr(curArtMethod),<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">var</span> methodName=result.add(<span class="number">0x8</span>).readPointer().readCString()</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;,method_idx:&quot;</span>,method_idx,<span class="string">&quot;native_ptr:&quot;</span>,native_method,<span class="string">&quot;,methodName:&quot;</span>,methodName);</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    hook_native_register();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></table></figure><p>关键要注意的一个地方是prettyMethod的调用，它是一个特殊的调用，类和结构的返回值都会进行特殊的方式返回。这里返回的是一个string，所以使用了特殊方式进行返回结果。默认新加一个参数在最前面，然后将返回值填充到第一个参数里面。而不是直接返回。下面放一下frida文档的原文</p><p><code>As for structs or classes passed by value, instead of a string provide an array containing the struct’s field types following each other. You may nest these as deep as desired for representing structs inside structs. Note that the returned object is also a NativePointer, and can thus be passed to Interceptor#attach.This must match the struct/class exactly, so if you have a struct with three ints, you must pass [&#39;int&#39;, &#39;int&#39;, &#39;int&#39;]For a class that has virtual methods, the first parameter will be a pointer to the vtable.For C++ scenarios involving a return value that is larger than Process.pointerSize, a NativePointer to preallocated space must be passed in as the first parameter. (This scenario is common in WebKit, for example.)</code></p><p>这里原本执行是</p><p><code>var prettyMethod=new NativeFunction(prettyMethodPtr,&#39;pointer&#39;,[&#39;pointer&#39;,&#39;bool&#39;]);</code></p><p>特殊处理后变成了</p><p><code>var prettyMethod=new NativeFunction(prettyMethodPtr,&#39;pointer&#39;,[&#39;pointer&#39;,&#39;pointer&#39;,&#39;bool&#39;]);</code></p><p>最后frida启动测试</p><p><code>frida -U --no-pause -f com.example.classloadertest -l mydemo1.js</code></p><p>下面是运行结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">method_idx: <span class="number">131</span> native_ptr: <span class="number">0xcb4ddea5</span> ,methodName: java.lang.String com.stub.StubApp.interface14(int)</span><br><span class="line">method_idx: <span class="number">141</span> native_ptr: <span class="number">0xcb516d41</span> ,methodName: void com.stub.StubApp.mark()</span><br><span class="line">method_idx: <span class="number">142</span> native_ptr: <span class="number">0xcb516a75</span> ,methodName: void com.stub.StubApp.mark(android.location.Location)</span><br><span class="line">method_idx: <span class="number">140</span> native_ptr: <span class="number">0xcb516979</span> ,methodName: android.location.Location com.stub.StubApp.mark(android.location.LocationManager, java.lang.String)</span><br><span class="line">method_idx: <span class="number">136</span> native_ptr: <span class="number">0xcb4ddf05</span> ,methodName: void com.stub.StubApp.interface5(android.app.Application)</span><br><span class="line">method_idx: <span class="number">128</span> native_ptr: <span class="number">0xcb4eb3d5</span> ,methodName: void com.stub.StubApp.interface11(int)</span><br><span class="line">method_idx: <span class="number">129</span> native_ptr: <span class="number">0xcb4de28d</span> ,methodName: java.util.Enumeration com.stub.StubApp.interface12(dalvik.system.DexFile)</span><br><span class="line">method_idx: <span class="number">138</span> native_ptr: <span class="number">0xcb4e0b19</span> ,methodName: boolean com.stub.StubApp.interface7(android.app.Application, android.content.Context)</span><br><span class="line">method_idx: <span class="number">139</span> native_ptr: <span class="number">0xcb4de721</span> ,methodName: boolean com.stub.StubApp.interface8(android.app.Application, android.content.Context)</span><br><span class="line">method_idx: <span class="number">5228</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: java.lang.String com.jg.bh.BH.getCloundTag(android.content.Context)</span><br><span class="line">method_idx: <span class="number">5229</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: java.lang.String com.jg.bh.BH.getMsg(android.content.Context)</span><br><span class="line">method_idx: <span class="number">5230</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: void com.jg.bh.BH.install(android.content.Context)</span><br><span class="line">method_idx: <span class="number">5233</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: void com.jg.bh.BH.updateConfig(android.content.Context, java.lang.String)</span><br><span class="line">method_idx: <span class="number">5358</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: java.lang.String com.jg.bh.proxy.MyProxy.getEnable(android.content.Context)</span><br><span class="line">method_idx: <span class="number">5359</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: java.lang.String com.jg.bh.proxy.MyProxy.getMetaRow(android.content.Context)</span><br><span class="line">method_idx: <span class="number">5360</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: java.lang.Object com.jg.bh.proxy.MyProxy.getProxyObject(java.lang.Object, java.lang.reflect.InvocationHandler)</span><br><span class="line">method_idx: <span class="number">5361</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: java.lang.String com.jg.bh.proxy.MyProxy.getVersion(android.content.Context)</span><br><span class="line">method_idx: <span class="number">5362</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: void com.jg.bh.proxy.MyProxy.installAll(android.content.Context)</span><br><span class="line">method_idx: <span class="number">5363</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: java.lang.Object com.jg.bh.proxy.MyProxy.newProxyInstance(java.lang.ClassLoader, java.lang.Class[], java.lang.reflect.InvocationHandler)</span><br><span class="line">method_idx: <span class="number">5364</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: org.json.JSONObject com.jg.bh.proxy.MyProxy.parseConfig(java.lang.String)</span><br><span class="line">method_idx: <span class="number">5365</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: void com.jg.bh.proxy.MyProxy.putBHString(android.content.Context, java.lang.String)</span><br><span class="line">method_idx: <span class="number">5366</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: void com.jg.bh.proxy.MyProxy.putConfig(android.content.Context, java.lang.String)</span><br><span class="line">method_idx: <span class="number">5399</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: boolean com.jg.bh.util.MetaRow.access$<span class="number">000</span>(com.jg.bh.util.MetaRow)</span><br><span class="line">method_idx: <span class="number">5400</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: boolean com.jg.bh.util.MetaRow.access$<span class="number">002</span>(com.jg.bh.util.MetaRow, boolean)</span><br><span class="line">method_idx: <span class="number">5401</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: void com.jg.bh.util.MetaRow.access$<span class="number">100</span>(com.jg.bh.util.MetaRow, org.json.JSONObject)</span><br><span class="line">method_idx: <span class="number">5402</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: org.json.JSONObject com.jg.bh.util.MetaRow.getCellList()</span><br><span class="line">method_idx: <span class="number">5403</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: org.json.JSONObject com.jg.bh.util.MetaRow.getCelllData(android.telephony.CellInfo)</span><br><span class="line">method_idx: <span class="number">5405</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: org.json.JSONObject com.jg.bh.util.MetaRow.getWiFiInfo()</span><br><span class="line">method_idx: <span class="number">5406</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: org.json.JSONObject com.jg.bh.util.MetaRow.getWifiScanList()</span><br><span class="line">method_idx: <span class="number">5417</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: void com.jg.bh.util.MetaRow.syncJsonData(org.json.JSONObject)</span><br><span class="line">method_idx: <span class="number">5404</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: java.lang.String com.jg.bh.util.MetaRow.getNetConnType()</span><br><span class="line">method_idx: <span class="number">5407</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: boolean com.jg.bh.util.MetaRow.isGlobalVpn()</span><br><span class="line">method_idx: <span class="number">5408</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: void com.jg.bh.util.MetaRow.setCellInfoList(java.util.List)</span><br><span class="line">method_idx: <span class="number">5409</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: void com.jg.bh.util.MetaRow.setConnWifi(android.net.wifi.WifiInfo)</span><br><span class="line">method_idx: <span class="number">5410</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: void com.jg.bh.util.MetaRow.setData(java.lang.String)</span><br><span class="line">method_idx: <span class="number">5411</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: void com.jg.bh.util.MetaRow.setDhcpInfo(android.net.DhcpInfo)</span><br><span class="line">method_idx: <span class="number">5412</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: void com.jg.bh.util.MetaRow.setLocation(android.location.Location)</span><br><span class="line">method_idx: <span class="number">5413</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: void com.jg.bh.util.MetaRow.setWifiConf(java.lang.Object)</span><br><span class="line">method_idx: <span class="number">5414</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: void com.jg.bh.util.MetaRow.setWifiScanner(java.util.List)</span><br><span class="line">method_idx: <span class="number">5415</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: void com.jg.bh.util.MetaRow.setmNISubtype(int)</span><br><span class="line">method_idx: <span class="number">5416</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: void com.jg.bh.util.MetaRow.setmNIType(int)</span><br><span class="line">method_idx: <span class="number">5418</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: org.json.JSONObject com.jg.bh.util.MetaRow.toJSON()</span><br><span class="line">method_idx: <span class="number">5257</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: void com.jg.bh.hook.binder.BaseServiceHook.onInstall()</span><br><span class="line">method_idx: <span class="number">5301</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: void com.jg.bh.hook.binder.TelephonyHook.access$<span class="number">000</span>(com.jg.bh.hook.binder.TelephonyHook, java.lang.Object)</span><br><span class="line">method_idx: <span class="number">5302</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: void com.jg.bh.hook.binder.TelephonyHook.access$<span class="number">100</span>(com.jg.bh.hook.binder.TelephonyHook, java.lang.Object)</span><br><span class="line">method_idx: <span class="number">5303</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: void com.jg.bh.hook.binder.TelephonyHook.callGetAllCellInfo(java.lang.Object)</span><br><span class="line">method_idx: <span class="number">5304</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: void com.jg.bh.hook.binder.TelephonyHook.callGetCellLocation(java.lang.Object)</span><br><span class="line">method_idx: <span class="number">5305</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: com.jg.bh.hook.binder.BinderProxyHookHandler$IInterfaceHookHandler com.jg.bh.hook.binder.TelephonyHook.createBinderProxyHookHandler(android.os.IBinder, java.lang.Class)</span><br><span class="line">method_idx: <span class="number">5265</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: com.jg.bh.hook.binder.BinderProxyHookHandler$IInterfaceHookHandler com.jg.bh.hook.binder.BinderProxyHookHandler.getmInterfacehandler()</span><br><span class="line">method_idx: <span class="number">5266</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: java.lang.Object com.jg.bh.hook.binder.BinderProxyHookHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])</span><br><span class="line">method_idx: <span class="number">5267</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: void com.jg.bh.hook.binder.BinderProxyHookHandler.setmInterfacehandler(com.jg.bh.hook.binder.BinderProxyHookHandler$IInterfaceHookHandler)</span><br><span class="line">method_idx: <span class="number">5273</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: com.jg.bh.hook.binder.BinderProxyHookHandler$IInterfaceHookHandler com.jg.bh.hook.binder.IConnectivityManagerHook.createBinderProxyHookHandler(android.os.IBinder, java.lang.Class)</span><br><span class="line">method_idx: <span class="number">5280</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: com.jg.bh.hook.binder.BinderProxyHookHandler$IInterfaceHookHandler com.jg.bh.hook.binder.ILocationManagerHook.createBinderProxyHookHandler(android.os.IBinder, java.lang.Class)</span><br><span class="line">method_idx: <span class="number">5287</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: com.jg.bh.hook.binder.BinderProxyHookHandler$IInterfaceHookHandler com.jg.bh.hook.binder.IWifiManagerHook.createBinderProxyHookHandler(android.os.IBinder, java.lang.Class)</span><br><span class="line">method_idx: <span class="number">5294</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: com.jg.bh.hook.binder.BinderProxyHookHandler$IInterfaceHookHandler com.jg.bh.hook.binder.IWifiScannerHook.createBinderProxyHookHandler(android.os.IBinder, java.lang.Class)</span><br><span class="line">method_idx: <span class="number">11474</span> native_ptr: <span class="number">0xcb4defb9</span> ,methodName: java.lang.String[] dalvik.system.DexFile.getClassNameList(java.lang.Object)</span><br><span class="line">method_idx: <span class="number">5172</span> native_ptr: <span class="number">0xcb4dd59d</span> ,methodName: java.lang.String com.common.busi.CustomView.getAppkey()</span><br><span class="line">method_idx: <span class="number">5173</span> native_ptr: <span class="number">0xcb4dd78d</span> ,methodName: long com.common.busi.CustomView.getPT()</span><br><span class="line">method_idx: <span class="number">5451</span> native_ptr: <span class="number">0xcb4dd8a9</span> ,methodName: int com.jg.ce.Interface2.interface1(android.content.Context)</span><br><span class="line">method_idx: <span class="number">5452</span> native_ptr: <span class="number">0xcb4dd8b7</span> ,methodName: int com.jg.ce.Interface2.interface2(android.content.Context)</span><br><span class="line">method_idx: <span class="number">5453</span> native_ptr: <span class="number">0xcb4dd8bb</span> ,methodName: int com.jg.ce.Interface2.interface3(android.content.Context)</span><br><span class="line">method_idx: <span class="number">5454</span> native_ptr: <span class="number">0xcb4dd8c1</span> ,methodName: int com.jg.ce.Interface2.interface4(android.content.Context)</span><br><span class="line">method_idx: <span class="number">5455</span> native_ptr: <span class="number">0xcb4dd8c5</span> ,methodName: int com.jg.ce.Interface2.interface5(android.content.Context)</span><br><span class="line">method_idx: <span class="number">5643</span> native_ptr: <span class="number">0xcb4db755</span> ,methodName: void com.stub.stub07.Stub01.mark1(java.lang.String)</span><br><span class="line">method_idx: <span class="number">5231</span> native_ptr: <span class="number">0xcb4db8d9</span> ,methodName: void com.jg.bh.BH.mark2(java.lang.String, double, double)</span><br><span class="line">method_idx: <span class="number">5232</span> native_ptr: <span class="number">0xcb52d269</span> ,methodName: java.lang.String com.jg.bh.BH.mark3()</span><br><span class="line">method_idx: <span class="number">5196</span> native_ptr: <span class="number">0xcb4ec3f1</span> ,methodName: void com.example.classloadertest.MainActivity.onCreate(android.os.Bundle)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础,frida </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jni函数动态注册分析</title>
      <link href="/2020/08/30/JNI-DexClassLoader/"/>
      <url>/2020/08/30/JNI-DexClassLoader/</url>
      
        <content type="html"><![CDATA[<h3 id="动态注册jni函数时的流程"><a href="#动态注册jni函数时的流程" class="headerlink" title="动态注册jni函数时的流程"></a>动态注册jni函数时的流程</h3><p>学习过程的记录，以下代码参考自aosp8.1</p><p>jni函数绑定主要是有两种方式。静态注册和动态注册的jni函数</p><p>静态注册的jni函数有两次绑定，在类加载时会绑定一次，在jni函数第一次被调用时，art会对jni函数的地址进行查询并绑定</p><p>动态注册的jni函数也有两次绑定，在类加载时绑定一次，第二次由开发人员的代码主动绑定。</p><a id="more"></a><p>DexClassLoader是安卓的一种类加载器，然后用他的loadClass函数来进行类加载处理，而DexClassLoader中没有看到loadClass函数。通过在父类中寻找。最终发现loadClass在ClassLoad类中。继承关系如下</p><p>DexClassLoader–&gt;BaseDexClassLoader–&gt;ClassLoader</p><p>然后开始看看loadClass的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">     <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了两个参数的重载。继续看另外一个重载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line">                                <span class="comment">//初次加载时，c肯定是null，必然走的findClass</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>初次加载时，必然是取不到这个class的。所以初次执行时，必然走的findClass。所以接下来找这个findClass的代码，这个findClass的实现在BaseDexClassLoader中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        List&lt;Throwable&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;Throwable&gt;();</span><br><span class="line">        Class c = pathList.findClass(name, suppressedExceptions);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ClassNotFoundException cnfe = <span class="keyword">new</span> ClassNotFoundException(</span><br><span class="line">                    <span class="string">&quot;Didn&#x27;t find class \&quot;&quot;</span> + name + <span class="string">&quot;\&quot; on path: &quot;</span> + pathList);</span><br><span class="line">            <span class="keyword">for</span> (Throwable t : suppressedExceptions) &#123;</span><br><span class="line">                cnfe.addSuppressed(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> cnfe;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面我们可以看到关键的一句</p><p><code> Class c = pathList.findClass(name, suppressedExceptions);</code></p><p>Class c又是调用的pathList.findClass，继续找pathList的findClass，</p><p><code>DexPathList pathList</code></p><p>找到这个pathList的定义后，继续去DexPathList找findClass的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">        DexPathList.Element[] arr$ = <span class="keyword">this</span>.dexElements;</span><br><span class="line">        <span class="keyword">int</span> len$ = arr$.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i$ = <span class="number">0</span>; i$ &lt; len$; ++i$) &#123;</span><br><span class="line">            DexPathList.Element element = arr$[i$];</span><br><span class="line">            DexFile dex = element.dexFile;</span><br><span class="line">            <span class="keyword">if</span> (dex != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Class clazz = dex.loadClassBinaryName(name, <span class="keyword">this</span>.definingContext, suppressed);</span><br><span class="line">                <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.dexElementsSuppressedExceptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">            suppressed.addAll(Arrays.asList(<span class="keyword">this</span>.dexElementsSuppressedExceptions));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面是关键的class来源。</p><p><code>Class clazz = dex.loadClassBinaryName(name, this.definingContext, suppressed);</code></p><p>这里可以看到clazz的来源，然后继续找loadClassBinaryName，在DexFile中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">loadClassBinaryName</span><span class="params">(String name, ClassLoader loader, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, loader, <span class="keyword">this</span>.mCookie, suppressed);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后继续看defineClass的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Class <span class="title">defineClass</span><span class="params">(String name, ClassLoader loader, <span class="keyword">long</span> cookie, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">        Class result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = defineClassNative(name, loader, cookie);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoClassDefFoundError var7) &#123;</span><br><span class="line">            <span class="keyword">if</span> (suppressed != <span class="keyword">null</span>) &#123;</span><br><span class="line">                suppressed.add(var7);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var8) &#123;</span><br><span class="line">            <span class="keyword">if</span> (suppressed != <span class="keyword">null</span>) &#123;</span><br><span class="line">                suppressed.add(var8);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后继续看defineClassNative的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Class <span class="title">defineClassNative</span><span class="params">(String var0, ClassLoader var1, <span class="keyword">long</span> var2)</span> <span class="keyword">throws</span> ClassNotFoundException, NoClassDefFoundError</span>;</span><br></pre></td></tr></table></figure><p>这里这个defineClassNative是一个native函数了。那么实现的代码就要去找c++代码了。DexFile的对应c++代码在dalvik_system_DexFile.cc中。继续找c++的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jclass <span class="title">DexFile_defineClassNative</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        jclass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        jstring javaName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        jobject javaLoader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        jobject cookie,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        jobject dexFile)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> DexFile*&gt; dex_files;</span><br><span class="line">  <span class="keyword">const</span> OatFile* oat_file;</span><br><span class="line">  <span class="keyword">if</span> (!ConvertJavaArrayToDexFiles(env, cookie, <span class="comment">/*out*/</span> dex_files, <span class="comment">/*out*/</span> oat_file)) &#123;</span><br><span class="line">    VLOG(class_linker) &lt;&lt; <span class="string">&quot;Failed to find dex_file&quot;</span>;</span><br><span class="line">    DCHECK(env-&gt;ExceptionCheck());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">ScopedUtfChars <span class="title">class_name</span><span class="params">(env, javaName)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (class_name.c_str() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    VLOG(class_linker) &lt;&lt; <span class="string">&quot;Failed to find class_name&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">descriptor</span><span class="params">(DotToDescriptor(class_name.c_str()))</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">size_t</span> <span class="title">hash</span><span class="params">(ComputeModifiedUtf8Hash(descriptor.c_str()))</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; dex_file : dex_files) &#123;</span><br><span class="line">    <span class="keyword">const</span> DexFile::ClassDef* dex_class_def =</span><br><span class="line">        OatDexFile::FindClassDef(*dex_file, descriptor.c_str(), hash);</span><br><span class="line">    <span class="keyword">if</span> (dex_class_def != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="function">ScopedObjectAccess <span class="title">soa</span><span class="params">(env)</span></span>;</span><br><span class="line">      ClassLinker* class_linker = Runtime::Current()-&gt;GetClassLinker();</span><br><span class="line">      <span class="function">StackHandleScope&lt;1&gt; <span class="title">hs</span><span class="params">(soa.Self())</span></span>;</span><br><span class="line">      <span class="function">Handle&lt;mirror::ClassLoader&gt; <span class="title">class_loader</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          hs.NewHandle(soa.Decode&lt;mirror::ClassLoader&gt;(javaLoader)))</span></span>;</span><br><span class="line">      ObjPtr&lt;mirror::DexCache&gt; dex_cache =</span><br><span class="line">          class_linker-&gt;RegisterDexFile(*dex_file, class_loader.Get());</span><br><span class="line">      <span class="keyword">if</span> (dex_cache == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// OOME or InternalError (dexFile already registered with a different class loader).</span></span><br><span class="line">        soa.Self()-&gt;AssertPendingException();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ObjPtr&lt;mirror::Class&gt; result = class_linker-&gt;DefineClass(soa.Self(),</span><br><span class="line">                                                               descriptor.c_str(),</span><br><span class="line">                                                               hash,</span><br><span class="line">                                                               class_loader,</span><br><span class="line">                                                               *dex_file,</span><br><span class="line">                                                               *dex_class_def);</span><br><span class="line">      <span class="comment">// Add the used dex file. This only required for the DexFile.loadClass API since normal</span></span><br><span class="line">      <span class="comment">// class loaders already keep their dex files live.</span></span><br><span class="line">      class_linker-&gt;InsertDexFileInToClassLoader(soa.Decode&lt;mirror::Object&gt;(dexFile),</span><br><span class="line">                                                 class_loader.Get());</span><br><span class="line">      <span class="keyword">if</span> (result != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        VLOG(class_linker) &lt;&lt; <span class="string">&quot;DexFile_defineClassNative returning &quot;</span> &lt;&lt; result</span><br><span class="line">                           &lt;&lt; <span class="string">&quot; for &quot;</span> &lt;&lt; class_name.c_str();</span><br><span class="line">        <span class="keyword">return</span> soa.AddLocalReference&lt;jclass&gt;(result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  VLOG(class_linker) &lt;&lt; <span class="string">&quot;Failed to find dex_class_def &quot;</span> &lt;&lt; class_name.c_str();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里这段代码比较多。下面是关键代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjPtr&lt;mirror::Class&gt; result = class_linker-&gt;DefineClass(soa.Self(),                                   descriptor.c_str(),                                          hash,                                               class_loader,                                                *dex_file,                                             *dex_class_def);</span><br></pre></td></tr></table></figure><p>继续看DefineClass的实现代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">mirror::Class* <span class="title">ClassLinker::DefineClass</span><span class="params">(Thread* self,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> <span class="keyword">char</span>* descriptor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">size_t</span> hash,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Handle&lt;mirror::ClassLoader&gt; class_loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> DexFile&amp; dex_file,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> DexFile::ClassDef&amp; dex_class_def)</span> </span>&#123;</span><br><span class="line">  <span class="function">StackHandleScope&lt;3&gt; <span class="title">hs</span><span class="params">(self)</span></span>;</span><br><span class="line">  <span class="keyword">auto</span> klass = hs.NewHandle&lt;mirror::Class&gt;(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Load the class from the dex file.</span></span><br><span class="line">  <span class="keyword">if</span> (UNLIKELY(!init_done_)) &#123;</span><br><span class="line">    <span class="comment">// finish up init of hand crafted class_roots_</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(descriptor, <span class="string">&quot;Ljava/lang/Object;&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      klass.Assign(GetClassRoot(kJavaLangObject));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(descriptor, <span class="string">&quot;Ljava/lang/Class;&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      klass.Assign(GetClassRoot(kJavaLangClass));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(descriptor, <span class="string">&quot;Ljava/lang/String;&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      klass.Assign(GetClassRoot(kJavaLangString));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(descriptor, <span class="string">&quot;Ljava/lang/ref/Reference;&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      klass.Assign(GetClassRoot(kJavaLangRefReference));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(descriptor, <span class="string">&quot;Ljava/lang/DexCache;&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      klass.Assign(GetClassRoot(kJavaLangDexCache));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(descriptor, <span class="string">&quot;Ldalvik/system/ClassExt;&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      klass.Assign(GetClassRoot(kDalvikSystemClassExt));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (klass == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// Allocate a class with the status of not ready.</span></span><br><span class="line">    <span class="comment">// Interface object should get the right size here. Regular class will</span></span><br><span class="line">    <span class="comment">// figure out the right size later and be replaced with one of the right</span></span><br><span class="line">    <span class="comment">// size when the class becomes resolved.</span></span><br><span class="line">    klass.Assign(AllocClass(self, SizeOfClassWithoutEmbeddedTables(dex_file, dex_class_def)));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (UNLIKELY(klass == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    self-&gt;AssertPendingOOMException();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Get the real dex file. This will return the input if there aren&#x27;t any callbacks or they do</span></span><br><span class="line">  <span class="comment">// nothing.</span></span><br><span class="line">  DexFile <span class="keyword">const</span>* new_dex_file = <span class="literal">nullptr</span>;</span><br><span class="line">  DexFile::ClassDef <span class="keyword">const</span>* new_class_def = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// TODO We should ideally figure out some way to move this after we get a lock on the klass so it</span></span><br><span class="line">  <span class="comment">// will only be called once.</span></span><br><span class="line">  Runtime::Current()-&gt;GetRuntimeCallbacks()-&gt;ClassPreDefine(descriptor,</span><br><span class="line">                                                            klass,</span><br><span class="line">                                                            class_loader,</span><br><span class="line">                                                            dex_file,</span><br><span class="line">                                                            dex_class_def,</span><br><span class="line">                                                            &amp;new_dex_file,</span><br><span class="line">                                                            &amp;new_class_def);</span><br><span class="line">  <span class="comment">// Check to see if an exception happened during runtime callbacks. Return if so.</span></span><br><span class="line">  <span class="keyword">if</span> (self-&gt;IsExceptionPending()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ObjPtr&lt;mirror::DexCache&gt; dex_cache = RegisterDexFile(*new_dex_file, class_loader.Get());</span><br><span class="line">  <span class="keyword">if</span> (dex_cache == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    self-&gt;AssertPendingException();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  klass-&gt;SetDexCache(dex_cache);</span><br><span class="line">  SetupClass(*new_dex_file, *new_class_def, klass, class_loader.Get());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Mark the string class by setting its access flag.</span></span><br><span class="line">  <span class="keyword">if</span> (UNLIKELY(!init_done_)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(descriptor, <span class="string">&quot;Ljava/lang/String;&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      klass-&gt;SetStringClass();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">ObjectLock&lt;mirror::Class&gt; <span class="title">lock</span><span class="params">(self, klass)</span></span>;</span><br><span class="line">  klass-&gt;SetClinitThreadId(self-&gt;GetTid());</span><br><span class="line">  <span class="comment">// Make sure we have a valid empty iftable even if there are errors.</span></span><br><span class="line">  klass-&gt;SetIfTable(GetClassRoot(kJavaLangObject)-&gt;GetIfTable());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add the newly loaded class to the loaded classes table.</span></span><br><span class="line">  ObjPtr&lt;mirror::Class&gt; existing = InsertClass(descriptor, klass.Get(), hash);</span><br><span class="line">  <span class="keyword">if</span> (existing != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// We failed to insert because we raced with another thread. Calling EnsureResolved may cause</span></span><br><span class="line">    <span class="comment">// this thread to block.</span></span><br><span class="line">    <span class="keyword">return</span> EnsureResolved(self, descriptor, existing);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Load the fields and other things after we are inserted in the table. This is so that we don&#x27;t</span></span><br><span class="line">  <span class="comment">// end up allocating unfree-able linear alloc resources and then lose the race condition. The</span></span><br><span class="line">  <span class="comment">// other reason is that the field roots are only visited from the class table. So we need to be</span></span><br><span class="line">  <span class="comment">// inserted before we allocate / fill in these fields.</span></span><br><span class="line">  LoadClass(self, *new_dex_file, *new_class_def, klass);</span><br><span class="line">  <span class="keyword">if</span> (self-&gt;IsExceptionPending()) &#123;</span><br><span class="line">    VLOG(class_linker) &lt;&lt; self-&gt;GetException()-&gt;Dump();</span><br><span class="line">    <span class="comment">// An exception occured during load, set status to erroneous while holding klass&#x27; lock in case</span></span><br><span class="line">    <span class="comment">// notification is necessary.</span></span><br><span class="line">    <span class="keyword">if</span> (!klass-&gt;IsErroneous()) &#123;</span><br><span class="line">      mirror::Class::SetStatus(klass, mirror::Class::kStatusErrorUnresolved, self);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Finish loading (if necessary) by finding parents</span></span><br><span class="line">  CHECK(!klass-&gt;IsLoaded());</span><br><span class="line">  <span class="keyword">if</span> (!LoadSuperAndInterfaces(klass, *new_dex_file)) &#123;</span><br><span class="line">    <span class="comment">// Loading failed.</span></span><br><span class="line">    <span class="keyword">if</span> (!klass-&gt;IsErroneous()) &#123;</span><br><span class="line">      mirror::Class::SetStatus(klass, mirror::Class::kStatusErrorUnresolved, self);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  CHECK(klass-&gt;IsLoaded());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// At this point the class is loaded. Publish a ClassLoad event.</span></span><br><span class="line">  <span class="comment">// Note: this may be a temporary class. It is a listener&#x27;s responsibility to handle this.</span></span><br><span class="line">  Runtime::Current()-&gt;GetRuntimeCallbacks()-&gt;ClassLoad(klass);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Link the class (if necessary)</span></span><br><span class="line">  CHECK(!klass-&gt;IsResolved());</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Use fast jobjects?</span></span><br><span class="line">  <span class="keyword">auto</span> interfaces = hs.NewHandle&lt;mirror::ObjectArray&lt;mirror::Class&gt;&gt;(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  MutableHandle&lt;mirror::Class&gt; h_new_class = hs.NewHandle&lt;mirror::Class&gt;(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span> (!LinkClass(self, descriptor, klass, interfaces, &amp;h_new_class)) &#123;</span><br><span class="line">    <span class="comment">// Linking failed.</span></span><br><span class="line">    <span class="keyword">if</span> (!klass-&gt;IsErroneous()) &#123;</span><br><span class="line">      mirror::Class::SetStatus(klass, mirror::Class::kStatusErrorUnresolved, self);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  self-&gt;AssertNoPendingException();</span><br><span class="line">  CHECK(h_new_class != <span class="literal">nullptr</span>) &lt;&lt; descriptor;</span><br><span class="line">  CHECK(h_new_class-&gt;IsResolved() &amp;&amp; !h_new_class-&gt;IsErroneousResolved()) &lt;&lt; descriptor;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Instrumentation may have updated entrypoints for all methods of all</span></span><br><span class="line">  <span class="comment">// classes. However it could not update methods of this class while we</span></span><br><span class="line">  <span class="comment">// were loading it. Now the class is resolved, we can update entrypoints</span></span><br><span class="line">  <span class="comment">// as required by instrumentation.</span></span><br><span class="line">  <span class="keyword">if</span> (Runtime::Current()-&gt;GetInstrumentation()-&gt;AreExitStubsInstalled()) &#123;</span><br><span class="line">    <span class="comment">// We must be in the kRunnable state to prevent instrumentation from</span></span><br><span class="line">    <span class="comment">// suspending all threads to update entrypoints while we are doing it</span></span><br><span class="line">    <span class="comment">// for this class.</span></span><br><span class="line">    DCHECK_EQ(self-&gt;GetState(), kRunnable);</span><br><span class="line">    Runtime::Current()-&gt;GetInstrumentation()-&gt;InstallStubsForClass(h_new_class.Get());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * We send CLASS_PREPARE events to the debugger from here.  The</span></span><br><span class="line"><span class="comment">   * definition of &quot;preparation&quot; is creating the static fields for a</span></span><br><span class="line"><span class="comment">   * class and initializing them to the standard default values, but not</span></span><br><span class="line"><span class="comment">   * executing any code (that comes later, during &quot;initialization&quot;).</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * We did the static preparation in LinkClass.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * The class has been prepared and resolved but possibly not yet verified</span></span><br><span class="line"><span class="comment">   * at this point.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Runtime::Current()-&gt;GetRuntimeCallbacks()-&gt;ClassPrepare(klass, h_new_class);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Notify native debugger of the new class and its layout.</span></span><br><span class="line">  jit::Jit::NewTypeLoadedIfUsingJit(h_new_class.Get());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> h_new_class.Get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段代码比较多，可以从descriptor的使用看出，这个参数是要加载的类描述 。但是关键点也很明显，那就是LoadClass。</p><p><code>LoadClass(self, *new_dex_file, *new_class_def, klass);</code></p><p>继续看LoadClass的实现代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClassLinker::LoadClass</span><span class="params">(Thread* self,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> DexFile&amp; dex_file,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> DexFile::ClassDef&amp; dex_class_def,</span></span></span><br><span class="line"><span class="function"><span class="params">                            Handle&lt;mirror::Class&gt; klass)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint8_t</span>* class_data = dex_file.GetClassData(dex_class_def);</span><br><span class="line">  <span class="keyword">if</span> (class_data == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">// no fields or methods - for example a marker interface</span></span><br><span class="line">  &#125;</span><br><span class="line">  LoadClassMembers(self, dex_file, class_data, klass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里就看到了我们关心的加载函数的处理了，LoadClassMembers也就是加载类函数的地方了。继续往下看实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClassLinker::LoadClassMembers</span><span class="params">(Thread* self,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">const</span> DexFile&amp; dex_file,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">const</span> <span class="keyword">uint8_t</span>* class_data,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   Handle&lt;mirror::Class&gt; klass)</span> </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Note: We cannot have thread suspension until the field and method arrays are setup or else</span></span><br><span class="line">    <span class="comment">// Class::VisitFieldRoots may miss some fields or methods.</span></span><br><span class="line">    <span class="function">ScopedAssertNoThreadSuspension <span class="title">nts</span><span class="params">(__FUNCTION__)</span></span>;</span><br><span class="line">    <span class="comment">// Load static fields.</span></span><br><span class="line">    <span class="comment">// We allow duplicate definitions of the same field in a class_data_item</span></span><br><span class="line">    <span class="comment">// but ignore the repeated indexes here, b/21868015.</span></span><br><span class="line">    LinearAlloc* <span class="keyword">const</span> allocator = GetAllocatorForClassLoader(klass-&gt;GetClassLoader());</span><br><span class="line">    <span class="function">ClassDataItemIterator <span class="title">it</span><span class="params">(dex_file, class_data)</span></span>;</span><br><span class="line">    LengthPrefixedArray&lt;ArtField&gt;* sfields = AllocArtFieldArray(self,</span><br><span class="line">                                                                allocator,</span><br><span class="line">                                                                it.NumStaticFields());</span><br><span class="line">    <span class="keyword">size_t</span> num_sfields = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> last_field_idx = <span class="number">0u</span>;</span><br><span class="line">    <span class="keyword">for</span> (; it.HasNextStaticField(); it.Next()) &#123;</span><br><span class="line">      <span class="keyword">uint32_t</span> field_idx = it.GetMemberIndex();</span><br><span class="line">      DCHECK_GE(field_idx, last_field_idx);  <span class="comment">// Ordering enforced by DexFileVerifier.</span></span><br><span class="line">      <span class="keyword">if</span> (num_sfields == <span class="number">0</span> || LIKELY(field_idx &gt; last_field_idx)) &#123;</span><br><span class="line">        DCHECK_LT(num_sfields, it.NumStaticFields());</span><br><span class="line">        LoadField(it, klass, &amp;sfields-&gt;At(num_sfields));</span><br><span class="line">        ++num_sfields;</span><br><span class="line">        last_field_idx = field_idx;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load instance fields.</span></span><br><span class="line">    LengthPrefixedArray&lt;ArtField&gt;* ifields = AllocArtFieldArray(self,</span><br><span class="line">                                                                allocator,</span><br><span class="line">                                                                it.NumInstanceFields());</span><br><span class="line">    <span class="keyword">size_t</span> num_ifields = <span class="number">0u</span>;</span><br><span class="line">    last_field_idx = <span class="number">0u</span>;</span><br><span class="line">    <span class="keyword">for</span> (; it.HasNextInstanceField(); it.Next()) &#123;</span><br><span class="line">      <span class="keyword">uint32_t</span> field_idx = it.GetMemberIndex();</span><br><span class="line">      DCHECK_GE(field_idx, last_field_idx);  <span class="comment">// Ordering enforced by DexFileVerifier.</span></span><br><span class="line">      <span class="keyword">if</span> (num_ifields == <span class="number">0</span> || LIKELY(field_idx &gt; last_field_idx)) &#123;</span><br><span class="line">        DCHECK_LT(num_ifields, it.NumInstanceFields());</span><br><span class="line">        LoadField(it, klass, &amp;ifields-&gt;At(num_ifields));</span><br><span class="line">        ++num_ifields;</span><br><span class="line">        last_field_idx = field_idx;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (UNLIKELY(num_sfields != it.NumStaticFields()) ||</span><br><span class="line">        UNLIKELY(num_ifields != it.NumInstanceFields())) &#123;</span><br><span class="line">      LOG(WARNING) &lt;&lt; <span class="string">&quot;Duplicate fields in class &quot;</span> &lt;&lt; klass-&gt;PrettyDescriptor()</span><br><span class="line">          &lt;&lt; <span class="string">&quot; (unique static fields: &quot;</span> &lt;&lt; num_sfields &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; it.NumStaticFields()</span><br><span class="line">          &lt;&lt; <span class="string">&quot;, unique instance fields: &quot;</span> &lt;&lt; num_ifields &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; it.NumInstanceFields() &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">      <span class="comment">// <span class="doctag">NOTE:</span> Not shrinking the over-allocated sfields/ifields, just setting size.</span></span><br><span class="line">      <span class="keyword">if</span> (sfields != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        sfields-&gt;SetSize(num_sfields);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (ifields != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ifields-&gt;SetSize(num_ifields);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Set the field arrays.</span></span><br><span class="line">    klass-&gt;SetSFieldsPtr(sfields);</span><br><span class="line">    DCHECK_EQ(klass-&gt;NumStaticFields(), num_sfields);</span><br><span class="line">    klass-&gt;SetIFieldsPtr(ifields);</span><br><span class="line">    DCHECK_EQ(klass-&gt;NumInstanceFields(), num_ifields);</span><br><span class="line">    <span class="comment">// Load methods.</span></span><br><span class="line">    <span class="keyword">bool</span> has_oat_class = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> OatFile::OatClass oat_class =</span><br><span class="line">        (Runtime::Current()-&gt;IsStarted() &amp;&amp; !Runtime::Current()-&gt;IsAotCompiler())</span><br><span class="line">            ? OatFile::FindOatClass(dex_file, klass-&gt;GetDexClassDefIndex(), &amp;has_oat_class)</span><br><span class="line">            : OatFile::OatClass::Invalid();</span><br><span class="line">    <span class="keyword">const</span> OatFile::OatClass* oat_class_ptr = has_oat_class ? &amp;oat_class : <span class="literal">nullptr</span>;</span><br><span class="line">    klass-&gt;SetMethodsPtr(</span><br><span class="line">        AllocArtMethodArray(self, allocator, it.NumDirectMethods() + it.NumVirtualMethods()),</span><br><span class="line">        it.NumDirectMethods(),</span><br><span class="line">        it.NumVirtualMethods());</span><br><span class="line">    <span class="keyword">size_t</span> class_def_method_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> last_dex_method_index = DexFile::kDexNoIndex;</span><br><span class="line">    <span class="keyword">size_t</span> last_class_def_method_index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// TODO These should really use the iterators.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; it.HasNextDirectMethod(); i++, it.Next()) &#123;</span><br><span class="line">      ArtMethod* method = klass-&gt;GetDirectMethodUnchecked(i, image_pointer_size_);</span><br><span class="line">      LoadMethod(dex_file, it, klass, method);</span><br><span class="line">      LinkCode(<span class="keyword">this</span>, method, oat_class_ptr, class_def_method_index);</span><br><span class="line">      <span class="keyword">uint32_t</span> it_method_index = it.GetMemberIndex();</span><br><span class="line">      <span class="keyword">if</span> (last_dex_method_index == it_method_index) &#123;</span><br><span class="line">        <span class="comment">// duplicate case</span></span><br><span class="line">        method-&gt;SetMethodIndex(last_class_def_method_index);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        method-&gt;SetMethodIndex(class_def_method_index);</span><br><span class="line">        last_dex_method_index = it_method_index;</span><br><span class="line">        last_class_def_method_index = class_def_method_index;</span><br><span class="line">      &#125;</span><br><span class="line">      class_def_method_index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; it.HasNextVirtualMethod(); i++, it.Next()) &#123;</span><br><span class="line">      ArtMethod* method = klass-&gt;GetVirtualMethodUnchecked(i, image_pointer_size_);</span><br><span class="line">      LoadMethod(dex_file, it, klass, method);</span><br><span class="line">      DCHECK_EQ(class_def_method_index, it.NumDirectMethods() + i);</span><br><span class="line">      LinkCode(<span class="keyword">this</span>, method, oat_class_ptr, class_def_method_index);</span><br><span class="line">      class_def_method_index++;</span><br><span class="line">    &#125;</span><br><span class="line">    DCHECK(!it.HasNext());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Ensure that the card is marked so that remembered sets pick up native roots.</span></span><br><span class="line">  Runtime::Current()-&gt;GetHeap()-&gt;WriteBarrierEveryFieldOf(klass.Get());</span><br><span class="line">  self-&gt;AllowThreadSuspension();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码比较多。但是整体内容前面部分是准备好jni函数绑定需要用到的field。后面是函数的加载。下面是函数加载部分的关键部分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; it.HasNextDirectMethod(); i++, it.Next()) &#123;</span><br><span class="line">      ArtMethod* method = klass-&gt;GetDirectMethodUnchecked(i, image_pointer_size_);</span><br><span class="line">      LoadMethod(dex_file, it, klass, method);</span><br><span class="line">      LinkCode(<span class="keyword">this</span>, method, oat_class_ptr, class_def_method_index);</span><br><span class="line">      <span class="keyword">uint32_t</span> it_method_index = it.GetMemberIndex();</span><br><span class="line">      <span class="keyword">if</span> (last_dex_method_index == it_method_index) &#123;</span><br><span class="line">        <span class="comment">// duplicate case</span></span><br><span class="line">        method-&gt;SetMethodIndex(last_class_def_method_index);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        method-&gt;SetMethodIndex(class_def_method_index);</span><br><span class="line">        last_dex_method_index = it_method_index;</span><br><span class="line">        last_class_def_method_index = class_def_method_index;</span><br><span class="line">      &#125;</span><br><span class="line">      class_def_method_index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; it.HasNextVirtualMethod(); i++, it.Next()) &#123;</span><br><span class="line">      ArtMethod* method = klass-&gt;GetVirtualMethodUnchecked(i, image_pointer_size_);</span><br><span class="line">      LoadMethod(dex_file, it, klass, method);</span><br><span class="line">      DCHECK_EQ(class_def_method_index, it.NumDirectMethods() + i);</span><br><span class="line">      LinkCode(<span class="keyword">this</span>, method, oat_class_ptr, class_def_method_index);</span><br><span class="line">      class_def_method_index++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以大概看出意思，前面是遍历所有普通函数进行加载，后面是遍历所有虚函数进行加载。而加载的方式主要是两段代码，下面列出关键代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LoadMethod(dex_file, it, klass, method);</span><br><span class="line">LinkCode(<span class="keyword">this</span>, method, oat_class_ptr, class_def_method_index);</span><br></pre></td></tr></table></figure><p>这两个函数我们都看一下具体实现里面做了些什么，先是LoadMethod的处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClassLinker::LoadMethod</span><span class="params">(<span class="keyword">const</span> DexFile&amp; dex_file,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> ClassDataItemIterator&amp; it,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Handle&lt;mirror::Class&gt; klass,</span></span></span><br><span class="line"><span class="function"><span class="params">                             ArtMethod* dst)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> dex_method_idx = it.GetMemberIndex();</span><br><span class="line">  <span class="keyword">const</span> DexFile::MethodId&amp; method_id = dex_file.GetMethodId(dex_method_idx);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* method_name = dex_file.StringDataByIdx(method_id.name_idx_);</span><br><span class="line"></span><br><span class="line">  <span class="function">ScopedAssertNoThreadSuspension <span class="title">ants</span><span class="params">(<span class="string">&quot;LoadMethod&quot;</span>)</span></span>;</span><br><span class="line">  dst-&gt;SetDexMethodIndex(dex_method_idx);</span><br><span class="line">  dst-&gt;SetDeclaringClass(klass.Get());</span><br><span class="line">  dst-&gt;SetCodeItemOffset(it.GetMethodCodeItemOffset());</span><br><span class="line"></span><br><span class="line">  dst-&gt;SetDexCacheResolvedMethods(klass-&gt;GetDexCache()-&gt;GetResolvedMethods(), image_pointer_size_);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint32_t</span> access_flags = it.GetMethodAccessFlags();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (UNLIKELY(<span class="built_in">strcmp</span>(<span class="string">&quot;finalize&quot;</span>, method_name) == <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">// Set finalizable flag on declaring class.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;V&quot;</span>, dex_file.GetShorty(method_id.proto_idx_)) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Void return type.</span></span><br><span class="line">      <span class="keyword">if</span> (klass-&gt;GetClassLoader() != <span class="literal">nullptr</span>) &#123;  <span class="comment">// All non-boot finalizer methods are flagged.</span></span><br><span class="line">        klass-&gt;SetFinalizable();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> temp;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* klass_descriptor = klass-&gt;GetDescriptor(&amp;temp);</span><br><span class="line">        <span class="comment">// The Enum class declares a &quot;final&quot; finalize() method to prevent subclasses from</span></span><br><span class="line">        <span class="comment">// introducing a finalizer. We don&#x27;t want to set the finalizable flag for Enum or its</span></span><br><span class="line">        <span class="comment">// subclasses, so we exclude it here.</span></span><br><span class="line">        <span class="comment">// We also want to avoid setting the flag on Object, where we know that finalize() is</span></span><br><span class="line">        <span class="comment">// empty.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(klass_descriptor, <span class="string">&quot;Ljava/lang/Object;&quot;</span>) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            <span class="built_in">strcmp</span>(klass_descriptor, <span class="string">&quot;Ljava/lang/Enum;&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">          klass-&gt;SetFinalizable();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method_name[<span class="number">0</span>] == <span class="string">&#x27;&lt;&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// Fix broken access flags for initializers. Bug 11157540.</span></span><br><span class="line">    <span class="keyword">bool</span> is_init = (<span class="built_in">strcmp</span>(<span class="string">&quot;&lt;init&gt;&quot;</span>, method_name) == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">bool</span> is_clinit = !is_init &amp;&amp; (<span class="built_in">strcmp</span>(<span class="string">&quot;&lt;clinit&gt;&quot;</span>, method_name) == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (UNLIKELY(!is_init &amp;&amp; !is_clinit)) &#123;</span><br><span class="line">      LOG(WARNING) &lt;&lt; <span class="string">&quot;Unexpected &#x27;&lt;&#x27; at start of method name &quot;</span> &lt;&lt; method_name;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (UNLIKELY((access_flags &amp; kAccConstructor) == <span class="number">0</span>)) &#123;</span><br><span class="line">        LOG(WARNING) &lt;&lt; method_name &lt;&lt; <span class="string">&quot; didn&#x27;t have expected constructor access flag in class &quot;</span></span><br><span class="line">            &lt;&lt; klass-&gt;PrettyDescriptor() &lt;&lt; <span class="string">&quot; in dex file &quot;</span> &lt;&lt; dex_file.GetLocation();</span><br><span class="line">        access_flags |= kAccConstructor;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dst-&gt;SetAccessFlags(access_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里大概就是构造函数的加载处理和普通函数的加载处理，然后我们再看看另一个函数LinkCode的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LinkCode</span><span class="params">(ClassLinker* class_linker,</span></span></span><br><span class="line"><span class="function"><span class="params">                     ArtMethod* method,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">const</span> OatFile::OatClass* oat_class,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">uint32_t</span> class_def_method_index)</span> <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">  Runtime* <span class="keyword">const</span> runtime = Runtime::Current();</span><br><span class="line">  <span class="keyword">if</span> (runtime-&gt;IsAotCompiler()) &#123;</span><br><span class="line">    <span class="comment">// The following code only applies to a non-compiler runtime.</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Method shouldn&#x27;t have already been linked.</span></span><br><span class="line">  DCHECK(method-&gt;GetEntryPointFromQuickCompiledCode() == <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span> (oat_class != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// Every kind of method should at least get an invoke stub from the oat_method.</span></span><br><span class="line">    <span class="comment">// non-abstract methods also get their code pointers.</span></span><br><span class="line">    <span class="keyword">const</span> OatFile::OatMethod oat_method = oat_class-&gt;GetOatMethod(class_def_method_index);</span><br><span class="line">    oat_method.LinkMethod(method);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Install entry point from interpreter.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">void</span>* quick_code = method-&gt;GetEntryPointFromQuickCompiledCode();</span><br><span class="line">  <span class="keyword">bool</span> enter_interpreter = class_linker-&gt;ShouldUseInterpreterEntrypoint(method, quick_code);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!method-&gt;IsInvokable()) &#123;</span><br><span class="line">    EnsureThrowsInvocationError(class_linker, method);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (method-&gt;IsStatic() &amp;&amp; !method-&gt;IsConstructor()) &#123;</span><br><span class="line">    <span class="comment">// For static methods excluding the class initializer, install the trampoline.</span></span><br><span class="line">    <span class="comment">// It will be replaced by the proper entry point by ClassLinker::FixupStaticTrampolines</span></span><br><span class="line">    <span class="comment">// after initializing class (see ClassLinker::InitializeClass method).</span></span><br><span class="line">    method-&gt;SetEntryPointFromQuickCompiledCode(GetQuickResolutionStub());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (quick_code == <span class="literal">nullptr</span> &amp;&amp; method-&gt;IsNative()) &#123;</span><br><span class="line">    method-&gt;SetEntryPointFromQuickCompiledCode(GetQuickGenericJniStub());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (enter_interpreter) &#123;</span><br><span class="line">    <span class="comment">// Set entry point from compiled code if there&#x27;s no code or in interpreter only mode.</span></span><br><span class="line">    method-&gt;SetEntryPointFromQuickCompiledCode(GetQuickToInterpreterBridge());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (method-&gt;IsNative()) &#123;</span><br><span class="line">    <span class="comment">// Unregistering restores the dlsym lookup stub.</span></span><br><span class="line">    method-&gt;UnregisterNative();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enter_interpreter || quick_code == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// We have a native method here without code. Then it should have either the generic JNI</span></span><br><span class="line">      <span class="comment">// trampoline as entrypoint (non-static), or the resolution trampoline (static).</span></span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> this doesn&#x27;t handle all the cases where trampolines may be installed.</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">void</span>* entry_point = method-&gt;GetEntryPointFromQuickCompiledCode();</span><br><span class="line">      DCHECK(class_linker-&gt;IsQuickGenericJniStub(entry_point) ||</span><br><span class="line">             class_linker-&gt;IsQuickResolutionStub(entry_point));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到重点，如果是native的处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (method-&gt;IsNative()) &#123;</span><br><span class="line">    <span class="comment">// Unregistering restores the dlsym lookup stub.</span></span><br><span class="line">    method-&gt;UnregisterNative();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是每个类加载时会触发的jni函数绑定，继续看UnregisterNative的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArtMethod::UnregisterNative</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  CHECK(IsNative() &amp;&amp; !IsFastNative()) &lt;&lt; PrettyMethod();</span><br><span class="line">  <span class="comment">// restore stub to lookup native pointer via dlsym</span></span><br><span class="line">  SetEntryPointFromJni(GetJniDlsymLookupStub());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们就知道了。jni函数的静态加载和动态加载的第一次加载绑定都会调用的位置就是SetEntryPointFromJni这里，初次绑定函数存放到了GetJniDlsymLookupStub()这个函数返回的指针。然后看看是存放到了什么地方</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">void</span>* <span class="title">GetJniDlsymLookupStub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">void</span>*&gt;(art_jni_dlsym_lookup_stub);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确定了这是一个指针。这个指针指向了一个函数。初次加载是把函数存放到了哪里，对应的函数是一个汇编函数。静态注册的第一次调用就会直接触发这个函数来获取加载函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    .extern artFindNativeMethod</span><br><span class="line">ENTRY art_jni_dlsym_lookup_stub</span><br><span class="line">    push   &#123;r0, r1, r2, r3, lr&#125;           @ spill regs</span><br><span class="line">    .cfi_adjust_cfa_offset 20</span><br><span class="line">    .cfi_rel_offset r0, 0</span><br><span class="line">    .cfi_rel_offset r1, 4</span><br><span class="line">    .cfi_rel_offset r2, 8</span><br><span class="line">    .cfi_rel_offset r3, 12</span><br><span class="line">    .cfi_rel_offset lr, 16</span><br><span class="line">    sub    sp, #12                        @ pad stack pointer to align frame</span><br><span class="line">    .cfi_adjust_cfa_offset 12</span><br><span class="line">    blx    artFindNativeMethod</span><br><span class="line">    mov    r12, r0                        @ save result in r12</span><br><span class="line">    add    sp, #12                        @ restore stack pointer</span><br><span class="line">    .cfi_adjust_cfa_offset -12</span><br><span class="line">    cbz    r0, 1f                         @ is method code null?</span><br><span class="line">    pop    &#123;r0, r1, r2, r3, lr&#125;           @ restore regs</span><br><span class="line">    .cfi_adjust_cfa_offset -20</span><br><span class="line">    .cfi_restore r0</span><br><span class="line">    .cfi_restore r1</span><br><span class="line">    .cfi_restore r2</span><br><span class="line">    .cfi_restore r3</span><br><span class="line">    .cfi_restore lr</span><br><span class="line">    bx     r12                            @ if non-null, tail call to method&#39;s code</span><br><span class="line">1:</span><br><span class="line">    pop    &#123;r0, r1, r2, r3, pc&#125;           @ restore regs and return to caller to handle exception</span><br><span class="line">END art_jni_dlsym_lookup_stub</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看到这里blx调用了artFindNativeMethod。继续再看看这个里面做了什么。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">const</span> <span class="keyword">void</span>* <span class="title">artFindNativeMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Thread* self = Thread::Current();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">const</span> <span class="keyword">void</span>* <span class="title">artFindNativeMethod</span><span class="params">(Thread* self)</span> </span>&#123;</span><br><span class="line">  DCHECK_EQ(self, Thread::Current());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  Locks::mutator_lock_-&gt;AssertNotHeld(self);  <span class="comment">// We come here as Native.</span></span><br><span class="line">  <span class="function">ScopedObjectAccess <span class="title">soa</span><span class="params">(self)</span></span>;</span><br><span class="line"></span><br><span class="line">  ArtMethod* method = self-&gt;GetCurrentMethod(<span class="literal">nullptr</span>);</span><br><span class="line">  DCHECK(method != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Lookup symbol address for method, on failure we&#x27;ll return null with an exception set,</span></span><br><span class="line">  <span class="comment">// otherwise we return the address of the method we found.</span></span><br><span class="line">  <span class="keyword">void</span>* native_code = soa.Vm()-&gt;FindCodeForNativeMethod(method);</span><br><span class="line">  <span class="keyword">if</span> (native_code == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    self-&gt;AssertPendingException();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Register so that future calls don&#x27;t come here</span></span><br><span class="line">  <span class="keyword">return</span> method-&gt;RegisterNative(native_code, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就看到了熟悉的RegisterNative了，到这里才进行了真正的函数的绑定。而前面FindCodeForNativeMethod这个函数用来获取绑定函数的符号地址。将查询到的地址交给RegisterNative进行绑定，继续看是如何查询函数符号地址的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">JavaVMExt::FindCodeForNativeMethod</span><span class="params">(ArtMethod* m)</span> </span>&#123;</span><br><span class="line">  CHECK(m-&gt;IsNative());</span><br><span class="line">  mirror::Class* c = m-&gt;GetDeclaringClass();</span><br><span class="line">  <span class="comment">// If this is a static method, it could be called before the class has been initialized.</span></span><br><span class="line">  CHECK(c-&gt;IsInitializing()) &lt;&lt; c-&gt;GetStatus() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m-&gt;PrettyMethod();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> detail;</span><br><span class="line">  Thread* <span class="keyword">const</span> self = Thread::Current();</span><br><span class="line">  <span class="keyword">void</span>* native_method = libraries_-&gt;FindNativeMethod(self, m, detail);</span><br><span class="line">  <span class="keyword">if</span> (native_method == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// Lookup JNI native methods from native TI Agent libraries. See runtime/ti/agent.h for more</span></span><br><span class="line">    <span class="comment">// information. Agent libraries are searched for native methods after all jni libraries.</span></span><br><span class="line">    native_method = FindCodeForNativeMethodInAgents(m);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Throwing can cause libraries_lock to be reacquired.</span></span><br><span class="line">  <span class="keyword">if</span> (native_method == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    LOG(ERROR) &lt;&lt; detail;</span><br><span class="line">    self-&gt;ThrowNewException(<span class="string">&quot;Ljava/lang/UnsatisfiedLinkError;&quot;</span>, detail.c_str());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> native_method;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里又看到了FindNativeMethod，然后继续深入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">FindNativeMethod</span><span class="params">(Thread* self, ArtMethod* m, <span class="built_in">std</span>::<span class="built_in">string</span>&amp; detail)</span></span></span><br><span class="line"><span class="function">      <span class="title">REQUIRES</span><span class="params">(!Locks::jni_libraries_lock_)</span></span></span><br><span class="line"><span class="function">      <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">jni_short_name</span><span class="params">(m-&gt;JniShortName())</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">jni_long_name</span><span class="params">(m-&gt;JniLongName())</span></span>;</span><br><span class="line">    mirror::ClassLoader* <span class="keyword">const</span> declaring_class_loader = m-&gt;GetDeclaringClass()-&gt;GetClassLoader();</span><br><span class="line">    <span class="function">ScopedObjectAccessUnchecked <span class="title">soa</span><span class="params">(Thread::Current())</span></span>;</span><br><span class="line">    <span class="keyword">void</span>* <span class="keyword">const</span> declaring_class_loader_allocator =</span><br><span class="line">        Runtime::Current()-&gt;GetClassLinker()-&gt;GetAllocatorForClassLoader(declaring_class_loader);</span><br><span class="line">    CHECK(declaring_class_loader_allocator != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Avoid calling GetShorty here to prevent dirtying dex pages?</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* shorty = m-&gt;GetShorty();</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// Go to suspended since dlsym may block for a long time if other threads are using dlopen.</span></span><br><span class="line">      <span class="function">ScopedThreadSuspension <span class="title">sts</span><span class="params">(self, kNative)</span></span>;</span><br><span class="line">      <span class="keyword">void</span>* native_code = FindNativeMethodInternal(self,</span><br><span class="line">                                                   declaring_class_loader_allocator,</span><br><span class="line">                                                   shorty,</span><br><span class="line">                                                   jni_short_name,</span><br><span class="line">                                                   jni_long_name);</span><br><span class="line">      <span class="keyword">if</span> (native_code != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> native_code;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    detail += <span class="string">&quot;No implementation found for &quot;</span>;</span><br><span class="line">    detail += m-&gt;PrettyMethod();</span><br><span class="line">    detail += <span class="string">&quot; (tried &quot;</span> + jni_short_name + <span class="string">&quot; and &quot;</span> + jni_long_name + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里继续找关键的函数FindNativeMethodInternal，然后再深入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">FindNativeMethodInternal</span><span class="params">(Thread* self,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">void</span>* declaring_class_loader_allocator,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">const</span> <span class="keyword">char</span>* shorty,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; jni_short_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; jni_long_name)</span></span></span><br><span class="line"><span class="function">      <span class="title">REQUIRES</span><span class="params">(!Locks::jni_libraries_lock_)</span></span></span><br><span class="line"><span class="function">      <span class="title">REQUIRES</span><span class="params">(!Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">    <span class="function">MutexLock <span class="title">mu</span><span class="params">(self, *Locks::jni_libraries_lock_)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; lib : libraries_) &#123;</span><br><span class="line">      SharedLibrary* <span class="keyword">const</span> library = lib.second;</span><br><span class="line">      <span class="comment">// Use the allocator address for class loader equality to avoid unnecessary weak root decode.</span></span><br><span class="line">      <span class="keyword">if</span> (library-&gt;GetClassLoaderAllocator() != declaring_class_loader_allocator) &#123;</span><br><span class="line">        <span class="comment">// We only search libraries loaded by the appropriate ClassLoader.</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Try the short name then the long name...</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span>* arg_shorty = library-&gt;NeedsNativeBridge() ? shorty : <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">void</span>* fn = library-&gt;FindSymbol(jni_short_name, arg_shorty);</span><br><span class="line">      <span class="keyword">if</span> (fn == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        fn = library-&gt;FindSymbol(jni_long_name, arg_shorty);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (fn != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        VLOG(jni) &lt;&lt; <span class="string">&quot;[Found native code for &quot;</span> &lt;&lt; jni_long_name</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; in \&quot;&quot;</span> &lt;&lt; library-&gt;GetPath() &lt;&lt; <span class="string">&quot;\&quot;]&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> fn;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>最后看到了，是通过FindSymbol这个函数来获取绑定函数的符号地址。</p><p>静态函数绑定流程到这里就完成了。</p><p>动态函数绑定是通过jni中的RegisterNatives来进行绑定.然后找到art/runtime/jni_internal.cc下的RegisterNatives</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">RegisterNatives</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">                              jclass java_class,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">const</span> JNINativeMethod* methods,</span></span></span><br><span class="line"><span class="function"><span class="params">                              jint method_count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (UNLIKELY(method_count &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">      JavaVmExtFromEnv(env)-&gt;JniAbortF(<span class="string">&quot;RegisterNatives&quot;</span>, <span class="string">&quot;negative method count: %d&quot;</span>,</span><br><span class="line">                                       method_count);</span><br><span class="line">      <span class="keyword">return</span> JNI_ERR;  <span class="comment">// Not reached except in unit tests.</span></span><br><span class="line">    &#125;</span><br><span class="line">    CHECK_NON_NULL_ARGUMENT_FN_NAME(<span class="string">&quot;RegisterNatives&quot;</span>, java_class, JNI_ERR);</span><br><span class="line">    <span class="function">ScopedObjectAccess <span class="title">soa</span><span class="params">(env)</span></span>;</span><br><span class="line">    <span class="function">StackHandleScope&lt;1&gt; <span class="title">hs</span><span class="params">(soa.Self())</span></span>;</span><br><span class="line">    Handle&lt;mirror::Class&gt; c = hs.NewHandle(soa.Decode&lt;mirror::Class&gt;(java_class));</span><br><span class="line">    <span class="keyword">if</span> (UNLIKELY(method_count == <span class="number">0</span>)) &#123;</span><br><span class="line">      LOG(WARNING) &lt;&lt; <span class="string">&quot;JNI RegisterNativeMethods: attempt to register 0 native methods for &quot;</span></span><br><span class="line">          &lt;&lt; c-&gt;PrettyDescriptor();</span><br><span class="line">      <span class="keyword">return</span> JNI_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    CHECK_NON_NULL_ARGUMENT_FN_NAME(<span class="string">&quot;RegisterNatives&quot;</span>, methods, JNI_ERR);</span><br><span class="line">    <span class="keyword">for</span> (jint i = <span class="number">0</span>; i &lt; method_count; ++i) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span>* name = methods[i].name;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span>* sig = methods[i].signature;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">void</span>* fnPtr = methods[i].fnPtr;</span><br><span class="line">      <span class="keyword">if</span> (UNLIKELY(name == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">        ReportInvalidJNINativeMethod(soa, c.Get(), <span class="string">&quot;method name&quot;</span>, i);</span><br><span class="line">        <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (UNLIKELY(sig == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">        ReportInvalidJNINativeMethod(soa, c.Get(), <span class="string">&quot;method signature&quot;</span>, i);</span><br><span class="line">        <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (UNLIKELY(fnPtr == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">        ReportInvalidJNINativeMethod(soa, c.Get(), <span class="string">&quot;native function&quot;</span>, i);</span><br><span class="line">        <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">bool</span> is_fast = <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">// Notes about fast JNI calls:</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// On a normal JNI call, the calling thread usually transitions</span></span><br><span class="line">      <span class="comment">// from the kRunnable state to the kNative state. But if the</span></span><br><span class="line">      <span class="comment">// called native function needs to access any Java object, it</span></span><br><span class="line">      <span class="comment">// will have to transition back to the kRunnable state.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// There is a cost to this double transition. For a JNI call</span></span><br><span class="line">      <span class="comment">// that should be quick, this cost may dominate the call cost.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// On a fast JNI call, the calling thread avoids this double</span></span><br><span class="line">      <span class="comment">// transition by not transitioning from kRunnable to kNative and</span></span><br><span class="line">      <span class="comment">// stays in the kRunnable state.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// There are risks to using a fast JNI call because it can delay</span></span><br><span class="line">      <span class="comment">// a response to a thread suspension request which is typically</span></span><br><span class="line">      <span class="comment">// used for a GC root scanning, etc. If a fast JNI call takes a</span></span><br><span class="line">      <span class="comment">// long time, it could cause longer thread suspension latency</span></span><br><span class="line">      <span class="comment">// and GC pauses.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// Thus, fast JNI should be used with care. It should be used</span></span><br><span class="line">      <span class="comment">// for a JNI call that takes a short amount of time (eg. no</span></span><br><span class="line">      <span class="comment">// long-running loop) and does not block (eg. no locks, I/O,</span></span><br><span class="line">      <span class="comment">// etc.)</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// A &#x27;!&#x27; prefix in the signature in the JNINativeMethod</span></span><br><span class="line">      <span class="comment">// indicates that it&#x27;s a fast JNI call and the runtime omits the</span></span><br><span class="line">      <span class="comment">// thread state transition from kRunnable to kNative at the</span></span><br><span class="line">      <span class="comment">// entry.</span></span><br><span class="line">      <span class="keyword">if</span> (*sig == <span class="string">&#x27;!&#x27;</span>) &#123;</span><br><span class="line">        is_fast = <span class="literal">true</span>;</span><br><span class="line">        ++sig;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Note: the right order is to try to find the method locally</span></span><br><span class="line">      <span class="comment">// first, either as a direct or a virtual method. Then move to</span></span><br><span class="line">      <span class="comment">// the parent.</span></span><br><span class="line">      ArtMethod* m = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">bool</span> warn_on_going_to_parent = down_cast&lt;JNIEnvExt*&gt;(env)-&gt;vm-&gt;IsCheckJniEnabled();</span><br><span class="line">      <span class="keyword">for</span> (ObjPtr&lt;mirror::Class&gt; current_class = c.Get();</span><br><span class="line">           current_class != <span class="literal">nullptr</span>;</span><br><span class="line">           current_class = current_class-&gt;GetSuperClass()) &#123;</span><br><span class="line">        <span class="comment">// Search first only comparing methods which are native.</span></span><br><span class="line">        m = FindMethod&lt;<span class="literal">true</span>&gt;(current_class.Ptr(), name, sig);</span><br><span class="line">        <span class="keyword">if</span> (m != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Search again comparing to all methods, to find non-native methods that match.</span></span><br><span class="line">        m = FindMethod&lt;<span class="literal">false</span>&gt;(current_class.Ptr(), name, sig);</span><br><span class="line">        <span class="keyword">if</span> (m != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (warn_on_going_to_parent) &#123;</span><br><span class="line">          LOG(WARNING) &lt;&lt; <span class="string">&quot;CheckJNI: method to register \&quot;&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;\&quot; not in the given class. &quot;</span></span><br><span class="line">                       &lt;&lt; <span class="string">&quot;This is slow, consider changing your RegisterNatives calls.&quot;</span>;</span><br><span class="line">          warn_on_going_to_parent = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (m == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        c-&gt;DumpClass(LOG_STREAM(ERROR), mirror::Class::kDumpClassFullDetail);</span><br><span class="line">        LOG(ERROR)</span><br><span class="line">            &lt;&lt; <span class="string">&quot;Failed to register native method &quot;</span></span><br><span class="line">            &lt;&lt; c-&gt;PrettyDescriptor() &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; name &lt;&lt; sig &lt;&lt; <span class="string">&quot; in &quot;</span></span><br><span class="line">            &lt;&lt; c-&gt;GetDexCache()-&gt;GetLocation()-&gt;ToModifiedUtf8();</span><br><span class="line">        ThrowNoSuchMethodError(soa, c.Get(), name, sig, <span class="string">&quot;static or non-static&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!m-&gt;IsNative()) &#123;</span><br><span class="line">        LOG(ERROR)</span><br><span class="line">            &lt;&lt; <span class="string">&quot;Failed to register non-native method &quot;</span></span><br><span class="line">            &lt;&lt; c-&gt;PrettyDescriptor() &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; name &lt;&lt; sig</span><br><span class="line">            &lt;&lt; <span class="string">&quot; as native&quot;</span>;</span><br><span class="line">        ThrowNoSuchMethodError(soa, c.Get(), name, sig, <span class="string">&quot;native&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      VLOG(jni) &lt;&lt; <span class="string">&quot;[Registering JNI native method &quot;</span> &lt;&lt; m-&gt;PrettyMethod() &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (UNLIKELY(is_fast)) &#123;</span><br><span class="line">        <span class="comment">// There are a few reasons to switch:</span></span><br><span class="line">        <span class="comment">// 1) We don&#x27;t support !bang JNI anymore, it will turn to a hard error later.</span></span><br><span class="line">        <span class="comment">// 2) @FastNative is actually faster. At least 1.5x faster than !bang JNI.</span></span><br><span class="line">        <span class="comment">//    and switching is super easy, remove ! in C code, add annotation in .java code.</span></span><br><span class="line">        <span class="comment">// 3) Good chance of hitting DCHECK failures in ScopedFastNativeObjectAccess</span></span><br><span class="line">        <span class="comment">//    since that checks for presence of @FastNative and not for ! in the descriptor.</span></span><br><span class="line">        LOG(WARNING) &lt;&lt; <span class="string">&quot;!bang JNI is deprecated. Switch to @FastNative for &quot;</span> &lt;&lt; m-&gt;PrettyMethod();</span><br><span class="line">        is_fast = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> make this a hard register error in the future.</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">void</span>* final_function_ptr = m-&gt;RegisterNative(fnPtr, is_fast);</span><br><span class="line">      UNUSED(final_function_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> JNI_OK;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里代码有点多。关键函数是最后的m-&gt;RegisterNative进行绑定，这个m对象是一个ArtMethod类，继续往里面看代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">void</span>* <span class="title">ArtMethod::RegisterNative</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* native_method, <span class="keyword">bool</span> is_fast)</span> </span>&#123;</span><br><span class="line">  CHECK(IsNative()) &lt;&lt; PrettyMethod();</span><br><span class="line">  CHECK(!IsFastNative()) &lt;&lt; PrettyMethod();</span><br><span class="line">  CHECK(native_method != <span class="literal">nullptr</span>) &lt;&lt; PrettyMethod();</span><br><span class="line">  <span class="keyword">if</span> (is_fast) &#123;</span><br><span class="line">    AddAccessFlags(kAccFastNative);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span>* new_native_method = <span class="literal">nullptr</span>;</span><br><span class="line">  Runtime::Current()-&gt;GetRuntimeCallbacks()-&gt;RegisterNativeMethod(<span class="keyword">this</span>,</span><br><span class="line">                                                                  native_method,</span><br><span class="line">                                                                  <span class="comment">/*out*/</span>&amp;new_native_method);</span><br><span class="line">  SetEntryPointFromJni(new_native_method);</span><br><span class="line">  <span class="keyword">return</span> new_native_method;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候发现，其实动态注册最后还是调用了SetEntryPointFromJni这个函数来进行绑定的。</p><p>这篇太长了。frida来hook的部分下一篇再记录吧。</p>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ios的砸壳和基础工具</title>
      <link href="/2020/08/26/IOSDump/"/>
      <url>/2020/08/26/IOSDump/</url>
      
        <content type="html"><![CDATA[<h2 id="一、砸壳"><a href="#一、砸壳" class="headerlink" title="一、砸壳"></a>一、砸壳</h2><h3 id="1、dumpdecrypted"><a href="#1、dumpdecrypted" class="headerlink" title="1、dumpdecrypted"></a>1、dumpdecrypted</h3><p>这种砸壳方式我在ios11的机子上测试没能解密成功，然后ios10一点问题都没有。可能是我太渣了吧。新手还请用ios10来尝试</p><p>首先从github上下载了编译出来dumpdecrypted，这个基本没啥问题的。</p><p>接着我们用到了两个路径，一个是沙盒到路径，还有一个是运行的路径</p><p>运行想要砸壳的应用，然后ps -e|grep Application找到要砸壳的应用，将路径保存出来</p><a id="more"></a><p>然后我们需要找到沙盒到路径，简单的办法就是使用cycript注入之后，再查询出来。</p><p>ios11的是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask][0]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file:&#x2F;&#x2F;&#x2F;var&#x2F;mobile&#x2F;Containers&#x2F;Data&#x2F;Application&#x2F;3B94D3F0-2CFB-4E0E-A0A2-03F960B2BA60&#x2F;Documents&#x2F;</span><br></pre></td></tr></table></figure><p>ios10的是NSHomeDirectory()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;var&#x2F;mobile&#x2F;Containers&#x2F;Data&#x2F;Application&#x2F;3B94D3F0-2CFB-4E0E-A0A2-03F960B2BA60</span><br></pre></td></tr></table></figure><p>接着把编译好的dumpdecrypted.dylib用scp上传到设备的/var/mobile/Containers/Data/Application/3B94D3F0-2CFB-4E0E-A0A2-03F960B2BA60/Documents/这个目录下</p><p>然后就可以砸壳了，cd到沙盒的目录下。执行下面的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib  /var/containers/Bundle/Application/4AE69936-E547-4B27-B76F-D5CEAB992553/Target.app/Target</span><br></pre></td></tr></table></figure><p>成功后会在当前目录生成出砸壳后的文件，scp到本地即可</p><h3 id="2、bfinject"><a href="#2、bfinject" class="headerlink" title="2、bfinject"></a>2、bfinject</h3><p>使用这个方式砸壳是因为刚开始我手上只有ios11的手机，然后萌新各种无法成功解密，并且获取沙盒路径也不好使，并且cycript也无法正常运行。然后我就找到了bfinject。我们可以用它来实现在ios11上运行cycript，也可以直接用它来进行砸壳。使用起来也很简单便捷</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash bfinject -P iRead.app -L decrypt</span><br><span class="line">bash bfinject -p 进程id -L decrypt</span><br></pre></td></tr></table></figure><p>两种方式都能砸壳，成功砸壳后会生成文件。我们要搜索下文件生成在哪里了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /var/mobile/Containers/Data/Application/ -name decrypted-app.ipa</span><br></pre></td></tr></table></figure><p>然后把这个砸好的拷贝到本地即可。</p><h3 id="3、frida-ios-dump"><a href="#3、frida-ios-dump" class="headerlink" title="3、frida-ios-dump"></a>3、frida-ios-dump</h3><p>这个使用我感觉没啥好介绍了的了。ios的frida用起来简单方便</p><p>添加源<a href="https://build.frida.re/">https://build.frida.re</a></p><p>然后搜索frida，安装。有点小坑的是，frida有点略大，然后国内的网经常下载失败，反正我安装尝试很多次，最后搭梯子才下好的。</p><p>然后github上的frida-ios-dump项目拉下来。有一点坑的是，砸壳的这个py脚本里面用了一些linux的命令。如果你是在window下面来进行砸壳的话，那么你就得尽兴一些特殊处理才能成功砸壳了。</p><p>方案一，将py里面用到的一些linux命令转换成对应的win的命令。</p><p>方案二，安装cywin，安装的时候，把py脚本中用到的一些linux命令添加一下。这样脚本就可以成功运行并砸壳了。</p><h2 id="二、各类工具"><a href="#二、各类工具" class="headerlink" title="二、各类工具"></a>二、各类工具</h2><h3 id="1、reveal"><a href="#1、reveal" class="headerlink" title="1、reveal"></a>1、reveal</h3><p>这个是界面ui分析工具，也是有些小坑在里面，我照着书里面的发现ios library根本点不了，没有找到这个文件，最后查了下，原来新版本的不一样。</p><p>Reveal⁩/⁨Contents⁩/⁨SharedSupport⁩/⁨iOS-Libraries⁩/RevealServer.framework 目录下的 RevealServer 复制到设备/Library/RHRevealLoader/libReveal.dylib</p><p>然后RevealServer.framework 拷贝到手机上的/System/Library/Frameworks 目录下</p><p>然后到设置里面找到reveal，点开后选择自己想要抓到应用，我们就可以抓到界面了。</p><h3 id="2、dpkg"><a href="#2、dpkg" class="headerlink" title="2、dpkg"></a>2、dpkg</h3><p>先安装Xcode，然后就是按照下面的步骤来。如果安装了不能用要记得sudo port selfupdate</p><p>xcode-select –install </p><p>sudo xcodebuild -license</p><p>安装 Macports ，网址：<a href="http://www.macports.org/install.php">http://www.macports.org/install.php</a></p><p>测试时否能用port可以先sudo port list一下</p><p>如果找不到port是需要设置环境变量</p><p>export PATH=/opt/local/bin:/opt/local/sbin:$PATH</p><p>如果不能用就先sudo port selfupdate</p><p>最后执行安装dpkg</p><p>sudo port -f install dpkg</p><h3 id="3、Charles"><a href="#3、Charles" class="headerlink" title="3、Charles"></a>3、Charles</h3><p>这个是用来抓http包的，用法很简单，这里我只说下ios设备抓https时，使用10及10以上会有个小坑</p><p>手机代理端口设置好。保证能抓包http包先，然后手机访问<a href="http://chls.pro/ssl%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%83%BD%E6%88%90%E5%8A%9F%E5%AE%89%E8%A3%85%EF%BC%8C%E8%AF%B4%E6%98%8E%E9%85%8D%E7%BD%AEok%E3%80%82%E4%B8%8D%E8%83%BD%E5%B0%B1%E6%98%AF%E6%89%8B%E6%9C%BA%E8%BF%98%E6%B2%A1%E8%AE%BE%E7%BD%AE%E5%A5%BD">http://chls.pro/ssl，如果能成功安装，说明配置ok。不能就是手机还没设置好</a></p><p>这里注意手机不能翻q，否则可能会导致不能正常的安装</p><p>然后进入设置，通用，关于本机，证书信任，开启刚刚的证书即可</p><h3 id="4、cycript"><a href="#4、cycript" class="headerlink" title="4、cycript"></a>4、cycript</h3><p>这个不得不说相当强大，应用运行时注入，写插件的时候可以提前用这个执行测试效果。很大的提高开发效率，简单的功能可以省掉写测试插件了。</p><p>但是也有坑，ios10运行相当顺利。但是ios11需要使用bfinject注入才能运行成功，并且control+d退出好像有点问题，我没有去查啥情况。</p><p>在ios11上运行 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash bfinject -P Reddit -L cycript</span><br></pre></td></tr></table></figure><p>据说最新的插件装上也可以直接运行cycript。不过我没有测试了。</p><p>ios10直接运行 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cycript -p demo2</span><br></pre></td></tr></table></figure><p>由于cycript上可以导入脚本的，如果先导入脚本，把常用的简单操作可以直接封装在脚本中，这样就可以节省我们很多时间</p><p>这里我用的github上的mjcripy。这样使用前先@import mjcript  然后查询一些信息的命令可以直接调用封装好的，主要还是因为我object-c太渣了。毕竟没做过ios开发。</p><h3 id="5、debugserver-lldb动态调试"><a href="#5、debugserver-lldb动态调试" class="headerlink" title="5、debugserver+lldb动态调试"></a>5、debugserver+lldb动态调试</h3><p>xcode如果有进行过调试的话，会在自动把debugserver复制到移动设备上，路径是/Developer/usr/bin下面会有个debugserver</p><p>复制到pc端，然后签名授权下，下面的内容保存为ent.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.springboard.debugapplications<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>get-task-allow<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>task_for_pid-allow<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>run-unsigned-code<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后签名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldid -S ent.xml debugserver</span><br></pre></td></tr></table></figure><p>然后把这个文件复制到手机的/usr/bin目录下</p><p>如果动态调试太卡，我们可以用iport转发下端口，然后使用localhost来进行连接</p><p>移动设备</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debugserver *:1234 -a “demo2”</span><br></pre></td></tr></table></figure><p>pc端执行lldb</p><p>然后链接到移动设备</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process connect connect://ip:1234</span><br></pre></td></tr></table></figure><p>查询模块在内存中的偏移量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image list -o -f</span><br></pre></td></tr></table></figure><p>Ida中的函数地址+偏移量=偏移后的基址</p><p>根据函数名设置断点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b function_name</span><br></pre></td></tr></table></figure><p>根据地址设置断点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b s -a 0x1111</span><br></pre></td></tr></table></figure><p>不得不说github就说我们这些渣渣新的好基友，lldb的命令对我来说，也是头昏脑花，于是搜一搜。</p><p>果然有仗义大佬，chisel这个项目就可以让我们舒舒服服的玩耍起来了。</p><h3 id="6、插件编写"><a href="#6、插件编写" class="headerlink" title="6、插件编写"></a>6、插件编写</h3><h4 id="theos"><a href="#theos" class="headerlink" title="theos"></a>theos</h4><p>theos的编译</p><p>nic.pl 创建项目</p><p>make 编译</p><p>make package 打包成deb</p><p>make install 安装到远程移动设备</p><p>安装到远程设备是用的环境变量的值</p><p>THEOS_DEVICE_IP和THEOS_DEVICE_PORT来设置远程设备的ip和端口</p><h4 id="MonkeyDev"><a href="#MonkeyDev" class="headerlink" title="MonkeyDev"></a>MonkeyDev</h4><p>我感觉就是xcode集成了theos，直接用theos每次我都是直接用编辑器来写，感觉是各种不方便，想着要是能用个ide该多爽。然后就发现是有的。</p><p>github上找到monkeydev，按照readme安装后，就可以看到Xcode创建的时候下面多了一些模版，里面的logos tweak就和theos的一样了。</p>]]></content>
      
      
      <categories>
          
          <category> ios逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 砸壳 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类对象的内存布局</title>
      <link href="/2020/08/12/ClassStructure/"/>
      <url>/2020/08/12/ClassStructure/</url>
      
        <content type="html"><![CDATA[<h2 id="类对象的存储结构"><a href="#类对象的存储结构" class="headerlink" title="类对象的存储结构"></a>类对象的存储结构</h2><p>首先看下一个空的对象占用的内存大小</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student stu;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stu size:%lu\n&quot;</span>,<span class="keyword">sizeof</span>(stu));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面是结果，说明一个对象的内存占用至少是1个字节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@&quot;stu size:1\r\n&quot;</span><br></pre></td></tr></table></figure><p>然后再看看增加成员变量的结构体的内存占用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> arg;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student stu;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stu size:%lu\n&quot;</span>,<span class="keyword">sizeof</span>(stu));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是int的大小</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@&quot;stu size:4\r\n&quot;</span><br></pre></td></tr></table></figure><p>如果再增加一个char变量,结果就有区别了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> arg;</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student stu;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stu size:%lu\n&quot;</span>,<span class="keyword">sizeof</span>(stu));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时的结果是8,因为底层为了高效的内存操作,有一个内存对齐的处理，如果不足4的倍数，则补全，比如此时4字节+1字节，则对齐到8字节。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@&quot;stu size:8\r\n&quot;</span><br></pre></td></tr></table></figure><p>类的成员除了成员变量，还有成员函数，那么成员函数占用多少内存呢</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> arg;</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;show()\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student stu;</span><br><span class="line">    stu.show();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stu size:%lu\n&quot;</span>,<span class="keyword">sizeof</span>(stu));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果依然为8，这里说明了成员函数并不是存储在类对象的内存结构中。而我们虽然在函数中能够访问到类对象的成员变量，实际上是因为当类对象调用成员函数时，默认将类对象作为第一个参数传递</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@&quot;show()\r\n&quot;</span><br><span class="line">@&quot;stu size:8\r\n&quot;</span><br></pre></td></tr></table></figure><p>然后用ida解析看看这个show经过编译器优化后的样子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">Student::show</span><span class="params">(Student *<span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;show()\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态成员函数和成员函数一样不占用空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> arg;</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;show()\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;show2()\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student stu;</span><br><span class="line">    stu.show();</span><br><span class="line">    stu.show2();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stu size:%lu\n&quot;</span>,<span class="keyword">sizeof</span>(stu));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果同样是8个字节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@&quot;show()\r\n&quot;</span><br><span class="line">@&quot;show2()\r\n&quot;</span><br><span class="line">@&quot;stu size:8\r\n&quot;</span><br></pre></td></tr></table></figure><p>以上是简单的类对象内存布局，还有一种情况比较特殊情况，就是虚函数，现在看一个简单的虚函数例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> arg;</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">virtual_show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;virtual_show()\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student stu;</span><br><span class="line">    stu.virtual_show();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stu size:%lu\n&quot;</span>,<span class="keyword">sizeof</span>(stu));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子的结果在32位中是12字节，在64位中是16字节。我现在是在64位中测试，所以结果是16字节，这里是怎么组合的呢，如果类中有虚函数，则会在内存的头部存放一个虚函数表的指针。而在32位中指针的大小是4字节，在64位中指针的大小是8字节，所以32位中4+1+4然后再内存对齐，结果就12字节，在64位中4+1+8再内存对齐，结果就是16字节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@&quot;virtual_show()\r\n&quot;</span><br><span class="line">@&quot;stu size:16\r\n&quot;</span><br></pre></td></tr></table></figure><p>那么如果有多个虚函数呢</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> arg;</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">virtual_show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;virtual_show()\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">virtual_show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;virtual_show2()\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student stu;</span><br><span class="line">    stu.virtual_show();</span><br><span class="line">    stu.virtual_show2();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stu size:%lu\n&quot;</span>,<span class="keyword">sizeof</span>(stu));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果依然是16字节，因为内存头部存储的是虚函数表的指针，而虚函数全部存储在虚函数表中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@&quot;virtual_show()\r\n&quot;</span><br><span class="line">@&quot;virtual_show2()\r\n&quot;</span><br><span class="line">@&quot;stu size:16\r\n&quot;</span><br></pre></td></tr></table></figure><p>刚刚说了，内存头部存储了虚函数指针，那么我们证实一下吧。看看这个对象16个字节的数据是装了些什么</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> arg;</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">virtual_show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;virtual_show()\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">virtual_show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;virtual_show2()\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student stu;</span><br><span class="line">    stu.arg=<span class="number">0x20</span>;</span><br><span class="line">    stu.sex=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    stu.virtual_show();</span><br><span class="line">    stu.virtual_show2();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stu size:%lu\n&quot;</span>,<span class="keyword">sizeof</span>(stu));</span><br><span class="line">    <span class="keyword">char</span>* stu_pointer=(<span class="keyword">char</span>*)&amp;stu;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">sizeof</span>(stu);i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%x &quot;</span>,stu_pointer[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据我们的分析，这个stu对象前面8个字节为虚函数表指针，然后4个字节为arg的数据，然后1个字节为sex的数据，最后3个字节为内存对齐的无用数据。那么这样理解下面的数据后就是20 10 0 0 1 0 0 0 是虚函数表指针，然后内存中存放的是小端序，转换一下就是0x1000102为虚函数表指针，20 0 0 0 为年龄，同样转换一下就是0x20。最后0x41是ascii码表中的’A’，而7f 0 0则是用来对齐的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@&quot;virtual_show()\r\n&quot;</span><br><span class="line">@&quot;virtual_show2()\r\n&quot;</span><br><span class="line">@&quot;stu size:16\r\n&quot;</span><br><span class="line">@&quot;20 10 0 0 1 0 0 0 20 0 0 0 41 7f 0 0 &quot;</span><br></pre></td></tr></table></figure><p>头部的指针既然说他是虚函数表指针。那么是不是可以访问到虚函数呢。下面调用试一下，通过这种对象指针的方式访问虚函数表的函数，是可以访问到类对象的私有函数的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> arg;</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">virtual_show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;virtual_show()\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">virtual_show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;virtual_show2()\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*FUNC)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student stu;</span><br><span class="line">    stu.arg=<span class="number">0x20</span>;</span><br><span class="line">    stu.sex=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stu size:%lu\n&quot;</span>,<span class="keyword">sizeof</span>(stu));</span><br><span class="line">    <span class="keyword">long</span> stu_pointer=*(<span class="keyword">long</span>*)&amp;stu;</span><br><span class="line">    FUNC show1=(FUNC)*(<span class="keyword">long</span>*)stu_pointer;</span><br><span class="line">    FUNC show2=(FUNC)*(<span class="keyword">long</span>*)(stu_pointer+<span class="keyword">sizeof</span>(<span class="keyword">int</span>*));</span><br><span class="line">    show1();</span><br><span class="line">    show2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后成功的调用了这两个函数，我们主要缕一下怎么找到的这两个函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@&quot;stu size:16\r\n&quot;</span><br><span class="line">@&quot;virtual_show()\r\n&quot;</span><br><span class="line">@&quot;virtual_show2()\r\n&quot;</span><br></pre></td></tr></table></figure><p>首先我们前面知道的，如果类中有虚函数，则会在类对象的内存最开始的位置存放一个虚函数表的指针。由此，我们首先拿到这个虚函数表的指针</p><p><code>long stu_pointer=*(long*)&amp;stu;</code></p><p>上面这句中&amp;stu这里会获取到stu的内存最开始的地址。也就是相当于。&amp;stu这里的指针指向了虚函数表指针。stu_pointer最后这里得到的也就是虚函数表指针</p><p><code>FUNC show1=(FUNC)*(long*)stu_pointer;</code></p><p>虚函数表指针直接再获取一下指针的数据。则取到了虚函数的指针。</p><p><code>FUNC show2=(FUNC)*(long*)(stu_pointer+sizeof(int*));</code></p><p>如果是想要获取下一个虚函数的指针，则偏移一个指针的位置。这里也可以直接先转long*了之后再+1。同样可以偏移到下一个虚函数指针位置</p><p><code>FUNC show2=(FUNC)*((long*)(stu_pointer)+1);</code></p><p>这样同样可以偏移到第二个虚函数指针的位置</p><p>如果类再加上继承，多继承，虚函数。内存分布则会更加复杂。下一篇我再详细测试下比较复杂关系的类的布局情况。</p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
