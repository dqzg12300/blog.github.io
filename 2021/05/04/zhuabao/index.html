<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>android抓包学习的整理和归纳 | king的博客</title><meta name="keywords" content="andorid,抓包"><meta name="author" content="king"><meta name="copyright" content="king"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="最近学习了各种抓包。为了防止忘记。学到的东西必须是整理一波啊。向大佬们看齐。如果有啥地方写的不对，希望大家多多指点 抓包主要是针对网络通讯数据，客户端向服务端上报的数据拦截下来。一般都是抓取http、https、tcp、udp。想要获取到数据包。有多种方式，下面简单列一下。 抓包方式1、hook app业务层，根据业务代码逻辑找到触发请求的函数，比如按钮触发，或者触发数据上报时的提示框等方式。分析">
<meta property="og:type" content="article">
<meta property="og:title" content="android抓包学习的整理和归纳">
<meta property="og:url" content="http://missking.cc/2021/05/04/zhuabao/index.html">
<meta property="og:site_name" content="king的博客">
<meta property="og:description" content="最近学习了各种抓包。为了防止忘记。学到的东西必须是整理一波啊。向大佬们看齐。如果有啥地方写的不对，希望大家多多指点 抓包主要是针对网络通讯数据，客户端向服务端上报的数据拦截下来。一般都是抓取http、https、tcp、udp。想要获取到数据包。有多种方式，下面简单列一下。 抓包方式1、hook app业务层，根据业务代码逻辑找到触发请求的函数，比如按钮触发，或者触发数据上报时的提示框等方式。分析">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2021-05-04T10:35:17.000Z">
<meta property="article:modified_time" content="2022-09-05T12:58:31.186Z">
<meta property="article:author" content="king">
<meta property="article:tag" content="andorid,抓包">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://missking.cc/2021/05/04/zhuabao/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'android抓包学习的整理和归纳',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-05 12:58:31'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/assets/blogImg/litten.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">king的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">android抓包学习的整理和归纳</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-04T10:35:17.000Z" title="发表于 2021-05-04 10:35:17">2021-05-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-05T12:58:31.186Z" title="更新于 2022-09-05 12:58:31">2022-09-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="android抓包学习的整理和归纳"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>最近学习了各种抓包。为了防止忘记。学到的东西必须是整理一波啊。向大佬们看齐。如果有啥地方写的不对，希望大家多多指点</p>
<p>抓包主要是针对网络通讯数据，客户端向服务端上报的数据拦截下来。一般都是抓取http、https、tcp、udp。想要获取到数据包。有多种方式，下面简单列一下。</p>
<h2 id="抓包方式"><a href="#抓包方式" class="headerlink" title="抓包方式"></a>抓包方式</h2><p>1、hook app业务层，根据业务代码逻辑找到触发请求的函数，比如按钮触发，或者触发数据上报时的提示框等方式。分析后找到发送数据的地方hook打印。</p>
<p><strong>优点：不受app的防抓包手段的影响，只要能hook到就能抓到包。</strong></p>
<p><strong>缺点：必须分析app找关键点，并且每个不同的请求都要找对应的触发函数，效率太慢。</strong></p>
<a id="more"></a>

<p>2、系统框架层的hook。直接hook系统源码发送和接受数据的地方。</p>
<p><strong>优点：可以直接省略掉业务层的分析。因为业务层不论逻辑怎么样最终都是调用系统的或者是第三方的库来进行数据传输。并且通用性更好。基本不用修改就可以抓很多app的包。并且可以在这里直接打印堆栈回溯请求触发的函数，提高分析的效率。同样不受防抓包手段影响。</strong></p>
<p><strong>缺点：hook出来的抓包数据不便于我们分析和筛选。只能在日志中查找对应的数据，分析数据包会比较繁琐。简单的需求或者是溯源时使用比较好</strong></p>
<p>3、中间人抓包，使用charles、burp等抓包工具进行拦截，中间人抓包在https请求时，抓包软件的证书在中间冒充服务端接收客服端的请求。然后又冒充客户端，发送请求给服务端。在中间拿到了客户端和服务端的数据。</p>
<p><strong>优点：专业的抓包分析软件，更加友好的分析页面。更加强大的功能，例如可以拦截请求进行改写替换，安装证书可以解析抓到的https数据包。支持vpn抓包</strong></p>
<p><strong>缺点：防抓包手段针对的主要目标，例如服务端验证客户端证书，不正确就拒绝访问，我们需要把客户端的证书给dump出来，然后让中间人抓包使用指定证书。或者是客户端验证服务端证书。我们需要找到并hook去掉验证的代码。无法抓tcp和udp的包</strong></p>
<p>4、网卡抓包、路由抓包。如wireshark，科来之类的。</p>
<p><strong>优点：这种方式不受任何限制，并且通杀，绝对能抓到。</strong></p>
<p><strong>缺点：对于加密的数据没有办法。需要自己进行解密，对于http和https包的展示不太友好</strong></p>
<p>其中比较通用一点的是系统层的hook。所以我这里主要针对这个记录下系统层hook的方式抓取http、https、tcp、udp的数据。</p>
<h2 id="系统层hook抓包"><a href="#系统层hook抓包" class="headerlink" title="系统层hook抓包"></a>系统层hook抓包</h2><h3 id="1、java层的抓包"><a href="#1、java层的抓包" class="headerlink" title="1、java层的抓包"></a>1、java层的抓包</h3><p>首先贴一个网上找的经典的网络模型图。可以看出来。http包是处于应用层的一种封装，所以我们抓tcp包的时候就可以抓到http包。</p>
<p><img src="/2021/05/04/zhuabao/zhuabao.png" alt="image-20210524221336406"></p>
<p>最常听到别人说的一句话就是想要逆向先会正向。我们得先知道如何在android中发包。下面我直接封装两种不同库的http请求方式和一个tcp的请求。然后再顺着代码去分析。看是否能直接在一个地方hook。将这三种情况的包都能抓到。</p>
<p>先贴上用来测试当tcp服务端的代码。我在网上随便搜的：<a target="_blank" rel="noopener" href="https://github.com/fschr/simpletcp.git">https://github.com/fschr/simpletcp.git</a></p>
<p>下面是我拿来测试的tcp server代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">from</span> simpletcp.tcpserver <span class="keyword">import</span> TCPServer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo</span>(<span class="params">ip, queue, data</span>):</span></span><br><span class="line">    queue.put(bytes(<span class="string">&quot;server recv &quot;</span>,<span class="string">&quot;UTF-8&quot;</span>)+data)</span><br><span class="line">    print(<span class="string">&quot;echo &quot;</span>+data.decode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"></span><br><span class="line">server = TCPServer(<span class="string">&quot;192.168.3.8&quot;</span>, <span class="number">5000</span>, echo)</span><br><span class="line">server.run()</span><br></pre></td></tr></table></figure>

<p>然后下面贴上java的代码。三种请求的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetByHttpURL</span><span class="params">(<span class="keyword">final</span> String url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String resultData=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                URL connUrl=<span class="keyword">new</span> URL (url);</span><br><span class="line">                HttpURLConnection urlConn= (HttpURLConnection)connUrl.openConnection (); </span><br><span class="line">                InputStreamReader in=<span class="keyword">new</span> InputStreamReader (urlConn.getInputStream());</span><br><span class="line">                BufferedReader buffer=<span class="keyword">new</span> BufferedReader (in);</span><br><span class="line">                String inputLine=<span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">while</span> (((inputLine=buffer.readLine()) !=<span class="keyword">null</span>)) &#123;</span><br><span class="line">                    resultData+=inputLine+<span class="string">&quot;\n&quot;</span>; </span><br><span class="line">                &#125;</span><br><span class="line">                in.close();</span><br><span class="line">                urlConn.disconnect();</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;GetByHttpURL &quot;</span>+resultData);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;GetByHttpURL error &quot;</span>+e.getMessage());</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetByOkHttp</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        OkHttpClient okHttpClient = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">        <span class="keyword">final</span> Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">                .url(url)</span><br><span class="line">                .get()<span class="comment">//默认就是GET请求，可以不写</span></span><br><span class="line">                .build();</span><br><span class="line">        Call call = okHttpClient.newCall(request);</span><br><span class="line">        call.enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;onFailure: &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;GetByOkHttp onResponse: &quot;</span> + response.body().string());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;GetByOkHttp error &quot;</span>+e.getMessage());</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoTcp</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">&quot;DoTcp bind tcp&quot;</span>);</span><br><span class="line">    Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;192.168.3.8&quot;</span>, <span class="number">5000</span>);</span><br><span class="line">    socket.setSoTimeout(<span class="number">10000</span>);</span><br><span class="line">    <span class="comment">//发送数据给服务端</span></span><br><span class="line">    OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">    outputStream.write(<span class="string">&quot;hello,server&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    socket.shutdownOutput();</span><br><span class="line">    <span class="comment">//读取数据</span></span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">    String line = br.readLine();</span><br><span class="line">    <span class="comment">//打印读取到的数据</span></span><br><span class="line">    Log.d(TAG, <span class="string">&quot;tcp server recv:&quot;</span> + line);</span><br><span class="line">    br.close();</span><br><span class="line">    socket.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    TextView tv = findViewById(R.id.sample_text);</span><br><span class="line">    tv.setText(stringFromJNI());</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;start send http&quot;</span>);</span><br><span class="line">                    GetByOkHttp(<span class="string">&quot;http://missking.cc/&quot;</span>);</span><br><span class="line">                    GetByHttpURL(<span class="string">&quot;http://10.ip138.com&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    DoTcp();</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;DoTcp error: &quot;</span> + e.getMessage());</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;DoTcp error: &quot;</span> + e.getMessage());</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面列出了HttpURLConnection请求。OkHttp3的库来请求。以及一个tcp的请求。我们知道http最终也是调用的tcp连接来传输的。所以我们直接分析tcp的调用流程即可。在调用链中。任意一个含有我们传递参数的位置都可以打印出想要的明文信息。但是我们要尽量的找一个更通用一些。能获取到数据更完整的点来hook。所以我们找到最后调用的native的位置。下面列出我们接下来的目标</p>
<p>1、找到tcp请求发送数据的native函数处</p>
<p>2、hook函数打印发送的数据以及目标服务器地址、端口。</p>
<p>3、找到tcp请求接受数据的native函数处</p>
<p>4、hook函数打印接收的数据以及目标服务器地址、端口。</p>
<p>目标服务器地址和端口我们直接hook了Socket的构造函数即可拿到。所以直接分析发送数据部分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public abstract class OutputStream   //这个OutputStream是一个抽象类，我们需要找到这个对象的真实类型</span></span><br><span class="line">OutputStream outputStream = socket.getOutputStream();</span><br><span class="line"><span class="comment">//找到对应的真实类型后，再找到对应的write函数</span></span><br><span class="line">outputStream.write(<span class="string">&quot;hello,server&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"><span class="comment">//下面打印下input和output的真实类型</span></span><br><span class="line">Log.d(TAG,<span class="string">&quot;output class:&quot;</span>+outputStream.getClass());</span><br><span class="line">Log.d(TAG,<span class="string">&quot;input class:&quot;</span>+socket.getInputStream().getClass());</span><br></pre></td></tr></table></figure>

<p>然后结果如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output class:class java.net.SocketOutputStream</span><br><span class="line">input class:class java.net.SocketInputStream</span><br></pre></td></tr></table></figure>

<p>我们先看看write的调用链。整理后如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SocketOutputStream.java</span></span><br><span class="line"><span class="comment">//第一步调用到这里</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      socketWrite(b, <span class="number">0</span>, b.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二步调用到这个</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">socketWrite</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">0</span> || off &lt; <span class="number">0</span> || len &gt; b.length - off) &#123;</span><br><span class="line">            <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">&quot;len == &quot;</span> + len</span><br><span class="line">                    + <span class="string">&quot; off == &quot;</span> + off + <span class="string">&quot; buffer length == &quot;</span> + b.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FileDescriptor fd = impl.acquireFD();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BlockGuard.getThreadPolicy().onNetwork();</span><br><span class="line">            socketWrite0(fd, b, off, len);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException se) &#123;</span><br><span class="line">            <span class="keyword">if</span> (se <span class="keyword">instanceof</span> sun.net.ConnectionResetException) &#123;</span><br><span class="line">                impl.setConnectionResetPending();</span><br><span class="line">                se = <span class="keyword">new</span> SocketException(<span class="string">&quot;Connection reset&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (impl.isClosedOrPending()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">&quot;Socket closed&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> se;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            impl.releaseFD();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三部调用到这里。java部分的就走完了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">socketWrite0</span><span class="params">(FileDescriptor fd, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以我们发送数据抓包可以通过hook函数socketWrite0来获取</p>
<p>接下来是接受数据readline的流程，这里比上面稍微复杂一些。我会列出完整的来龙去脉</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先贴是怎么调用的</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">String line = br.readLine();</span><br><span class="line"></span><br><span class="line"><span class="comment">//所以直接看BufferedReader.java的readLine()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">readLine</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> readLine(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后调用了另外一个重载，这个函数比较大。省略掉非关键位置</span></span><br><span class="line"><span class="function">String <span class="title">readLine</span><span class="params">(<span class="keyword">boolean</span> ignoreLF)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    fill();  </span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后看看fill的处理</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    in.read(cb, dst, cb.length - dst);</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面的in是InputStreamReader这个类型所以InputStreamReader.java中看看read</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> sd.read(cbuf, offset, length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个sd是StreamDecoder这个类。继续到里面看看read函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">return</span> n + implRead(cbuf, off, off + len);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继续看implRead</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">implRead</span><span class="params">(<span class="keyword">char</span>[] cbuf, <span class="keyword">int</span> off, <span class="keyword">int</span> end)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">int</span> n = readBytes();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继续看readBytes。这里的in就是我们的SocketInputStream。绕了一圈终于到这里了。继续往后看</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">readBytes</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">int</span> n = in.read(bb.array(), bb.arrayOffset() + pos, rem);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面是SocketInputStream.java中的read函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> read(b, off, length, impl.getTimeout());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继续看调用的另外一个重载</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> length, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    n = socketRead(fd, b, off, length, timeout);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继续看socketRead。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">socketRead</span><span class="params">(FileDescriptor fd,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> timeout)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> socketRead0(fd, b, off, len, timeout);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//终于到达了最后的native函数。java部分走完了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">socketRead0</span><span class="params">(FileDescriptor fd,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">int</span> timeout)</span><span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据上面我们的线索。下面开始写代码hook一下。最后看看是不是能通抓三个发包的数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将数组转换成c++的byte[]。并且hexdump打印结果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print_bytes</span>(<span class="params">bytes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> buf  = Memory.alloc(bytes.length);</span><br><span class="line">    Memory.writeByteArray(buf, byte_to_ArrayBuffer(bytes));</span><br><span class="line">    <span class="built_in">console</span>.log(hexdump(buf, &#123;<span class="attr">offset</span>: <span class="number">0</span>, <span class="attr">length</span>: bytes.length, <span class="attr">header</span>: <span class="literal">false</span>, <span class="attr">ansi</span>: <span class="literal">true</span>&#125;));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将java的数组转换成js的数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">byte_to_ArrayBuffer</span>(<span class="params">bytes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> size=bytes.length;</span><br><span class="line">    <span class="keyword">var</span> tmparray = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> val = bytes[i];</span><br><span class="line">        <span class="keyword">if</span>(val &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            val += <span class="number">256</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmparray[i] = val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmparray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// java.net.Socket$init(ip,port) 获取ip和端口</span></span><br><span class="line"><span class="comment">// socketWrite0(FileDescriptor fd, byte[] b, int off,int len) 获取发送的数据</span></span><br><span class="line"><span class="comment">// socketRead0(FileDescriptor fd,byte b[], int off, int len,int timeout) 获取接受的数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_tcp</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> socketClass= Java.use(<span class="string">&quot;java.net.Socket&quot;</span>);</span><br><span class="line">    socketClass.$init.overload(<span class="string">&#x27;java.net.InetAddress&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).implementation=<span class="function"><span class="keyword">function</span>(<span class="params">ip,port</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;socket$init &quot;</span>,ip,<span class="string">&quot;:&quot;</span>,port);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.$init(ip,port);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> outputClass=Java.use(<span class="string">&quot;java.net.SocketOutputStream&quot;</span>);</span><br><span class="line">    outputClass.socketWrite0.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">fd,buff,off,len</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;tcp write fd:&quot;</span>,fd);</span><br><span class="line">        print_bytes(buff);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.socketWrite0(fd,buff,off,len);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> inputClass=Java.use(<span class="string">&quot;java.net.SocketInputStream&quot;</span>);</span><br><span class="line">    inputClass.socketRead0.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">fd,buff,off,len,timeout</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> res=<span class="built_in">this</span>.socketRead0(fd,buff,off,len,timeout);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;tcp read fd:&quot;</span>,fd)</span><br><span class="line">        print_bytes(buff);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_java</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        hook_tcp();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    hook_java();</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></table></figure>

<p>最后跑一下。将结果存储到文本中。搜索一下我们访问的两个地址<code>http://missking.cc/</code>以及<code>http://10.ip138.com</code>还有tcp服务器返回是否有收到</p>
<p><img src="/2021/05/04/zhuabao/image-20210525222902261.png" alt="image-20210525222902261"></p>
<p><img src="/2021/05/04/zhuabao/image-20210525222938288.png" alt="image-20210525222938288"></p>
<p><img src="/2021/05/04/zhuabao/image-20210525223221153.png" alt="image-20210525223221153"></p>
<p><img src="/2021/05/04/zhuabao/image-20210525223739749.png" alt="image-20210525223739749"></p>
<p>上面的日志显示。成功抓到了两种http请求和tcp的包</p>
<h3 id="2、jni层抓http包"><a href="#2、jni层抓http包" class="headerlink" title="2、jni层抓http包"></a>2、jni层抓http包</h3><p>有的时候发包的步骤并不是在java层中。而是在jni层直接就发包了。所以我们即使在java层的最深处。也没法抓到。准备一个例子</p>
<p>所以我们继续追踪之前的http发包例子的后续。socketWrite0和socketRead0的c层的调用链。通过编译配置，可以层层筛选找到代码在libopenjdk.so中。从当前测试手机中导出这个so文件。用ida打开后直接搜索就能找到socketWrite0。</p>
<p>socketWrite0解析的结果后发现调用的是NET_Send。再往后调用libc的sendto来进行发送数据</p>
<p><img src="/2021/05/04/zhuabao/image-20210528225035954.png" alt="image-20210528225035954"></p>
<p>socketRead0解析的结果后发现调用的是NET_Read。再往后调用libc的recvfrom来进行发送数据</p>
<p><img src="/2021/05/04/zhuabao/image-20210528225357994.png" alt="image-20210528225357994"></p>
<p>最后开始写代码来处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSocketData</span>(<span class="params">fd</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;fd:&quot;</span>,fd);</span><br><span class="line">    <span class="keyword">var</span> socketType=Socket.type(fd)</span><br><span class="line">    <span class="keyword">if</span>(socketType!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> res=<span class="string">&quot;type:&quot;</span>+socketType+<span class="string">&quot;,loadAddress:&quot;</span>+<span class="built_in">JSON</span>.stringify(Socket.localAddress(fd))+<span class="string">&quot;,peerAddress&quot;</span>+<span class="built_in">JSON</span>.stringify(Socket.peerAddress(fd));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;type:&quot;</span>+socketType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_jni_tcp</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sendtoPtr=Module.getExportByName(<span class="string">&quot;libc.so&quot;</span>,<span class="string">&quot;sendto&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> recvfromPtr=Module.getExportByName(<span class="string">&quot;libc.so&quot;</span>,<span class="string">&quot;recvfrom&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;sendto:&quot;</span>,sendtoPtr,<span class="string">&quot;,recvfrom:&quot;</span>,recvfromPtr);</span><br><span class="line">    <span class="comment">//sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len)</span></span><br><span class="line">    Interceptor.attach(sendtoPtr,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> fd=args[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">var</span> buff=args[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">var</span> size=args[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">var</span> sockdata=getSocketData(fd.toInt32());</span><br><span class="line">            <span class="built_in">console</span>.log(sockdata);</span><br><span class="line">            <span class="built_in">console</span>.log(hexdump(buff,&#123;<span class="attr">length</span>:size.toInt32()&#125;));</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len)</span></span><br><span class="line">    Interceptor.attach(recvfromPtr,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.fd=args[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">this</span>.buff=args[<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">this</span>.size=args[<span class="number">2</span>];</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> sockdata=getSocketData(<span class="built_in">this</span>.fd.toInt32());</span><br><span class="line">            <span class="built_in">console</span>.log(sockdata);</span><br><span class="line">            <span class="built_in">console</span>.log(hexdump(<span class="built_in">this</span>.buff,&#123;<span class="attr">length</span>:<span class="built_in">this</span>.size.toInt32()&#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后的hook结果。这里注意。我们刚刚梳理的jni调用流程是http的。所以测试程序的请求连接要修改下。</p>
<p><img src="/2021/05/04/zhuabao/image-20210528231015686.png" alt="image-20210528231015686"></p>
<h3 id="3、java层ssl抓包"><a href="#3、java层ssl抓包" class="headerlink" title="3、java层ssl抓包"></a>3、java层ssl抓包</h3><p>https实际上就是http+ssl。由于http发送的数据直接就是明文。安全性非常差。https会在数据发送前，先用ssl进行加密。如下图</p>
<p><img src="/2021/05/04/zhuabao/image-20210525224736434.png" alt="image-20210525224736434"></p>
<p>而加密则是使用对应的证书。接受到服务端数据后。再使用证书来进行解密</p>
<p><img src="/2021/05/04/zhuabao/image-20210525224939145.png" alt="image-20210525224939145"></p>
<p>下面是https交互的流程。ssl会先将证书中的公钥发送给服务器。然后服务器将自己的公钥返回给客户端。然后客户端拿到公钥后和证书中的私钥计算出共享密钥。然后就使用共享密钥来加解密服务端传递来的数据。服务端同样也是拿到客户端的公钥，就和自己的私钥计算出共享密钥。</p>
<p><img src="/2021/05/04/zhuabao/image-20210525225216620.png" alt="image-20210525225216620"></p>
<p>看完https的理论部分。我们就清楚如何达到自己的目的了。实际上只要在数据加密前的函数调用流程任意一个环节hook都能抓到明文。</p>
<p>下面直接修改访问地址成https。由于有些证书是手机内置的无需我们自行添加证书。所以代码不需要修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GetByOkHttp(<span class="string">&quot;https://www.baidu.com/&quot;</span>);</span><br><span class="line">GetByHttpURL(<span class="string">&quot;https://www.jd.com/&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>请求地址修改后。重新使用上面的脚本来hook。发现无法再抓到tcp的请求数据了。说明调用链发生了变化。所以我们分析下访问https时的调用链</p>
<p>由于这个调用链比较长。我就只针对OkHttp3进行跟踪分析。这里我采用的是调试的方式来追踪这个函数。由于整个追踪跳转的较多。我就只针对重点部分进行记录了。在开始调试之前。我们先整理清楚自己的目的。</p>
<p>1、调试GetByOkHttp执行的流程。在执行过程中找到ssl相关的处理。</p>
<p>2、追踪ssl相关的处理。找到最后调用的native函数。</p>
<p>那么下面贴上调试时得到的信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最关键的是这个newCall。断点跟踪进去</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetByOkHttp</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Call call = okHttpClient.newCall(request);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面调用了一个静态的初始化RealCall</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> RealCall.newRealCall(<span class="keyword">this</span>, request, <span class="keyword">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里初始化RealCall</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> RealCall <span class="title">newRealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Safely publish the Call instance to the EventListener.</span></span><br><span class="line">    RealCall call = <span class="keyword">new</span> RealCall(client, originalRequest, forWebSocket);</span><br><span class="line">    call.eventListener = client.eventListenerFactory().create(call);</span><br><span class="line">    <span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//到这里初始化好了。这里注意，retryAndFollowUpInterceptor这个实际上是一个拦截器，那么接下来我们应该把断点放在拦截器的intercept函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">RealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.client = client;</span><br><span class="line">    <span class="keyword">this</span>.originalRequest = originalRequest;</span><br><span class="line">    <span class="keyword">this</span>.forWebSocket = forWebSocket;</span><br><span class="line">    <span class="keyword">this</span>.retryAndFollowUpInterceptor = <span class="keyword">new</span> RetryAndFollowUpInterceptor(client, forWebSocket);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拦截器的触发函数。proceed里面的流程较长。里面经过了多次的跳转。</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">      response = realChain.proceed(request, streamAllocation, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//多次跳转后。最后走进了RealConnection.java的connect函数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> pingIntervalMillis, <span class="keyword">boolean</span> connectionRetryEnabled, Call call,</span></span></span><br><span class="line"><span class="function"><span class="params">      EventListener eventListener)</span> </span>&#123;</span><br><span class="line">           ...</span><br><span class="line">      <span class="comment">//这里判断如果非ssl的处理</span></span><br><span class="line">      <span class="keyword">if</span> (route.address().sslSocketFactory() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RouteException(<span class="keyword">new</span> UnknownServiceException(</span><br><span class="line">              <span class="string">&quot;CLEARTEXT communication not enabled for client&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        String host = route.address().url().host();</span><br><span class="line">        <span class="keyword">if</span> (!Platform.get().isCleartextTrafficPermitted(host)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RouteException(<span class="keyword">new</span> UnknownServiceException(</span><br><span class="line">              <span class="string">&quot;CLEARTEXT communication to &quot;</span> + host + <span class="string">&quot; not permitted by network security policy&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">          ...</span><br><span class="line">      <span class="comment">//这里面调用的socket.connect()</span></span><br><span class="line">      connectSocket(connectTimeout, readTimeout, call, eventListener);</span><br><span class="line">          ...</span><br><span class="line">      <span class="comment">//这里面发送的请求</span></span><br><span class="line">      establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);</span><br><span class="line">          ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先看看socket的连接部分</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connectSocket</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, Call call,</span></span></span><br><span class="line"><span class="function"><span class="params">      EventListener eventListener)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    <span class="comment">//根据不同的type创建不同的socket</span></span><br><span class="line">    rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP</span><br><span class="line">    ? address.socketFactory().createSocket()</span><br><span class="line">    : <span class="keyword">new</span> Socket(proxy);</span><br><span class="line">      ...</span><br><span class="line">    <span class="comment">//socket的连接</span></span><br><span class="line">    Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后这里只是单纯的调用下连接。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectSocket</span><span class="params">(Socket socket, InetSocketAddress address,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> connectTimeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    socket.connect(address, connectTimeout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面继续看发送请求的函数establishProtocol</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">establishProtocol</span><span class="params">(ConnectionSpecSelector connectionSpecSelector,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> pingIntervalMillis, Call call, EventListener eventListener)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">//非ssl的请求直接在这里就返回了</span></span><br><span class="line">    <span class="keyword">if</span> (route.address().sslSocketFactory() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      protocol = Protocol.HTTP_1_1;</span><br><span class="line">      socket = rawSocket;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">//后面是ssl相关的处理</span></span><br><span class="line">    eventListener.secureConnectStart(call);</span><br><span class="line">      <span class="comment">//最关键的是这里会创建sslsocket。并且和服务端进行握手交互</span></span><br><span class="line">    connectTls(connectionSpecSelector);</span><br><span class="line">    eventListener.secureConnectEnd(call, handshake);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (protocol == Protocol.HTTP_2) &#123;</span><br><span class="line">      socket.setSoTimeout(<span class="number">0</span>); <span class="comment">// HTTP/2 connection timeouts are set per-stream.</span></span><br><span class="line">      http2Connection = <span class="keyword">new</span> Http2Connection.Builder(<span class="keyword">true</span>)</span><br><span class="line">          .socket(socket, route.address().url().host(), source, sink)</span><br><span class="line">          .listener(<span class="keyword">this</span>)</span><br><span class="line">          .pingIntervalMillis(pingIntervalMillis)</span><br><span class="line">          .build();</span><br><span class="line">      http2Connection.start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最关键的部分。所以我就贴上完整的代码了。里面很多地方有英文注释。我就不自己画蛇添足了。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connectTls</span><span class="params">(ConnectionSpecSelector connectionSpecSelector)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Address address = route.address();</span><br><span class="line">    SSLSocketFactory sslSocketFactory = address.sslSocketFactory();</span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">    SSLSocket sslSocket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Create the wrapper over the connected socket.</span></span><br><span class="line">      sslSocket = (SSLSocket) sslSocketFactory.createSocket(</span><br><span class="line">          rawSocket, address.url().host(), address.url().port(), <span class="keyword">true</span> <span class="comment">/* autoClose */</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Configure the socket&#x27;s ciphers, TLS versions, and extensions.</span></span><br><span class="line">      ConnectionSpec connectionSpec = connectionSpecSelector.configureSecureSocket(sslSocket);</span><br><span class="line">      <span class="keyword">if</span> (connectionSpec.supportsTlsExtensions()) &#123;</span><br><span class="line">        Platform.get().configureTlsExtensions(</span><br><span class="line">            sslSocket, address.url().host(), address.protocols());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Force handshake. This can throw!</span></span><br><span class="line">      sslSocket.startHandshake();</span><br><span class="line">      <span class="comment">// block for session establishment</span></span><br><span class="line">      SSLSession sslSocketSession = sslSocket.getSession();</span><br><span class="line">      <span class="keyword">if</span> (!isValid(sslSocketSession)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;a valid ssl session was not established&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      Handshake unverifiedHandshake = Handshake.get(sslSocketSession);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Verify that the socket&#x27;s certificates are acceptable for the target host.</span></span><br><span class="line">      <span class="keyword">if</span> (!address.hostnameVerifier().verify(address.url().host(), sslSocketSession)) &#123;</span><br><span class="line">        X509Certificate cert = (X509Certificate) unverifiedHandshake.peerCertificates().get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SSLPeerUnverifiedException(<span class="string">&quot;Hostname &quot;</span> + address.url().host() + <span class="string">&quot; not verified:&quot;</span></span><br><span class="line">            + <span class="string">&quot;\n    certificate: &quot;</span> + CertificatePinner.pin(cert)</span><br><span class="line">            + <span class="string">&quot;\n    DN: &quot;</span> + cert.getSubjectDN().getName()</span><br><span class="line">            + <span class="string">&quot;\n    subjectAltNames: &quot;</span> + OkHostnameVerifier.allSubjectAltNames(cert));</span><br><span class="line">      &#125;</span><br><span class="line">            <span class="comment">//这里是证书的校验</span></span><br><span class="line">      <span class="comment">// Check that the certificate pinner is satisfied by the certificates presented.</span></span><br><span class="line">      address.certificatePinner().check(address.url().host(),</span><br><span class="line">          unverifiedHandshake.peerCertificates());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Success! Save the handshake and the ALPN protocol.</span></span><br><span class="line">      String maybeProtocol = connectionSpec.supportsTlsExtensions()</span><br><span class="line">          ? Platform.get().getSelectedProtocol(sslSocket)</span><br><span class="line">          : <span class="keyword">null</span>;</span><br><span class="line">      socket = sslSocket;</span><br><span class="line">      source = Okio.buffer(Okio.source(socket));</span><br><span class="line">      sink = Okio.buffer(Okio.sink(socket));</span><br><span class="line">      handshake = unverifiedHandshake;</span><br><span class="line">      protocol = maybeProtocol != <span class="keyword">null</span></span><br><span class="line">          ? Protocol.get(maybeProtocol)</span><br><span class="line">          : Protocol.HTTP_1_1;</span><br><span class="line">      success = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (AssertionError e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Util.isAndroidGetsocknameError(e)) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(e);</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (sslSocket != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Platform.get().afterHandshake(sslSocket);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        closeQuietly(sslSocket);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面流程走完。ssl的连接就建立起来了。继续跟踪后。走到下一个关键拦截器CallServerInterceptor.java。我们直接看拦截器函数实现部分</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="comment">//前面的代码应该是准备header的数据。我就都省略了。下面这个函数是发送请求的关键函数</span></span><br><span class="line">    httpCodec.finishRequest();</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继续往后跟踪flush</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    sink.flush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继续跟踪sink.write</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (closed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;closed&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (buffer.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      sink.write(buffer, buffer.size);</span><br><span class="line">    &#125;</span><br><span class="line">    sink.flush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继续往后看write</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Buffer source, <span class="keyword">long</span> byteCount)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        checkOffsetAndCount(source.size, <span class="number">0</span>, byteCount);</span><br><span class="line">      ...</span><br><span class="line">    sink.write(source, toWrite);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个write就到一个关键的位置了。这个out对象就是我们关心的类了。我们查一下out的类型</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Buffer source, <span class="keyword">long</span> byteCount)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//out对象的类型是com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream</span></span><br><span class="line">    out.write(head.data, head.pos, toCopy);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接下来我们就可以去找SSLOutputStream的write了。我们在调试中跟踪过去失败了。那么直接去翻源码把。下面是对应的write</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> offset, <span class="keyword">int</span> byteCount)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    ssl.write(Platform.getFileDescriptor(socket), buf, offset, byteCount,writeTimeoutMilliseconds);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继续看ssl.write。这个ssl的类型是SslWrapper。找到对应的write如下。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(FileDescriptor fd, <span class="keyword">byte</span>[] buf, <span class="keyword">int</span> offset, <span class="keyword">int</span> len, <span class="keyword">int</span> timeoutMillis)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        NativeCrypto.SSL_write(ssl, fd, handshakeCallbacks, buf, offset, len, timeoutMillis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继续找NativeCrypto类的SSL_write函数。到这里就结束了。终于到达java调用链的最后一层了。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">SSL_write</span><span class="params">(<span class="keyword">long</span> sslNativePointer, FileDescriptor fd,</span></span></span><br><span class="line"><span class="function"><span class="params">            SSLHandshakeCallbacks shc, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len, <span class="keyword">int</span> writeTimeoutMillis)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据上面的一连串翻找。终于走完了https请求时的java部分的整个调用链。至于读取包的。可以直接猜测一下，看有没有对应的SSL_read。搜了一下。果然是有的。很可能就是这个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">SSL_read</span><span class="params">(<span class="keyword">long</span> sslNativePointer, FileDescriptor fd, SSLHandshakeCallbacks shc,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len, <span class="keyword">int</span> readTimeoutMillis)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<p>接下来开始写hook脚本来处理SSL_write和SSL_read。在这之前。我们要先找到NativeCrypto类的包名才行。用frida来搜索一下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Java.enumerateLoadedClassesSync().forEach(<span class="function"><span class="keyword">function</span>(<span class="params">className</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(className.indexOf(name)!=<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">getFullName(<span class="string">&quot;NativeCrypto&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>最后得到结果<code>com.android.org.conscrypt.NativeCrypto</code></p>
<p>然后来处理读取和写入</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NativeCrypto   SSL_write(long sslNativePointer, FileDescriptor fd,</span></span><br><span class="line"><span class="comment">//             SSLHandshakeCallbacks shc, byte[] b, int off, int len, int writeTimeoutMillis)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//NativeCrypto   SSL_read(long sslNativePointer, FileDescriptor fd, SSLHandshakeCallbacks shc,</span></span><br><span class="line"><span class="comment">//             byte[] b, int off, int len, int readTimeoutMillis)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_ssl</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> NativeCryptoClass= Java.use(<span class="string">&quot;com.android.org.conscrypt.NativeCrypto&quot;</span>);</span><br><span class="line">    NativeCryptoClass.SSL_write.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">sslPtr,fd,shc,b,off,len,timeout</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;enter SSL_write&quot;</span>);</span><br><span class="line">        print_bytes(b);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.SSL_write(sslPtr,fd,shc,b,off,len,timeout);</span><br><span class="line">    &#125;;</span><br><span class="line">    NativeCryptoClass.SSL_read.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">sslPtr,fd,shc,b,off,len,timeout</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;enter SSL_read&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> res=<span class="built_in">this</span>.SSL_read(sslPtr,fd,shc,b,off,len,timeout);</span><br><span class="line">        print_bytes(b);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后这里就能获取到https的包数据了。但是如果是tcp的情况会有个问题。就是没有连接的服务器ip地址和端口。在整个调用链环节中。我们可以找个尽量靠近native层调用，并且能取到服务器地址和端口的函数来hook。比如直接hook了SSLOutputStream的write和SSLInputStream的read。我们先看看断点调试走到最后的SLLOutPutStream的那里。然后展开这个out对象看看有些什么属性</p>
<p><img src="/2021/05/04/zhuabao/image-20210528205036217.png" alt="image-20210528205036217"></p>
<p>看到在out里面有个this$0里面的socket有我们想要的目标服务器地址和端口。这个$0实际上是指向当前这个类中类的父级对象。那么我们再hook一下这里</p>
<p>老样子先用之前的办法取到完整类名<code>com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSocketData2</span>(<span class="params">stream</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data0=stream.this$<span class="number">0.</span>value;</span><br><span class="line">    <span class="keyword">var</span> sockdata=data0.socket.value;</span><br><span class="line">    <span class="keyword">return</span> sockdata;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SSLOutputStream  write(byte[] buf, int offset, int byteCount)</span></span><br><span class="line"><span class="comment">//SSLInputStream     read(byte[] buf, int offset, int byteCount)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_ssl2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> SSLOutputClass=Java.use(<span class="string">&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream&quot;</span>);</span><br><span class="line">    SSLOutputClass.write.overload(<span class="string">&#x27;[B&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).implementation=<span class="function"><span class="keyword">function</span>(<span class="params">buf,off,cnt</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(getSocketData2(<span class="built_in">this</span>));</span><br><span class="line">        print_bytes(buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.write(buf,off,cnt);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> SSLInputClass=Java.use(<span class="string">&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream&quot;</span>);</span><br><span class="line">    SSLInputClass.read.overload(<span class="string">&#x27;[B&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).implementation=<span class="function"><span class="keyword">function</span>(<span class="params">buf,off,cnt</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> res=<span class="built_in">this</span>.read(buf,off,cnt);</span><br><span class="line">        <span class="built_in">console</span>.log(getSocketData2(<span class="built_in">this</span>));</span><br><span class="line">        print_bytes(buf);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后看看效果。能成功抓到请求了。</p>
<p><img src="/2021/05/04/zhuabao/image-20210528210239341.png" alt="image-20210528210239341"></p>
<h3 id="4、jni层抓https包"><a href="#4、jni层抓https包" class="headerlink" title="4、jni层抓https包"></a>4、jni层抓https包</h3><p>继续跟着前面的线索往jni层跟踪。前面我们看到的最后一层是SSL_write和SSL_read，所属类是NativeCrypto。直接搜索函数NativeCrypto_SSL_write。下面贴出关键代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">NativeCrypto_SSL_write</span><span class="params">(JNIEnv* env, jclass, jlong ssl_address, jobject fdObject,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   jobject shc, jbyteArray b, jint offset, jint len,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   jint write_timeout_millis)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    ret = sslWrite(env, ssl, fdObject, shc, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(&amp;buf[<span class="number">0</span>]), len,</span><br><span class="line">                           sslError, write_timeout_millis);</span><br><span class="line">      ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续查看sslWrite的实现。发现里面又调用了一层SSL_write。这个函数虽然和上面的函数同名。但是不是同一个了。该函数是boringssl中的了。这是谷歌创建的openssl的分支，内置在android中的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sslWrite</span><span class="params">(JNIEnv* env, SSL* ssl, jobject fdObject, jobject shc, <span class="keyword">const</span> <span class="keyword">char</span>* buf, jint len,</span></span></span><br><span class="line"><span class="function"><span class="params">                    OpenSslError&amp; sslError, <span class="keyword">int</span> write_timeout_millis)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">int</span> result = SSL_write(ssl, buf, len);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续看boringssl中的SSL_write。这里调用的函数是根据不同ssl版本调用的。所以找对应的函数应该带上对应版本比如ssl3_write_app_data</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_write</span><span class="params">(SSL *ssl, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    ret = ssl-&gt;method-&gt;write_app_data(ssl, &amp;needs_handshake,</span><br><span class="line">                                      (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)buf, num);</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>继续看ssl3_write_app_data的实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ssl3_write_app_data</span><span class="params">(SSL *ssl, <span class="keyword">int</span> *out_needs_handshake, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">int</span> ret = do_ssl3_write(ssl, SSL3_RT_APPLICATION_DATA, &amp;buf[tot], nw);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续看do_ssl3_write的实现。这里可以看到这里就是明文的终点了。再往后面去的函数数据都是密文的了。从这里往前的流程都是明文。可以找任意一个觉得合适的地方来hook。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_ssl3_write</span><span class="params">(SSL *ssl, <span class="keyword">int</span> type, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *buf, <span class="keyword">unsigned</span> len)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">/* Add any unflushed handshake data as a prefix. This may be a KeyUpdate</span></span><br><span class="line"><span class="comment">* acknowledgment or 0-RTT key change messages. |pending_flight| must be clear</span></span><br><span class="line"><span class="comment">* when data is added to |write_buffer| or it will be written in the wrong</span></span><br><span class="line"><span class="comment">* order. */</span></span><br><span class="line">  <span class="keyword">if</span> (ssl-&gt;s3-&gt;pending_flight != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    OPENSSL_memcpy(</span><br><span class="line">        out, ssl-&gt;s3-&gt;pending_flight-&gt;data + ssl-&gt;s3-&gt;pending_flight_offset,</span><br><span class="line">        flight_len);</span><br><span class="line">    BUF_MEM_free(ssl-&gt;s3-&gt;pending_flight);</span><br><span class="line">    ssl-&gt;s3-&gt;pending_flight = <span class="literal">NULL</span>;</span><br><span class="line">    ssl-&gt;s3-&gt;pending_flight_offset = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!tls_seal_record(ssl, out + flight_len, &amp;ciphertext_len,</span><br><span class="line">                       max_out - flight_len, type, buf, len)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ssl_write_buffer_set_len(ssl, flight_len + ciphertext_len);</span><br><span class="line">    ...</span><br><span class="line">  <span class="comment">/* we now just need to write the buffer */</span></span><br><span class="line">  <span class="keyword">return</span> ssl3_write_pending(ssl, type, buf, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在开始写hook处理前解决一个疑问。就是之前在recvfrom和sendto进行hook。并没有取到https的密文。所以我们去看一下。boringssl中是怎么处理最终发送数据的。在boringssl项目的文件<code>crypto/bio/socket.c</code>中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sock_read</span><span class="params">(BIO *b, <span class="keyword">char</span> *out, <span class="keyword">int</span> outl)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (out == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  bio_clear_socket_error();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(OPENSSL_WINDOWS)</span></span><br><span class="line">  ret = recv(b-&gt;num, out, outl, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  ret = <span class="built_in">read</span>(b-&gt;num, out, outl);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  BIO_clear_retry_flags(b);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bio_fd_should_retry(ret)) &#123;</span><br><span class="line">      BIO_set_retry_read(b);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sock_write</span><span class="params">(BIO *b, <span class="keyword">const</span> <span class="keyword">char</span> *in, <span class="keyword">int</span> inl)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">  bio_clear_socket_error();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(OPENSSL_WINDOWS)</span></span><br><span class="line">  ret = send(b-&gt;num, in, inl, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  ret = <span class="built_in">write</span>(b-&gt;num, in, inl);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  BIO_clear_retry_flags(b);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bio_fd_should_retry(ret)) &#123;</span><br><span class="line">      BIO_set_retry_write(b);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到如何是jni层的ssl里面最终发送数据的地方。判断了如果是win平台就用send和recv。否则就使用write和read。这样我们就知道jni层的ssl怎么抓明文和密文了。明文的hook点直接选择openssl调用的函数SSL_write和SSL_read接下来开始写代码。下面贴上完整的代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将数组转换成c++的byte[]。并且hexdump打印结果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print_bytes</span>(<span class="params">bytes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> buf  = Memory.alloc(bytes.length);</span><br><span class="line">    Memory.writeByteArray(buf, byte_to_ArrayBuffer(bytes));</span><br><span class="line">    <span class="built_in">console</span>.log(hexdump(buf, &#123;<span class="attr">offset</span>: <span class="number">0</span>, <span class="attr">length</span>: bytes.length, <span class="attr">header</span>: <span class="literal">false</span>, <span class="attr">ansi</span>: <span class="literal">true</span>&#125;));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将java的数组转换成js的数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">byte_to_ArrayBuffer</span>(<span class="params">bytes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> size=bytes.length;</span><br><span class="line">    <span class="keyword">var</span> tmparray = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> val = bytes[i];</span><br><span class="line">        <span class="keyword">if</span>(val &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            val += <span class="number">256</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmparray[i] = val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmparray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// java.net.Socket$init(ip,port) 获取ip和端口</span></span><br><span class="line"><span class="comment">// socketWrite0(FileDescriptor fd, byte[] b, int off,int len) 获取发送的数据</span></span><br><span class="line"><span class="comment">// socketRead0(FileDescriptor fd,byte b[], int off, int len,int timeout) 获取接受的数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_tcp</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> socketClass= Java.use(<span class="string">&quot;java.net.Socket&quot;</span>);</span><br><span class="line">    socketClass.$init.overload(<span class="string">&#x27;java.net.InetAddress&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).implementation=<span class="function"><span class="keyword">function</span>(<span class="params">ip,port</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;socket$init &quot;</span>,ip,<span class="string">&quot;:&quot;</span>,port);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.$init(ip,port);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> outputClass=Java.use(<span class="string">&quot;java.net.SocketOutputStream&quot;</span>);</span><br><span class="line">    outputClass.socketWrite0.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">fd,buff,off,len</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;tcp write fd:&quot;</span>,fd);</span><br><span class="line">        print_bytes(buff);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.socketWrite0(fd,buff,off,len);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> inputClass=Java.use(<span class="string">&quot;java.net.SocketInputStream&quot;</span>);</span><br><span class="line">    inputClass.socketRead0.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">fd,buff,off,len,timeout</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> res=<span class="built_in">this</span>.socketRead0(fd,buff,off,len,timeout);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;tcp read fd:&quot;</span>,fd)</span><br><span class="line">        print_bytes(buff);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SSL_write(long sslNativePointer, FileDescriptor fd,</span></span><br><span class="line"><span class="comment">//             SSLHandshakeCallbacks shc, byte[] b, int off, int len, int writeTimeoutMillis)</span></span><br><span class="line"><span class="comment">//SSL_read(long sslNativePointer, FileDescriptor fd, SSLHandshakeCallbacks shc,</span></span><br><span class="line"><span class="comment">//             byte[] b, int off, int len, int readTimeoutMillis)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSocketData</span>(<span class="params">fd</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;fd:&quot;</span>,fd);</span><br><span class="line">    <span class="keyword">var</span> socketType=Socket.type(fd)</span><br><span class="line">    <span class="keyword">if</span>(socketType!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> res=<span class="string">&quot;type:&quot;</span>+socketType+<span class="string">&quot;,loadAddress:&quot;</span>+<span class="built_in">JSON</span>.stringify(Socket.localAddress(fd))+<span class="string">&quot;,peerAddress&quot;</span>+<span class="built_in">JSON</span>.stringify(Socket.peerAddress(fd));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;type:&quot;</span>+socketType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSocketData2</span>(<span class="params">stream</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data0=stream.this$<span class="number">0.</span>value;</span><br><span class="line">    <span class="keyword">var</span> sockdata=data0.socket.value;</span><br><span class="line">    <span class="keyword">return</span> sockdata;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_ssl</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> NativeCryptoClass= Java.use(<span class="string">&quot;com.android.org.conscrypt.NativeCrypto&quot;</span>);</span><br><span class="line">    NativeCryptoClass.SSL_write.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">sslPtr,fd,shc,b,off,len,timeout</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;enter SSL_write&quot;</span>);</span><br><span class="line">        print_bytes(b);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.SSL_write(sslPtr,fd,shc,b,off,len,timeout);</span><br><span class="line">    &#125;;</span><br><span class="line">    NativeCryptoClass.SSL_read.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">sslPtr,fd,shc,b,off,len,timeout</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;enter SSL_read&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> res=<span class="built_in">this</span>.SSL_read(sslPtr,fd,shc,b,off,len,timeout);</span><br><span class="line">        print_bytes(b);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SSLOutputStream  write(byte[] buf, int offset, int byteCount)</span></span><br><span class="line"><span class="comment">//SSLInputStream     read(byte[] buf, int offset, int byteCount)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_ssl2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> SSLOutputClass=Java.use(<span class="string">&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream&quot;</span>);</span><br><span class="line">    SSLOutputClass.write.overload(<span class="string">&#x27;[B&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).implementation=<span class="function"><span class="keyword">function</span>(<span class="params">buf,off,cnt</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(getSocketData2(<span class="built_in">this</span>));</span><br><span class="line">        print_bytes(buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.write(buf,off,cnt);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> SSLInputClass=Java.use(<span class="string">&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream&quot;</span>);</span><br><span class="line">    SSLInputClass.read.overload(<span class="string">&#x27;[B&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).implementation=<span class="function"><span class="keyword">function</span>(<span class="params">buf,off,cnt</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> res=<span class="built_in">this</span>.read(buf,off,cnt);</span><br><span class="line">        <span class="built_in">console</span>.log(getSocketData2(<span class="built_in">this</span>));</span><br><span class="line">        print_bytes(buf);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//jni的ssl的加密数据hook</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_jni_ssl_enc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> writePtr=Module.getExportByName(<span class="string">&quot;libc.so&quot;</span>,<span class="string">&quot;write&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> readPtr=Module.getExportByName(<span class="string">&quot;libc.so&quot;</span>,<span class="string">&quot;read&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;write:&quot;</span>,writePtr,<span class="string">&quot;,read:&quot;</span>,readPtr);</span><br><span class="line">    Interceptor.attach(writePtr,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> fd=args[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">var</span> buff=args[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">var</span> size=args[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">var</span> sockdata=getSocketData(fd.toInt32());</span><br><span class="line">            <span class="keyword">if</span>(sockdata.indexOf(<span class="string">&quot;tcp&quot;</span>))&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(sockdata);</span><br><span class="line">                <span class="built_in">console</span>.log(hexdump(buff,&#123;<span class="attr">length</span>:size.toInt32()&#125;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Interceptor.attach(readPtr,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.fd=args[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">this</span>.buff=args[<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">this</span>.size=args[<span class="number">2</span>];</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> sockdata=getSocketData(<span class="built_in">this</span>.fd.toInt32());</span><br><span class="line">            <span class="keyword">if</span>(sockdata.indexOf(<span class="string">&quot;tcp&quot;</span>))&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(sockdata);</span><br><span class="line">                <span class="built_in">console</span>.log(hexdump(<span class="built_in">this</span>.buff,&#123;<span class="attr">length</span>:<span class="built_in">this</span>.size.toInt32()&#125;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//jni的ssl明文数据hook</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_jni_ssl</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sslWritePtr=Module.getExportByName(<span class="string">&quot;libssl.so&quot;</span>,<span class="string">&quot;SSL_write&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> sslReadPtr=Module.getExportByName(<span class="string">&quot;libssl.so&quot;</span>,<span class="string">&quot;SSL_read&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;sslWrite:&quot;</span>,sslWritePtr,<span class="string">&quot;,sslRead:&quot;</span>,sslReadPtr);</span><br><span class="line">    <span class="keyword">var</span> sslGetFdPtr=Module.getExportByName(<span class="string">&quot;libssl.so&quot;</span>,<span class="string">&quot;SSL_get_rfd&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> sslGetFdFunc=<span class="keyword">new</span> NativeFunction(sslGetFdPtr,<span class="string">&#x27;int&#x27;</span>,[<span class="string">&#x27;pointer&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int SSL_write(SSL *ssl, const void *buf, int num)</span></span><br><span class="line">    Interceptor.attach(sslWritePtr,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> sslPtr=args[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">var</span> buff=args[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">var</span> size=args[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">var</span> fd=sslGetFdFunc(sslPtr);</span><br><span class="line">            <span class="keyword">var</span> sockdata=getSocketData(fd);</span><br><span class="line">            <span class="built_in">console</span>.log(sockdata);</span><br><span class="line">            <span class="built_in">console</span>.log(hexdump(buff,&#123;<span class="attr">length</span>:size.toInt32()&#125;));</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//int SSL_read(SSL *ssl, void *buf, int num)</span></span><br><span class="line">    Interceptor.attach(sslReadPtr,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.sslPtr=args[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">this</span>.buff=args[<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">this</span>.size=args[<span class="number">2</span>];</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> fd=sslGetFdFunc(<span class="built_in">this</span>.sslPtr);</span><br><span class="line">            <span class="keyword">var</span> sockdata=getSocketData(fd);</span><br><span class="line">            <span class="built_in">console</span>.log(sockdata);</span><br><span class="line">            <span class="built_in">console</span>.log(hexdump(<span class="built_in">this</span>.buff,&#123;<span class="attr">length</span>:<span class="built_in">this</span>.size.toInt32()&#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_jni_tcp</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sendtoPtr=Module.getExportByName(<span class="string">&quot;libc.so&quot;</span>,<span class="string">&quot;sendto&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> recvfromPtr=Module.getExportByName(<span class="string">&quot;libc.so&quot;</span>,<span class="string">&quot;recvfrom&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;sendto:&quot;</span>,sendtoPtr,<span class="string">&quot;,recvfrom:&quot;</span>,recvfromPtr);</span><br><span class="line">    <span class="comment">//sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len)</span></span><br><span class="line">    Interceptor.attach(sendtoPtr,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> fd=args[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">var</span> buff=args[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">var</span> size=args[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">var</span> sockdata=getSocketData(fd.toInt32());</span><br><span class="line">            <span class="built_in">console</span>.log(sockdata);</span><br><span class="line">            <span class="built_in">console</span>.log(hexdump(buff,&#123;<span class="attr">length</span>:size.toInt32()&#125;));</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len)</span></span><br><span class="line">    Interceptor.attach(recvfromPtr,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.fd=args[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">this</span>.buff=args[<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">this</span>.size=args[<span class="number">2</span>];</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> sockdata=getSocketData(<span class="built_in">this</span>.fd.toInt32());</span><br><span class="line">            <span class="built_in">console</span>.log(sockdata);</span><br><span class="line">            <span class="built_in">console</span>.log(hexdump(<span class="built_in">this</span>.buff,&#123;<span class="attr">length</span>:<span class="built_in">this</span>.size.toInt32()&#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_java</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// hook_tcp();</span></span><br><span class="line">        <span class="comment">// hook_ssl();</span></span><br><span class="line">        <span class="comment">// hook_ssl2();</span></span><br><span class="line">        <span class="comment">// hook_jni_tcp();</span></span><br><span class="line">        hook_jni_ssl_enc();</span><br><span class="line">        hook_jni_ssl();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Java.enumerateLoadedClassesSync().forEach(<span class="function"><span class="keyword">function</span>(<span class="params">className</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(className.indexOf(name)!=<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    hook_java();</span><br><span class="line">    <span class="comment">// getFullName(&quot;SSLOutputStream&quot;)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></table></figure>

<p>跑起来后的结果如下。成功抓到ssl的密文和ssl的明文。想要回溯的话直接加上打印堆栈即可。</p>
<p><img src="/2021/05/04/zhuabao/image-20210531232115639.png" alt="image-20210531232115639"></p>
<p><img src="/2021/05/04/zhuabao/image-20210531232306136.png" alt="image-20210531232306136"></p>
<h2 id="中间人抓包"><a href="#中间人抓包" class="headerlink" title="中间人抓包"></a>中间人抓包</h2><p>我们常常用的burp和charles就是属于中间人抓包。前面我们看过了https的加密方式，需要使用证书的公钥去交换加密再发送数据。那么这些工具是如何做到抓取https的数据包并解密的呢。方式就和他的名字一样。这个抓包的应用他也有一个证书。然后客户端向服务端发送数据时，中间人就假装自己是服务端。将自己证书的公钥发送给客户端，然后拿到客户发送的数据后，再假装自己是客户端，把自己的证书公钥发送给服务端。大概可以想象成一个双面间谍。客户端面前冒充服务端，服务端面前冒充客户端。下面贴上网上找的交互的示意图，包括握手流程都写的非常详细了。</p>
<p><img src="/2021/05/04/zhuabao/image-20210602233051668.png" alt="image-20210602233051668"></p>
<p>而使用中间人抓包。常常会碰到防抓包手段。这些手段一般都是针对证书的检测。</p>
<h3 id="1、服务端验证客户端证书"><a href="#1、服务端验证客户端证书" class="headerlink" title="1、服务端验证客户端证书"></a>1、服务端验证客户端证书</h3><p>服务端会检测客户端交互使用的证书是不是正确的。这种情况我们可以直接将客户端里面使用的证书导出来，然后设置让charles使用指定的证书来抓包。这里导出证书的办法有两种。</p>
<p>第一种是直接hook代码中设置证书的地方，直接重新设置一次空的证书。让其不要验证。</p>
<p>这里看一个网上找的android设置证书的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">val resourceStream = resources.openRawResource(R.raw.infinisign_cert)</span><br><span class="line">val keyStoreType = KeyStore.getDefaultType()</span><br><span class="line">val keyStore = KeyStore.getInstance(keyStoreType)</span><br><span class="line">keyStore.load(resourceStream, <span class="keyword">null</span>)</span><br><span class="line">  </span><br><span class="line">val trustManagerAlgorithm = TrustManagerFactory.getDefaultAlgorithm()</span><br><span class="line">val trustManagerFactory = TrustManagerFactory.getInstance(trustManagerAlgorithm)</span><br><span class="line">trustManagerFactory.init(keyStore)</span><br><span class="line">  </span><br><span class="line">val sslContext = SSLContext.getInstance(<span class="string">&quot;TLS&quot;</span>)</span><br><span class="line">sslContext.init(<span class="keyword">null</span>, trustManagerFactory.trustManagers, <span class="keyword">null</span>)</span><br><span class="line">val url = URL(<span class="string">&quot;http://infinisign.com/&quot;</span>)</span><br><span class="line">val urlConnection = url.openConnection() as HttpsURLConnection</span><br><span class="line">urlConnection.sslSocketFactory = sslContext.socketFactory</span><br></pre></td></tr></table></figure>

<p>大概意思是从资源文件加载到证书。然后用keyStore加载证书。后面再使用。所以我们直接看看keyStore的load函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(InputStream stream, <span class="keyword">char</span>[] password)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, NoSuchAlgorithmException, CertificateException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        keyStoreSpi.engineLoad(stream, password);</span><br><span class="line">        initialized = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>还有其他方式加载证书。看下面的我网上翻的另外一个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">CertificateFactory factory = CertificateFactory.getInstance(<span class="string">&quot;X.509&quot;</span>);<span class="comment">//设置证书类型，X.509是一种格式标准</span></span><br><span class="line">InputStream stream;</span><br><span class="line">Certificate certificate;<span class="comment">//Certificate是证书信息封装的一个bean类</span></span><br><span class="line"></span><br><span class="line">KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());</span><br><span class="line">keyStore.load(<span class="keyword">null</span>);<span class="comment">//清除默认证书,使用我们自己制定的证书</span></span><br><span class="line"></span><br><span class="line">CertificateFactory cf = CertificateFactory.getInstance(<span class="string">&quot;X.509&quot;</span>);</span><br><span class="line">InputStream caInput = getAssets().open(<span class="string">&quot;burp.der&quot;</span>);</span><br><span class="line">Certificate cert = cf.generateCertificate(caInput);</span><br><span class="line"><span class="comment">//设置自己的证书</span></span><br><span class="line">keyStore.setCertificateEntry(<span class="string">&quot;misskings&quot;</span>,cert);</span><br><span class="line"></span><br><span class="line">TrustManagerFactory trustManagerFactory =       TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());</span><br><span class="line">trustManagerFactory.init(keyStore);<span class="comment">//通过keyStore得到信任管理器</span></span><br><span class="line"></span><br><span class="line">KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());</span><br><span class="line">keyManagerFactory.init(keyStore, <span class="string">&quot;pwd&quot;</span>.toCharArray());<span class="comment">//通过keyStore得到密匙管理器</span></span><br><span class="line"></span><br><span class="line">SSLContext sslContext = SSLContext.getInstance(<span class="string">&quot;TLS&quot;</span>);</span><br><span class="line">sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), <span class="keyword">new</span> SecureRandom());</span><br><span class="line">SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();<span class="comment">//拿到SSLSocketFactory</span></span><br><span class="line"></span><br><span class="line">TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();</span><br><span class="line"><span class="keyword">if</span> (trustManagers.length != <span class="number">1</span> || !(trustManagers[<span class="number">0</span>] <span class="keyword">instanceof</span> X509TrustManager)) &#123;</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">X509TrustManager trustManager = (X509TrustManager) trustManagers[<span class="number">0</span>];</span><br><span class="line">okHttpClient.sslSocketFactory(sslSocketFactory, trustManager)<span class="comment">//设置ssl证书</span></span><br><span class="line">okHttpClient.build();</span><br></pre></td></tr></table></figure>

<p>发现这个例子里面的keyStore.load是null。是在后面进行再设置进去的。所以如果我们处理load函数。就会没有啥效果了。我们可以找找其他hook点。比如我直接在两个init的地方进行hook</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_keystore</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> keyManager=Java.use(<span class="string">&quot;javax.net.ssl.KeyManagerFactory&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> trustManager=Java.use(<span class="string">&quot;javax.net.ssl.TrustManagerFactory&quot;</span>);</span><br><span class="line">    keyManager.init.overload(<span class="string">&#x27;java.security.KeyStore&#x27;</span>, <span class="string">&#x27;[C&#x27;</span>).implementation=<span class="function"><span class="keyword">function</span>(<span class="params">ks,pwd</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;enter keyManager init&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> savePath=<span class="string">&quot;/sdcard/keyManagerFactory_init.p12&quot;</span>;</span><br><span class="line">            <span class="keyword">var</span> outStream=Java.use(<span class="string">&quot;java.io.FileOutputStream&quot;</span>).$new(savePath);</span><br><span class="line">            ks.store(outStream,Java.use(<span class="string">&quot;java.lang.String&quot;</span>).$new(pwd).toCharArray());</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;keyManager store success&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ex)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.init(ks,pwd);</span><br><span class="line">    &#125;</span><br><span class="line">    trustManager.init.overload(<span class="string">&#x27;java.security.KeyStore&#x27;</span>).implementation=<span class="function"><span class="keyword">function</span>(<span class="params">ks</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;enter trustManager init&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> savePath=<span class="string">&quot;/sdcard/TrustManagerFactory_init.p12&quot;</span>;</span><br><span class="line">            <span class="keyword">var</span> outStream=Java.use(<span class="string">&quot;java.io.FileOutputStream&quot;</span>).$new(savePath);</span><br><span class="line">            ks.store(outStream);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;trustManager store success&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ex)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.init(ks);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们测试下自己的例子。<code>frida -U --no-pause -f com.example.zhuabao -l zhuabao.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trustManager store success</span><br><span class="line">keyManager store success</span><br></pre></td></tr></table></figure>

<p>最后导出来的文件。我对比了一下原文件。发现要去掉头部的0x43个字节（这里是因为我安卓代码里面设置了别名）和尾部的0x15个字节。就和原证书文件完全一致了。不过是否通用就不知道了。未测试多个样本。</p>
<p>第二种是直接解压apk。然后在里面搜索证书特征的文件。例如下面。大概搜一下一些证书的后缀。一般也可能直接找到。</p>
<p><img src="/2021/05/04/zhuabao/image-20210602225401073.png" alt="image-20210602225401073"></p>
<h3 id="2、客户端验证服务端证书"><a href="#2、客户端验证服务端证书" class="headerlink" title="2、客户端验证服务端证书"></a>2、客户端验证服务端证书</h3><p>大概就是客户端向服务端请求。然后服务端把自己的证书返回了。客户端验证一下证书是否正确有效。没啥问题才正常通讯。而这种判断逻辑直接在客户端的。那就直接hook修改让他不要处理就行了。</p>
<p>解决这个的开源项目有很多。</p>
<p>xposed解决方案:<a target="_blank" rel="noopener" href="https://github.com/Fuzion24/JustTrustMe">JustTrustMe</a></p>
<p>frida解决方案:<a target="_blank" rel="noopener" href="https://github.com/WooyunDota/DroidSSLUnpinning">DroidSSLUnpinning</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">king</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://missking.cc/2021/05/04/zhuabao/">http://missking.cc/2021/05/04/zhuabao/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://missking.cc" target="_blank">king的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/andorid-%E6%8A%93%E5%8C%85/">andorid,抓包</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/05/04/ollvm2/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">使用unidbg去ollvm虚假分支反混淆</div></div></a></div><div class="next-post pull-right"><a href="/2021/02/03/zuoye9/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">算法还原实战9</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/assets/blogImg/litten.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">king</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/dqzg12300"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/dqzg12300" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:king910827@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">新时代农民工</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%93%E5%8C%85%E6%96%B9%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">抓包方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%B1%82hook%E6%8A%93%E5%8C%85"><span class="toc-number">2.</span> <span class="toc-text">系统层hook抓包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81java%E5%B1%82%E7%9A%84%E6%8A%93%E5%8C%85"><span class="toc-number">2.1.</span> <span class="toc-text">1、java层的抓包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81jni%E5%B1%82%E6%8A%93http%E5%8C%85"><span class="toc-number">2.2.</span> <span class="toc-text">2、jni层抓http包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81java%E5%B1%82ssl%E6%8A%93%E5%8C%85"><span class="toc-number">2.3.</span> <span class="toc-text">3、java层ssl抓包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81jni%E5%B1%82%E6%8A%93https%E5%8C%85"><span class="toc-number">2.4.</span> <span class="toc-text">4、jni层抓https包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%8A%93%E5%8C%85"><span class="toc-number">3.</span> <span class="toc-text">中间人抓包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%AA%8C%E8%AF%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%81%E4%B9%A6"><span class="toc-number">3.1.</span> <span class="toc-text">1、服务端验证客户端证书</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%AA%8C%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%81%E4%B9%A6"><span class="toc-number">3.2.</span> <span class="toc-text">2、客户端验证服务端证书</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/09/05/kernel1-0/" title="aosp12内核编译开启硬件断点和kprobes记录">aosp12内核编译开启硬件断点和kprobes记录</a><time datetime="2022-09-05T13:01:17.000Z" title="发表于 2022-09-05 13:01:17">2022-09-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/04/11/Kernel1/" title="linux内核书籍阅读笔记1">linux内核书籍阅读笔记1</a><time datetime="2022-04-11T22:38:34.000Z" title="发表于 2022-04-11 22:38:34">2022-04-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/03/20/CPU%E5%9F%BA%E7%A1%80/" title="逆向工程权威指南的看书笔记">逆向工程权威指南的看书笔记</a><time datetime="2022-03-20T15:38:13.000Z" title="发表于 2022-03-20 15:38:13">2022-03-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/01/27/MikRom/" title="FartExt超进化之奇奇怪怪的新ROM工具MikRom">FartExt超进化之奇奇怪怪的新ROM工具MikRom</a><time datetime="2022-01-27T13:48:38.000Z" title="发表于 2022-01-27 13:48:38">2022-01-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/07/26/fartext/" title="FartExt之优化更深主动调用的FART10">FartExt之优化更深主动调用的FART10</a><time datetime="2021-07-26T21:31:05.000Z" title="发表于 2021-07-26 21:31:05">2021-07-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By king</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'ihIPa0lRcHcfVzXqcboVznyu-gzGzoHsz',
      appKey: 'YB8y22BOhfzrVioINMUoEqxd',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'http://missking.cc/2021/05/04/zhuabao/'
    this.page.identifier = '2021/05/04/zhuabao/'
    this.page.title = 'android抓包学习的整理和归纳'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>